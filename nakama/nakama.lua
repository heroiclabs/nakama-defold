-- Code generated by codegen/generate-nakama-main.go. DO NOT EDIT.

--[[--
The Nakama client SDK for Defold.

@module nakama
]]

local log = require "nakama.util.log"
local retries = require "nakama.util.retries"
local socket = require "nakama.socket"

local M = {}

-- helpers for parameter type checking
local function check_array(v) return type(v) == "table" end
local function check_string(v) return type(v) == "string" end
local function check_integer(v) return type(v) == "number" end
local function check_object(v) return type(v) == "table" end
local function check_boolean(v) return type(v) == "boolean" end

--
-- The low level client for the Nakama API.
--

local _config = {}


--- Create a Nakama client instance.
-- @param config A table of configuration options.
-- config.engine - Engine specific implementations.
-- config.host
-- config.port
-- config.timeout
-- config.use_ssl - Use secure or non-secure sockets.
-- config.bearer_token
-- config.username
-- config.password
-- @return Nakama Client instance.
function M.create_client(config)
	assert(config, "You must provide a configuration")
	assert(config.host, "You must provide a host")
	assert(config.port, "You must provide a port")
	assert(config.engine, "You must provide an engine")
	assert(type(config.engine.http) == "function", "The engine must provide the 'http' function")
	assert(type(config.engine.socket_create) == "function", "The engine must provide the 'socket_create' function")
	assert(type(config.engine.socket_connect) == "function", "The engine must provide the 'socket_connect' function")
	assert(type(config.engine.socket_send) == "function", "The engine must provide the 'socket_send' function")
	log("init()")

	local client = {}
	local scheme = config.use_ssl and "https" or "http"
	client.engine = config.engine
	client.config = {}
	client.config.host = config.host
	client.config.port = config.port
	client.config.http_uri = ("%s://%s:%d"):format(scheme, config.host, config.port)
	client.config.bearer_token = config.bearer_token
	client.config.username = config.username
	client.config.password = config.password
	client.config.timeout = config.timeout or 10
	client.config.use_ssl = config.use_ssl
	client.config.retry_policy = config.retry_policy or retries.none()

	local ignored_fns = { create_client = true, sync = true }
	for name,fn in pairs(M) do
		if not ignored_fns[name] and type(fn) == "function" then
			log("setting " .. name)
			client[name] = function(...) return fn(client, ...) end
		end
	end

	return client
end


--- Create a Nakama socket.
-- @param client The client to create the socket for.
-- @return Socket instance.
function M.create_socket(client)
	assert(client, "You must provide a client")
	return socket.create(client)
end

--- Set Nakama client bearer token.
-- @param client Nakama client.
-- @param bearer_token Authorization bearer token.
function M.set_bearer_token(client, bearer_token)
	assert(client, "You must provide a client")
	client.config.bearer_token = bearer_token
end

--
-- Nakama REST API
--


--- api_operator
-- Operator that can be used to override the one set in the leaderboard.
-- 
--  - NO_OVERRIDE: Do not override the leaderboard operator.
--  - BEST: Override the leaderboard operator with BEST.
--  - SET: Override the leaderboard operator with SET.
--  - INCREMENT: Override the leaderboard operator with INCREMENT.
--  - DECREMENT: Override the leaderboard operator with DECREMENT.
M.APIOPERATOR_NO_OVERRIDE = "NO_OVERRIDE"
M.APIOPERATOR_BEST = "BEST"
M.APIOPERATOR_SET = "SET"
M.APIOPERATOR_INCREMENT = "INCREMENT"
M.APIOPERATOR_DECREMENT = "DECREMENT"

--- api_store_environment
-- - UNKNOWN: Unknown environment.
--  - SANDBOX: Sandbox/test environment.
--  - PRODUCTION: Production environment.
M.APISTOREENVIRONMENT_UNKNOWN = "UNKNOWN"
M.APISTOREENVIRONMENT_SANDBOX = "SANDBOX"
M.APISTOREENVIRONMENT_PRODUCTION = "PRODUCTION"

--- api_store_provider
-- - APPLE_APP_STORE: Apple App Store
--  - GOOGLE_PLAY_STORE: Google Play Store
--  - HUAWEI_APP_GALLERY: Huawei App Gallery
--  - FACEBOOK_INSTANT_STORE: Facebook Instant Store
M.APISTOREPROVIDER_APPLE_APP_STORE = "APPLE_APP_STORE"
M.APISTOREPROVIDER_GOOGLE_PLAY_STORE = "GOOGLE_PLAY_STORE"
M.APISTOREPROVIDER_HUAWEI_APP_GALLERY = "HUAWEI_APP_GALLERY"
M.APISTOREPROVIDER_FACEBOOK_INSTANT_STORE = "FACEBOOK_INSTANT_STORE"



local api_session = require "nakama.session"
local json = require "nakama.util.json"
local async = require "nakama.util.async"
local uri = require "nakama.util.uri"
local uri_encode = uri.encode

-- cancellation tokens associated with a coroutine
local cancellation_tokens = {}

-- cancel a cancellation token
function M.cancel(token)
	assert(token)
	token.cancelled = true
end

-- create a cancellation token
-- use this to cancel an ongoing API call or a sequence of API calls
-- @return token Pass the token to a call to nakama.sync() or to any of the API calls
function M.cancellation_token()
	local token = {
		cancelled = false
	}
	function token.cancel()
		token.cancelled = true
	end
	return token
end

-- Private
-- Run code within a coroutine
-- @param fn The code to run
-- @param cancellation_token Optional cancellation token to cancel the running code
function M.sync(fn, cancellation_token)
	assert(fn)
	local co = nil
	co = coroutine.create(function()
		cancellation_tokens[co] = cancellation_token
		fn()
		cancellation_tokens[co] = nil
	end)
	local ok, err = coroutine.resume(co)
	if not ok then
		log(err)
		cancellation_tokens[co] = nil
	end
end

-- http request helper used to reduce code duplication in all API functions below
local function http(client, callback, url_path, query_params, method, post_data, retry_policy, cancellation_token, handler_fn)
	if callback then
		log(url_path, "with callback")
		client.engine.http(client.config, url_path, query_params, method, post_data, retry_policy, cancellation_token, function(result)
			if not cancellation_token or not cancellation_token.cancelled then
				callback(handler_fn(result))
			end
		end)
	else
		log(url_path, "with coroutine")
		local co = coroutine.running()
		assert(co, "You must be running this from withing a coroutine")

		-- get cancellation token associated with this coroutine
		cancellation_token = cancellation_tokens[co]
		if cancellation_token and cancellation_token.cancelled then
			cancellation_tokens[co] = nil
			return
		end

		return async(function(done)
			client.engine.http(client.config, url_path, query_params, method, post_data, retry_policy, cancellation_token, function(result)
				if cancellation_token and cancellation_token.cancelled then
					cancellation_tokens[co] = nil
					return
				end
				done(handler_fn(result))
			end)
		end)
	end
end


--- healthcheck
-- A healthcheck which load balancers can use to check the service.
-- @param client
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.healthcheck(client, callback, retry_policy, cancellation_token)
	log("healthcheck()")
	assert(client, "You must provide a client")


	local url_path = "/healthcheck"

	local query_params = {}

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- get_account
-- Fetch the current user&#x27;s account.
-- @param client
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.get_account(client, callback, retry_policy, cancellation_token)
	log("get_account()")
	assert(client, "You must provide a client")


	local url_path = "/v2/account"

	local query_params = {}

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- delete_account
-- Delete the current user&#x27;s account.
-- @param client
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.delete_account(client, callback, retry_policy, cancellation_token)
	log("delete_account()")
	assert(client, "You must provide a client")


	local url_path = "/v2/account"

	local query_params = {}

	local post_data = nil

	return http(client, callback, url_path, query_params, "DELETE", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- update_account
-- Update fields in the current user&#x27;s account.
-- @param client
-- @param username_string (string) The username of the user&#x27;s account. (REQUIRED)
-- @param displayName_string (string) The display name of the user. (REQUIRED)
-- @param avatarUrl_string (string) A URL for an avatar image. (REQUIRED)
-- @param langTag_string (string) The language expected to be a tag which follows the BCP-47 spec. (REQUIRED)
-- @param location_string (string) The location set by the user. (REQUIRED)
-- @param timezone_string (string) The timezone set by the user. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.update_account(client, username_string, displayName_string, avatarUrl_string, langTag_string, location_string, timezone_string, callback, retry_policy, cancellation_token)
	log("update_account()")
	assert(client, "You must provide a client")
	assert(not username_string or check_string(username_string), "Argument 'username_string' must be 'nil' or of type 'string'")
	assert(not displayName_string or check_string(displayName_string), "Argument 'displayName_string' must be 'nil' or of type 'string'")
	assert(not avatarUrl_string or check_string(avatarUrl_string), "Argument 'avatarUrl_string' must be 'nil' or of type 'string'")
	assert(not langTag_string or check_string(langTag_string), "Argument 'langTag_string' must be 'nil' or of type 'string'")
	assert(not location_string or check_string(location_string), "Argument 'location_string' must be 'nil' or of type 'string'")
	assert(not timezone_string or check_string(timezone_string), "Argument 'timezone_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/account"

	local query_params = {}

	local post_data = json.encode({
		["username"] = username_string,
		["displayName"] = displayName_string,
		["avatarUrl"] = avatarUrl_string,
		["langTag"] = langTag_string,
		["location"] = location_string,
		["timezone"] = timezone_string,
	})

	return http(client, callback, url_path, query_params, "PUT", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- authenticate_apple
-- Authenticate a user with an Apple ID against the server.
-- @param client
-- @param token_string (string) The ID token received from Apple to validate. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param create_boolean (boolean) Register the account if the user does not already exist.
-- @param username_string (string) Set the username on the account at register. Must be unique.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.authenticate_apple(client, token_string, vars_table, create_boolean, username_string, callback, retry_policy, cancellation_token)
	log("authenticate_apple()")
	assert(client, "You must provide a client")
	assert(not token_string or check_string(token_string), "Argument 'token_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/apple"

	local query_params = {}
	query_params["create"] = create_boolean
	query_params["username"] = username_string

	local post_data = json.encode({
		["token"] = token_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		if not result.error then
			result = api_session.create(result)
		end
		return result
	end)
end

--- authenticate_custom
-- Authenticate a user with a custom id against the server.
-- @param client
-- @param id_string (string) A custom identifier. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param create_boolean (boolean) Register the account if the user does not already exist.
-- @param username_string (string) Set the username on the account at register. Must be unique.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.authenticate_custom(client, id_string, vars_table, create_boolean, username_string, callback, retry_policy, cancellation_token)
	log("authenticate_custom()")
	assert(client, "You must provide a client")
	assert(not id_string or check_string(id_string), "Argument 'id_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/custom"

	local query_params = {}
	query_params["create"] = create_boolean
	query_params["username"] = username_string

	local post_data = json.encode({
		["id"] = id_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		if not result.error then
			result = api_session.create(result)
		end
		return result
	end)
end

--- authenticate_device
-- Authenticate a user with a device id against the server.
-- @param client
-- @param id_string (string) A device identifier. Should be obtained by a platform-specific device API. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param create_boolean (boolean) Register the account if the user does not already exist.
-- @param username_string (string) Set the username on the account at register. Must be unique.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.authenticate_device(client, id_string, vars_table, create_boolean, username_string, callback, retry_policy, cancellation_token)
	log("authenticate_device()")
	assert(client, "You must provide a client")
	assert(not id_string or check_string(id_string), "Argument 'id_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/device"

	local query_params = {}
	query_params["create"] = create_boolean
	query_params["username"] = username_string

	local post_data = json.encode({
		["id"] = id_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		if not result.error then
			result = api_session.create(result)
		end
		return result
	end)
end

--- authenticate_email
-- Authenticate a user with an email+password against the server.
-- @param client
-- @param email_string (string) A valid RFC-5322 email address. (REQUIRED)
-- @param password_string (string) A password for the user account.
-- 
-- Ignored with unlink operations. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param create_boolean (boolean) Register the account if the user does not already exist.
-- @param username_string (string) Set the username on the account at register. Must be unique.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.authenticate_email(client, email_string, password_string, vars_table, create_boolean, username_string, callback, retry_policy, cancellation_token)
	log("authenticate_email()")
	assert(client, "You must provide a client")
	assert(not email_string or check_string(email_string), "Argument 'email_string' must be 'nil' or of type 'string'")
	assert(not password_string or check_string(password_string), "Argument 'password_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/email"

	local query_params = {}
	query_params["create"] = create_boolean
	query_params["username"] = username_string

	local post_data = json.encode({
		["email"] = email_string,
		["password"] = password_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		if not result.error then
			result = api_session.create(result)
		end
		return result
	end)
end

--- authenticate_facebook
-- Authenticate a user with a Facebook OAuth token against the server.
-- @param client
-- @param token_string (string) The OAuth token received from Facebook to access their profile API. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param create_boolean (boolean) Register the account if the user does not already exist.
-- @param username_string (string) Set the username on the account at register. Must be unique.
-- @param sync_boolean (boolean) Import Facebook friends for the user.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.authenticate_facebook(client, token_string, vars_table, create_boolean, username_string, sync_boolean, callback, retry_policy, cancellation_token)
	log("authenticate_facebook()")
	assert(client, "You must provide a client")
	assert(not token_string or check_string(token_string), "Argument 'token_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/facebook"

	local query_params = {}
	query_params["create"] = create_boolean
	query_params["username"] = username_string
	query_params["sync"] = sync_boolean

	local post_data = json.encode({
		["token"] = token_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		if not result.error then
			result = api_session.create(result)
		end
		return result
	end)
end

--- authenticate_facebook_instant_game
-- Authenticate a user with a Facebook Instant Game token against the server.
-- @param client
-- @param signedPlayerInfo_string (string) The Facebook Instant Game account details. The OAuth token received from a Facebook Instant Game that may be decoded with the Application Secret (must be available with the nakama configuration) (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param create_boolean (boolean) Register the account if the user does not already exist.
-- @param username_string (string) Set the username on the account at register. Must be unique.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.authenticate_facebook_instant_game(client, signedPlayerInfo_string, vars_table, create_boolean, username_string, callback, retry_policy, cancellation_token)
	log("authenticate_facebook_instant_game()")
	assert(client, "You must provide a client")
	assert(not signedPlayerInfo_string or check_string(signedPlayerInfo_string), "Argument 'signedPlayerInfo_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/facebookinstantgame"

	local query_params = {}
	query_params["create"] = create_boolean
	query_params["username"] = username_string

	local post_data = json.encode({
		["signedPlayerInfo"] = signedPlayerInfo_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		if not result.error then
			result = api_session.create(result)
		end
		return result
	end)
end

--- authenticate_game_center
-- Authenticate a user with Apple&#x27;s GameCenter against the server.
-- @param client
-- @param playerId_string (string) Player ID (generated by GameCenter). (REQUIRED)
-- @param bundleId_string (string) Bundle ID (generated by GameCenter). (REQUIRED)
-- @param timestampSeconds_string (string) Time since UNIX epoch when the signature was created. (REQUIRED)
-- @param salt_string (string) A random &quot;NSString&quot; used to compute the hash and keep it randomized. (REQUIRED)
-- @param signature_string (string) The verification signature data generated. (REQUIRED)
-- @param publicKeyUrl_string (string) The URL for the public encryption key. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param create_boolean (boolean) Register the account if the user does not already exist.
-- @param username_string (string) Set the username on the account at register. Must be unique.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.authenticate_game_center(client, playerId_string, bundleId_string, timestampSeconds_string, salt_string, signature_string, publicKeyUrl_string, vars_table, create_boolean, username_string, callback, retry_policy, cancellation_token)
	log("authenticate_game_center()")
	assert(client, "You must provide a client")
	assert(not playerId_string or check_string(playerId_string), "Argument 'playerId_string' must be 'nil' or of type 'string'")
	assert(not bundleId_string or check_string(bundleId_string), "Argument 'bundleId_string' must be 'nil' or of type 'string'")
	assert(not timestampSeconds_string or check_string(timestampSeconds_string), "Argument 'timestampSeconds_string' must be 'nil' or of type 'string'")
	assert(not salt_string or check_string(salt_string), "Argument 'salt_string' must be 'nil' or of type 'string'")
	assert(not signature_string or check_string(signature_string), "Argument 'signature_string' must be 'nil' or of type 'string'")
	assert(not publicKeyUrl_string or check_string(publicKeyUrl_string), "Argument 'publicKeyUrl_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/gamecenter"

	local query_params = {}
	query_params["create"] = create_boolean
	query_params["username"] = username_string

	local post_data = json.encode({
		["playerId"] = playerId_string,
		["bundleId"] = bundleId_string,
		["timestampSeconds"] = timestampSeconds_string,
		["salt"] = salt_string,
		["signature"] = signature_string,
		["publicKeyUrl"] = publicKeyUrl_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		if not result.error then
			result = api_session.create(result)
		end
		return result
	end)
end

--- authenticate_google
-- Authenticate a user with Google against the server.
-- @param client
-- @param token_string (string) The OAuth token received from Google to access their profile API. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param create_boolean (boolean) Register the account if the user does not already exist.
-- @param username_string (string) Set the username on the account at register. Must be unique.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.authenticate_google(client, token_string, vars_table, create_boolean, username_string, callback, retry_policy, cancellation_token)
	log("authenticate_google()")
	assert(client, "You must provide a client")
	assert(not token_string or check_string(token_string), "Argument 'token_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/google"

	local query_params = {}
	query_params["create"] = create_boolean
	query_params["username"] = username_string

	local post_data = json.encode({
		["token"] = token_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		if not result.error then
			result = api_session.create(result)
		end
		return result
	end)
end

--- authenticate_steam
-- Authenticate a user with Steam against the server.
-- @param client
-- @param token_string (string) The account token received from Steam to access their profile API. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param create_boolean (boolean) Register the account if the user does not already exist.
-- @param username_string (string) Set the username on the account at register. Must be unique.
-- @param sync_boolean (boolean) Import Steam friends for the user.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.authenticate_steam(client, token_string, vars_table, create_boolean, username_string, sync_boolean, callback, retry_policy, cancellation_token)
	log("authenticate_steam()")
	assert(client, "You must provide a client")
	assert(not token_string or check_string(token_string), "Argument 'token_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/steam"

	local query_params = {}
	query_params["create"] = create_boolean
	query_params["username"] = username_string
	query_params["sync"] = sync_boolean

	local post_data = json.encode({
		["token"] = token_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		if not result.error then
			result = api_session.create(result)
		end
		return result
	end)
end

--- link_apple
-- Add an Apple ID to the social profiles on the current user&#x27;s account.
-- @param client
-- @param token_string (string) The ID token received from Apple to validate. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.link_apple(client, token_string, vars_table, callback, retry_policy, cancellation_token)
	log("link_apple()")
	assert(client, "You must provide a client")
	assert(not token_string or check_string(token_string), "Argument 'token_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/account/link/apple"

	local query_params = {}

	local post_data = json.encode({
		["token"] = token_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- link_custom
-- Add a custom ID to the social profiles on the current user&#x27;s account.
-- @param client
-- @param id_string (string) A custom identifier. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.link_custom(client, id_string, vars_table, callback, retry_policy, cancellation_token)
	log("link_custom()")
	assert(client, "You must provide a client")
	assert(not id_string or check_string(id_string), "Argument 'id_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/account/link/custom"

	local query_params = {}

	local post_data = json.encode({
		["id"] = id_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- link_device
-- Add a device ID to the social profiles on the current user&#x27;s account.
-- @param client
-- @param id_string (string) A device identifier. Should be obtained by a platform-specific device API. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.link_device(client, id_string, vars_table, callback, retry_policy, cancellation_token)
	log("link_device()")
	assert(client, "You must provide a client")
	assert(not id_string or check_string(id_string), "Argument 'id_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/account/link/device"

	local query_params = {}

	local post_data = json.encode({
		["id"] = id_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- link_email
-- Add an email+password to the social profiles on the current user&#x27;s account.
-- @param client
-- @param email_string (string) A valid RFC-5322 email address. (REQUIRED)
-- @param password_string (string) A password for the user account.
-- 
-- Ignored with unlink operations. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.link_email(client, email_string, password_string, vars_table, callback, retry_policy, cancellation_token)
	log("link_email()")
	assert(client, "You must provide a client")
	assert(not email_string or check_string(email_string), "Argument 'email_string' must be 'nil' or of type 'string'")
	assert(not password_string or check_string(password_string), "Argument 'password_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/account/link/email"

	local query_params = {}

	local post_data = json.encode({
		["email"] = email_string,
		["password"] = password_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- link_facebook
-- Add Facebook to the social profiles on the current user&#x27;s account.
-- @param client
-- @param token_string (string) The OAuth token received from Facebook to access their profile API. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param sync_boolean (boolean) Import Facebook friends for the user.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.link_facebook(client, token_string, vars_table, sync_boolean, callback, retry_policy, cancellation_token)
	log("link_facebook()")
	assert(client, "You must provide a client")
	assert(not token_string or check_string(token_string), "Argument 'token_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/account/link/facebook"

	local query_params = {}
	query_params["sync"] = sync_boolean

	local post_data = json.encode({
		["token"] = token_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- link_facebook_instant_game
-- Add Facebook Instant Game to the social profiles on the current user&#x27;s account.
-- @param client
-- @param signedPlayerInfo_string (string) Send a Facebook Instant Game token to the server. Used with authenticate/link/unlink. The OAuth token received from a Facebook Instant Game that may be decoded with the Application Secret (must be available with the nakama configuration) (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.link_facebook_instant_game(client, signedPlayerInfo_string, vars_table, callback, retry_policy, cancellation_token)
	log("link_facebook_instant_game()")
	assert(client, "You must provide a client")
	assert(not signedPlayerInfo_string or check_string(signedPlayerInfo_string), "Argument 'signedPlayerInfo_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/account/link/facebookinstantgame"

	local query_params = {}

	local post_data = json.encode({
		["signedPlayerInfo"] = signedPlayerInfo_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- link_game_center
-- Add Apple&#x27;s GameCenter to the social profiles on the current user&#x27;s account.
-- @param client
-- @param playerId_string (string) Player ID (generated by GameCenter). (REQUIRED)
-- @param bundleId_string (string) Bundle ID (generated by GameCenter). (REQUIRED)
-- @param timestampSeconds_string (string) Time since UNIX epoch when the signature was created. (REQUIRED)
-- @param salt_string (string) A random &quot;NSString&quot; used to compute the hash and keep it randomized. (REQUIRED)
-- @param signature_string (string) The verification signature data generated. (REQUIRED)
-- @param publicKeyUrl_string (string) The URL for the public encryption key. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.link_game_center(client, playerId_string, bundleId_string, timestampSeconds_string, salt_string, signature_string, publicKeyUrl_string, vars_table, callback, retry_policy, cancellation_token)
	log("link_game_center()")
	assert(client, "You must provide a client")
	assert(not playerId_string or check_string(playerId_string), "Argument 'playerId_string' must be 'nil' or of type 'string'")
	assert(not bundleId_string or check_string(bundleId_string), "Argument 'bundleId_string' must be 'nil' or of type 'string'")
	assert(not timestampSeconds_string or check_string(timestampSeconds_string), "Argument 'timestampSeconds_string' must be 'nil' or of type 'string'")
	assert(not salt_string or check_string(salt_string), "Argument 'salt_string' must be 'nil' or of type 'string'")
	assert(not signature_string or check_string(signature_string), "Argument 'signature_string' must be 'nil' or of type 'string'")
	assert(not publicKeyUrl_string or check_string(publicKeyUrl_string), "Argument 'publicKeyUrl_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/account/link/gamecenter"

	local query_params = {}

	local post_data = json.encode({
		["playerId"] = playerId_string,
		["bundleId"] = bundleId_string,
		["timestampSeconds"] = timestampSeconds_string,
		["salt"] = salt_string,
		["signature"] = signature_string,
		["publicKeyUrl"] = publicKeyUrl_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- link_google
-- Add Google to the social profiles on the current user&#x27;s account.
-- @param client
-- @param token_string (string) The OAuth token received from Google to access their profile API. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.link_google(client, token_string, vars_table, callback, retry_policy, cancellation_token)
	log("link_google()")
	assert(client, "You must provide a client")
	assert(not token_string or check_string(token_string), "Argument 'token_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/account/link/google"

	local query_params = {}

	local post_data = json.encode({
		["token"] = token_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- link_steam
-- Add Steam to the social profiles on the current user&#x27;s account.
-- @param client
-- @param account_table (table) The Facebook account details. (REQUIRED)
-- @param sync_boolean (boolean) Import Steam friends for the user. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.link_steam(client, account_table, sync_boolean, callback, retry_policy, cancellation_token)
	log("link_steam()")
	assert(client, "You must provide a client")
	assert(not account_table or check_(account_table), "Argument 'account_table' must be 'nil' or of type ''")
	assert(not sync_boolean or check_boolean(sync_boolean), "Argument 'sync_boolean' must be 'nil' or of type 'boolean'")


	local url_path = "/v2/account/link/steam"

	local query_params = {}

	local post_data = json.encode({
		["account"] = account_table,
		["sync"] = sync_boolean,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- session_refresh
-- Refresh a user&#x27;s session using a refresh token retrieved from a previous authentication request.
-- @param client
-- @param token_string (string) Refresh token. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.session_refresh(client, token_string, vars_table, callback, retry_policy, cancellation_token)
	log("session_refresh()")
	assert(client, "You must provide a client")
	assert(not token_string or check_string(token_string), "Argument 'token_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/session/refresh"

	local query_params = {}

	local post_data = json.encode({
		["token"] = token_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		if not result.error then
			result = api_session.create(result)
		end
		return result
	end)
end

--- unlink_apple
-- Remove the Apple ID from the social profiles on the current user&#x27;s account.
-- @param client
-- @param token_string (string) The ID token received from Apple to validate. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.unlink_apple(client, token_string, vars_table, callback, retry_policy, cancellation_token)
	log("unlink_apple()")
	assert(client, "You must provide a client")
	assert(not token_string or check_string(token_string), "Argument 'token_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/account/unlink/apple"

	local query_params = {}

	local post_data = json.encode({
		["token"] = token_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- unlink_custom
-- Remove the custom ID from the social profiles on the current user&#x27;s account.
-- @param client
-- @param id_string (string) A custom identifier. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.unlink_custom(client, id_string, vars_table, callback, retry_policy, cancellation_token)
	log("unlink_custom()")
	assert(client, "You must provide a client")
	assert(not id_string or check_string(id_string), "Argument 'id_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/account/unlink/custom"

	local query_params = {}

	local post_data = json.encode({
		["id"] = id_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- unlink_device
-- Remove the device ID from the social profiles on the current user&#x27;s account.
-- @param client
-- @param id_string (string) A device identifier. Should be obtained by a platform-specific device API. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.unlink_device(client, id_string, vars_table, callback, retry_policy, cancellation_token)
	log("unlink_device()")
	assert(client, "You must provide a client")
	assert(not id_string or check_string(id_string), "Argument 'id_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/account/unlink/device"

	local query_params = {}

	local post_data = json.encode({
		["id"] = id_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- unlink_email
-- Remove the email+password from the social profiles on the current user&#x27;s account.
-- @param client
-- @param email_string (string) A valid RFC-5322 email address. (REQUIRED)
-- @param password_string (string) A password for the user account.
-- 
-- Ignored with unlink operations. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.unlink_email(client, email_string, password_string, vars_table, callback, retry_policy, cancellation_token)
	log("unlink_email()")
	assert(client, "You must provide a client")
	assert(not email_string or check_string(email_string), "Argument 'email_string' must be 'nil' or of type 'string'")
	assert(not password_string or check_string(password_string), "Argument 'password_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/account/unlink/email"

	local query_params = {}

	local post_data = json.encode({
		["email"] = email_string,
		["password"] = password_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- unlink_facebook
-- Remove Facebook from the social profiles on the current user&#x27;s account.
-- @param client
-- @param token_string (string) The OAuth token received from Facebook to access their profile API. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.unlink_facebook(client, token_string, vars_table, callback, retry_policy, cancellation_token)
	log("unlink_facebook()")
	assert(client, "You must provide a client")
	assert(not token_string or check_string(token_string), "Argument 'token_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/account/unlink/facebook"

	local query_params = {}

	local post_data = json.encode({
		["token"] = token_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- unlink_facebook_instant_game
-- Remove Facebook Instant Game profile from the social profiles on the current user&#x27;s account.
-- @param client
-- @param signedPlayerInfo_string (string) Send a Facebook Instant Game token to the server. Used with authenticate/link/unlink. The OAuth token received from a Facebook Instant Game that may be decoded with the Application Secret (must be available with the nakama configuration) (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.unlink_facebook_instant_game(client, signedPlayerInfo_string, vars_table, callback, retry_policy, cancellation_token)
	log("unlink_facebook_instant_game()")
	assert(client, "You must provide a client")
	assert(not signedPlayerInfo_string or check_string(signedPlayerInfo_string), "Argument 'signedPlayerInfo_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/account/unlink/facebookinstantgame"

	local query_params = {}

	local post_data = json.encode({
		["signedPlayerInfo"] = signedPlayerInfo_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- unlink_game_center
-- Remove Apple&#x27;s GameCenter from the social profiles on the current user&#x27;s account.
-- @param client
-- @param playerId_string (string) Player ID (generated by GameCenter). (REQUIRED)
-- @param bundleId_string (string) Bundle ID (generated by GameCenter). (REQUIRED)
-- @param timestampSeconds_string (string) Time since UNIX epoch when the signature was created. (REQUIRED)
-- @param salt_string (string) A random &quot;NSString&quot; used to compute the hash and keep it randomized. (REQUIRED)
-- @param signature_string (string) The verification signature data generated. (REQUIRED)
-- @param publicKeyUrl_string (string) The URL for the public encryption key. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.unlink_game_center(client, playerId_string, bundleId_string, timestampSeconds_string, salt_string, signature_string, publicKeyUrl_string, vars_table, callback, retry_policy, cancellation_token)
	log("unlink_game_center()")
	assert(client, "You must provide a client")
	assert(not playerId_string or check_string(playerId_string), "Argument 'playerId_string' must be 'nil' or of type 'string'")
	assert(not bundleId_string or check_string(bundleId_string), "Argument 'bundleId_string' must be 'nil' or of type 'string'")
	assert(not timestampSeconds_string or check_string(timestampSeconds_string), "Argument 'timestampSeconds_string' must be 'nil' or of type 'string'")
	assert(not salt_string or check_string(salt_string), "Argument 'salt_string' must be 'nil' or of type 'string'")
	assert(not signature_string or check_string(signature_string), "Argument 'signature_string' must be 'nil' or of type 'string'")
	assert(not publicKeyUrl_string or check_string(publicKeyUrl_string), "Argument 'publicKeyUrl_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/account/unlink/gamecenter"

	local query_params = {}

	local post_data = json.encode({
		["playerId"] = playerId_string,
		["bundleId"] = bundleId_string,
		["timestampSeconds"] = timestampSeconds_string,
		["salt"] = salt_string,
		["signature"] = signature_string,
		["publicKeyUrl"] = publicKeyUrl_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- unlink_google
-- Remove Google from the social profiles on the current user&#x27;s account.
-- @param client
-- @param token_string (string) The OAuth token received from Google to access their profile API. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.unlink_google(client, token_string, vars_table, callback, retry_policy, cancellation_token)
	log("unlink_google()")
	assert(client, "You must provide a client")
	assert(not token_string or check_string(token_string), "Argument 'token_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/account/unlink/google"

	local query_params = {}

	local post_data = json.encode({
		["token"] = token_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- unlink_steam
-- Remove Steam from the social profiles on the current user&#x27;s account.
-- @param client
-- @param token_string (string) The account token received from Steam to access their profile API. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.unlink_steam(client, token_string, vars_table, callback, retry_policy, cancellation_token)
	log("unlink_steam()")
	assert(client, "You must provide a client")
	assert(not token_string or check_string(token_string), "Argument 'token_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/account/unlink/steam"

	local query_params = {}

	local post_data = json.encode({
		["token"] = token_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- list_channel_messages
-- List a channel&#x27;s message history.
-- @param client
-- @param channelId_string (string) The channel ID to list from. (REQUIRED)
-- @param limit_table (table) Max number of records to return. Between 1 and 100.
-- @param forward_boolean (boolean) True if listing should be older messages to newer, false if reverse.
-- @param cursor_string (string) A pagination cursor, if any.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.list_channel_messages(client, channelId_string, limit_table, forward_boolean, cursor_string, callback, retry_policy, cancellation_token)
	log("list_channel_messages()")
	assert(client, "You must provide a client")
	assert(not channelId_string or check_string(channelId_string), "Argument 'channelId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/channel/{channelId}"
	url_path = url_path:gsub("{" .. "channelId" .. "}", uri_encode(channelId_string))

	local query_params = {}
	query_params["limit"] = limit_table
	query_params["forward"] = forward_boolean
	query_params["cursor"] = cursor_string

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- event
-- Submit an event for processing in the server&#x27;s registered runtime custom events handler.
-- @param client
-- @param name_string (string) An event name, type, category, or identifier. (REQUIRED)
-- @param properties_table (table) Arbitrary event property values. (REQUIRED)
-- @param timestamp_string (string) The time when the event was triggered. (REQUIRED)
-- @param external_boolean (boolean) True if the event came directly from a client call, false otherwise. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.event(client, name_string, properties_table, timestamp_string, external_boolean, callback, retry_policy, cancellation_token)
	log("event()")
	assert(client, "You must provide a client")
	assert(not name_string or check_string(name_string), "Argument 'name_string' must be 'nil' or of type 'string'")
	assert(not properties_table or check_object(properties_table), "Argument 'properties_table' must be 'nil' or of type 'object'")
	assert(not timestamp_string or check_string(timestamp_string), "Argument 'timestamp_string' must be 'nil' or of type 'string'")
	assert(not external_boolean or check_boolean(external_boolean), "Argument 'external_boolean' must be 'nil' or of type 'boolean'")


	local url_path = "/v2/event"

	local query_params = {}

	local post_data = json.encode({
		["name"] = name_string,
		["properties"] = properties_table,
		["timestamp"] = timestamp_string,
		["external"] = external_boolean,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- list_friends
-- List all friends for the current user.
-- @param client
-- @param limit_table (table) Max number of records to return. Between 1 and 100.
-- @param state_table (table) The friend state to list.
-- @param cursor_string (string) An optional next page cursor.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.list_friends(client, limit_table, state_table, cursor_string, callback, retry_policy, cancellation_token)
	log("list_friends()")
	assert(client, "You must provide a client")


	local url_path = "/v2/friend"

	local query_params = {}
	query_params["limit"] = limit_table
	query_params["state"] = state_table
	query_params["cursor"] = cursor_string

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- delete_friends
-- Delete one or more users by ID or username.
-- @param client
-- @param ids_table (table) The account id of a user.
-- @param usernames_table (table) The account username of a user.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.delete_friends(client, ids_table, usernames_table, callback, retry_policy, cancellation_token)
	log("delete_friends()")
	assert(client, "You must provide a client")


	local url_path = "/v2/friend"

	local query_params = {}
	query_params["ids"] = ids_table
	query_params["usernames"] = usernames_table

	local post_data = nil

	return http(client, callback, url_path, query_params, "DELETE", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- add_friends
-- Add friends by ID or username to a user&#x27;s account.
-- @param client
-- @param ids_table (table) The account id of a user.
-- @param usernames_table (table) The account username of a user.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.add_friends(client, ids_table, usernames_table, callback, retry_policy, cancellation_token)
	log("add_friends()")
	assert(client, "You must provide a client")


	local url_path = "/v2/friend"

	local query_params = {}
	query_params["ids"] = ids_table
	query_params["usernames"] = usernames_table

	local post_data = nil

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- block_friends
-- Block one or more users by ID or username.
-- @param client
-- @param ids_table (table) The account id of a user.
-- @param usernames_table (table) The account username of a user.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.block_friends(client, ids_table, usernames_table, callback, retry_policy, cancellation_token)
	log("block_friends()")
	assert(client, "You must provide a client")


	local url_path = "/v2/friend/block"

	local query_params = {}
	query_params["ids"] = ids_table
	query_params["usernames"] = usernames_table

	local post_data = nil

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- import_facebook_friends
-- Import Facebook friends and add them to a user&#x27;s account.
-- @param client
-- @param token_string (string) The OAuth token received from Facebook to access their profile API. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param reset_boolean (boolean) Reset the current user&#x27;s friends list.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.import_facebook_friends(client, token_string, vars_table, reset_boolean, callback, retry_policy, cancellation_token)
	log("import_facebook_friends()")
	assert(client, "You must provide a client")
	assert(not token_string or check_string(token_string), "Argument 'token_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/friend/facebook"

	local query_params = {}
	query_params["reset"] = reset_boolean

	local post_data = json.encode({
		["token"] = token_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- import_steam_friends
-- Import Steam friends and add them to a user&#x27;s account.
-- @param client
-- @param token_string (string) The account token received from Steam to access their profile API. (REQUIRED)
-- @param vars_table (table) Extra information that will be bundled in the session token. (REQUIRED)
-- @param reset_boolean (boolean) Reset the current user&#x27;s friends list.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.import_steam_friends(client, token_string, vars_table, reset_boolean, callback, retry_policy, cancellation_token)
	log("import_steam_friends()")
	assert(client, "You must provide a client")
	assert(not token_string or check_string(token_string), "Argument 'token_string' must be 'nil' or of type 'string'")
	assert(not vars_table or check_object(vars_table), "Argument 'vars_table' must be 'nil' or of type 'object'")


	local url_path = "/v2/friend/steam"

	local query_params = {}
	query_params["reset"] = reset_boolean

	local post_data = json.encode({
		["token"] = token_string,
		["vars"] = vars_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- list_groups
-- List groups based on given filters.
-- @param client
-- @param name_string (string) List groups that contain this value in their names.
-- @param cursor_string (string) Optional pagination cursor.
-- @param limit_table (table) Max number of groups to return. Between 1 and 100.
-- @param langTag_string (string) Language tag filter
-- @param members_table (table) Number of group members
-- @param open_boolean (boolean) Optional Open/Closed filter.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.list_groups(client, name_string, cursor_string, limit_table, langTag_string, members_table, open_boolean, callback, retry_policy, cancellation_token)
	log("list_groups()")
	assert(client, "You must provide a client")


	local url_path = "/v2/group"

	local query_params = {}
	query_params["name"] = name_string
	query_params["cursor"] = cursor_string
	query_params["limit"] = limit_table
	query_params["langTag"] = langTag_string
	query_params["members"] = members_table
	query_params["open"] = open_boolean

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- create_group
-- Create a new group with the current user as the owner.
-- @param client
-- @param name_string (string) A unique name for the group. (REQUIRED)
-- @param description_string (string) A description for the group. (REQUIRED)
-- @param langTag_string (string) The language expected to be a tag which follows the BCP-47 spec. (REQUIRED)
-- @param avatarUrl_string (string) A URL for an avatar image. (REQUIRED)
-- @param open_boolean (boolean) Mark a group as open or not where only admins can accept members. (REQUIRED)
-- @param maxCount_table (table) Maximum number of group members. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.create_group(client, name_string, description_string, langTag_string, avatarUrl_string, open_boolean, maxCount_table, callback, retry_policy, cancellation_token)
	log("create_group()")
	assert(client, "You must provide a client")
	assert(not name_string or check_string(name_string), "Argument 'name_string' must be 'nil' or of type 'string'")
	assert(not description_string or check_string(description_string), "Argument 'description_string' must be 'nil' or of type 'string'")
	assert(not langTag_string or check_string(langTag_string), "Argument 'langTag_string' must be 'nil' or of type 'string'")
	assert(not avatarUrl_string or check_string(avatarUrl_string), "Argument 'avatarUrl_string' must be 'nil' or of type 'string'")
	assert(not open_boolean or check_boolean(open_boolean), "Argument 'open_boolean' must be 'nil' or of type 'boolean'")
	assert(not maxCount_table or check_integer(maxCount_table), "Argument 'maxCount_table' must be 'nil' or of type 'integer'")


	local url_path = "/v2/group"

	local query_params = {}

	local post_data = json.encode({
		["name"] = name_string,
		["description"] = description_string,
		["langTag"] = langTag_string,
		["avatarUrl"] = avatarUrl_string,
		["open"] = open_boolean,
		["maxCount"] = maxCount_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- delete_group
-- Delete a group by ID.
-- @param client
-- @param groupId_string (string) The id of a group. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.delete_group(client, groupId_string, callback, retry_policy, cancellation_token)
	log("delete_group()")
	assert(client, "You must provide a client")
	assert(not groupId_string or check_string(groupId_string), "Argument 'groupId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/group/{groupId}"
	url_path = url_path:gsub("{" .. "groupId" .. "}", uri_encode(groupId_string))

	local query_params = {}

	local post_data = nil

	return http(client, callback, url_path, query_params, "DELETE", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- update_group
-- Update fields in a given group.
-- @param client
-- @param groupId_string (string) The ID of the group to update. (REQUIRED)
-- @param name_string (string) Name. (REQUIRED)
-- @param description_string (string) Description string. (REQUIRED)
-- @param langTag_string (string) Lang tag. (REQUIRED)
-- @param avatarUrl_string (string) Avatar URL. (REQUIRED)
-- @param open_boolean (boolean) Open is true if anyone should be allowed to join, or false if joins must be approved by a group admin. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.update_group(client, groupId_string, name_string, description_string, langTag_string, avatarUrl_string, open_boolean, callback, retry_policy, cancellation_token)
	log("update_group()")
	assert(client, "You must provide a client")
	assert(not groupId_string or check_string(groupId_string), "Argument 'groupId_string' must be 'nil' or of type 'string'")
	assert(not name_string or check_string(name_string), "Argument 'name_string' must be 'nil' or of type 'string'")
	assert(not description_string or check_string(description_string), "Argument 'description_string' must be 'nil' or of type 'string'")
	assert(not langTag_string or check_string(langTag_string), "Argument 'langTag_string' must be 'nil' or of type 'string'")
	assert(not avatarUrl_string or check_string(avatarUrl_string), "Argument 'avatarUrl_string' must be 'nil' or of type 'string'")
	assert(not open_boolean or check_boolean(open_boolean), "Argument 'open_boolean' must be 'nil' or of type 'boolean'")


	local url_path = "/v2/group/{groupId}"
	url_path = url_path:gsub("{" .. "groupId" .. "}", uri_encode(groupId_string))

	local query_params = {}

	local post_data = json.encode({
		["name"] = name_string,
		["description"] = description_string,
		["langTag"] = langTag_string,
		["avatarUrl"] = avatarUrl_string,
		["open"] = open_boolean,
	})

	return http(client, callback, url_path, query_params, "PUT", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- add_group_users
-- Add users to a group.
-- @param client
-- @param groupId_string (string) The group to add users to. (REQUIRED)
-- @param userIds_table (table) The users to add.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.add_group_users(client, groupId_string, userIds_table, callback, retry_policy, cancellation_token)
	log("add_group_users()")
	assert(client, "You must provide a client")
	assert(not groupId_string or check_string(groupId_string), "Argument 'groupId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/group/{groupId}/add"
	url_path = url_path:gsub("{" .. "groupId" .. "}", uri_encode(groupId_string))

	local query_params = {}
	query_params["userIds"] = userIds_table

	local post_data = nil

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- ban_group_users
-- Ban a set of users from a group.
-- @param client
-- @param groupId_string (string) The group to ban users from. (REQUIRED)
-- @param userIds_table (table) The users to ban.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.ban_group_users(client, groupId_string, userIds_table, callback, retry_policy, cancellation_token)
	log("ban_group_users()")
	assert(client, "You must provide a client")
	assert(not groupId_string or check_string(groupId_string), "Argument 'groupId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/group/{groupId}/ban"
	url_path = url_path:gsub("{" .. "groupId" .. "}", uri_encode(groupId_string))

	local query_params = {}
	query_params["userIds"] = userIds_table

	local post_data = nil

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- demote_group_users
-- Demote a set of users in a group to the next role down.
-- @param client
-- @param groupId_string (string) The group ID to demote in. (REQUIRED)
-- @param userIds_table (table) The users to demote.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.demote_group_users(client, groupId_string, userIds_table, callback, retry_policy, cancellation_token)
	log("demote_group_users()")
	assert(client, "You must provide a client")
	assert(not groupId_string or check_string(groupId_string), "Argument 'groupId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/group/{groupId}/demote"
	url_path = url_path:gsub("{" .. "groupId" .. "}", uri_encode(groupId_string))

	local query_params = {}
	query_params["userIds"] = userIds_table

	local post_data = nil

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- join_group
-- Immediately join an open group, or request to join a closed one.
-- @param client
-- @param groupId_string (string) The group ID to join. The group must already exist. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.join_group(client, groupId_string, callback, retry_policy, cancellation_token)
	log("join_group()")
	assert(client, "You must provide a client")
	assert(not groupId_string or check_string(groupId_string), "Argument 'groupId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/group/{groupId}/join"
	url_path = url_path:gsub("{" .. "groupId" .. "}", uri_encode(groupId_string))

	local query_params = {}

	local post_data = nil

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- kick_group_users
-- Kick a set of users from a group.
-- @param client
-- @param groupId_string (string) The group ID to kick from. (REQUIRED)
-- @param userIds_table (table) The users to kick.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.kick_group_users(client, groupId_string, userIds_table, callback, retry_policy, cancellation_token)
	log("kick_group_users()")
	assert(client, "You must provide a client")
	assert(not groupId_string or check_string(groupId_string), "Argument 'groupId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/group/{groupId}/kick"
	url_path = url_path:gsub("{" .. "groupId" .. "}", uri_encode(groupId_string))

	local query_params = {}
	query_params["userIds"] = userIds_table

	local post_data = nil

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- leave_group
-- Leave a group the user is a member of.
-- @param client
-- @param groupId_string (string) The group ID to leave. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.leave_group(client, groupId_string, callback, retry_policy, cancellation_token)
	log("leave_group()")
	assert(client, "You must provide a client")
	assert(not groupId_string or check_string(groupId_string), "Argument 'groupId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/group/{groupId}/leave"
	url_path = url_path:gsub("{" .. "groupId" .. "}", uri_encode(groupId_string))

	local query_params = {}

	local post_data = nil

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- promote_group_users
-- Promote a set of users in a group to the next role up.
-- @param client
-- @param groupId_string (string) The group ID to promote in. (REQUIRED)
-- @param userIds_table (table) The users to promote.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.promote_group_users(client, groupId_string, userIds_table, callback, retry_policy, cancellation_token)
	log("promote_group_users()")
	assert(client, "You must provide a client")
	assert(not groupId_string or check_string(groupId_string), "Argument 'groupId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/group/{groupId}/promote"
	url_path = url_path:gsub("{" .. "groupId" .. "}", uri_encode(groupId_string))

	local query_params = {}
	query_params["userIds"] = userIds_table

	local post_data = nil

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- list_group_users
-- List all users that are part of a group.
-- @param client
-- @param groupId_string (string) The group ID to list from. (REQUIRED)
-- @param limit_table (table) Max number of records to return. Between 1 and 100.
-- @param state_table (table) The group user state to list.
-- @param cursor_string (string) An optional next page cursor.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.list_group_users(client, groupId_string, limit_table, state_table, cursor_string, callback, retry_policy, cancellation_token)
	log("list_group_users()")
	assert(client, "You must provide a client")
	assert(not groupId_string or check_string(groupId_string), "Argument 'groupId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/group/{groupId}/user"
	url_path = url_path:gsub("{" .. "groupId" .. "}", uri_encode(groupId_string))

	local query_params = {}
	query_params["limit"] = limit_table
	query_params["state"] = state_table
	query_params["cursor"] = cursor_string

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- validate_purchase_apple
-- Validate Apple IAP Receipt
-- @param client
-- @param receipt_string (string) Base64 encoded Apple receipt data payload. (REQUIRED)
-- @param persist_boolean (boolean)  Persist the purchase (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.validate_purchase_apple(client, receipt_string, persist_boolean, callback, retry_policy, cancellation_token)
	log("validate_purchase_apple()")
	assert(client, "You must provide a client")
	assert(not receipt_string or check_string(receipt_string), "Argument 'receipt_string' must be 'nil' or of type 'string'")
	assert(not persist_boolean or check_boolean(persist_boolean), "Argument 'persist_boolean' must be 'nil' or of type 'boolean'")


	local url_path = "/v2/iap/purchase/apple"

	local query_params = {}

	local post_data = json.encode({
		["receipt"] = receipt_string,
		["persist"] = persist_boolean,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- validate_purchase_facebook_instant
-- Validate FB Instant IAP Receipt
-- @param client
-- @param signedRequest_string (string) Base64 encoded Facebook Instant signedRequest receipt data payload. (REQUIRED)
-- @param persist_boolean (boolean)  Persist the purchase (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.validate_purchase_facebook_instant(client, signedRequest_string, persist_boolean, callback, retry_policy, cancellation_token)
	log("validate_purchase_facebook_instant()")
	assert(client, "You must provide a client")
	assert(not signedRequest_string or check_string(signedRequest_string), "Argument 'signedRequest_string' must be 'nil' or of type 'string'")
	assert(not persist_boolean or check_boolean(persist_boolean), "Argument 'persist_boolean' must be 'nil' or of type 'boolean'")


	local url_path = "/v2/iap/purchase/facebookinstant"

	local query_params = {}

	local post_data = json.encode({
		["signedRequest"] = signedRequest_string,
		["persist"] = persist_boolean,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- validate_purchase_google
-- Validate Google IAP Receipt
-- @param client
-- @param purchase_string (string) JSON encoded Google purchase payload. (REQUIRED)
-- @param persist_boolean (boolean)  Persist the purchase (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.validate_purchase_google(client, purchase_string, persist_boolean, callback, retry_policy, cancellation_token)
	log("validate_purchase_google()")
	assert(client, "You must provide a client")
	assert(not purchase_string or check_string(purchase_string), "Argument 'purchase_string' must be 'nil' or of type 'string'")
	assert(not persist_boolean or check_boolean(persist_boolean), "Argument 'persist_boolean' must be 'nil' or of type 'boolean'")


	local url_path = "/v2/iap/purchase/google"

	local query_params = {}

	local post_data = json.encode({
		["purchase"] = purchase_string,
		["persist"] = persist_boolean,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- validate_purchase_huawei
-- Validate Huawei IAP Receipt
-- @param client
-- @param purchase_string (string) JSON encoded Huawei InAppPurchaseData. (REQUIRED)
-- @param signature_string (string) InAppPurchaseData signature. (REQUIRED)
-- @param persist_boolean (boolean)  Persist the purchase (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.validate_purchase_huawei(client, purchase_string, signature_string, persist_boolean, callback, retry_policy, cancellation_token)
	log("validate_purchase_huawei()")
	assert(client, "You must provide a client")
	assert(not purchase_string or check_string(purchase_string), "Argument 'purchase_string' must be 'nil' or of type 'string'")
	assert(not signature_string or check_string(signature_string), "Argument 'signature_string' must be 'nil' or of type 'string'")
	assert(not persist_boolean or check_boolean(persist_boolean), "Argument 'persist_boolean' must be 'nil' or of type 'boolean'")


	local url_path = "/v2/iap/purchase/huawei"

	local query_params = {}

	local post_data = json.encode({
		["purchase"] = purchase_string,
		["signature"] = signature_string,
		["persist"] = persist_boolean,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- list_subscriptions
-- List user&#x27;s subscriptions.
-- @param client
-- @param limit_table (table) List user subscriptions. Max number of results per page (REQUIRED)
-- @param cursor_string (string) List user subscriptions. Cursor to retrieve a page of records from (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.list_subscriptions(client, limit_table, cursor_string, callback, retry_policy, cancellation_token)
	log("list_subscriptions()")
	assert(client, "You must provide a client")
	assert(not limit_table or check_integer(limit_table), "Argument 'limit_table' must be 'nil' or of type 'integer'")
	assert(not cursor_string or check_string(cursor_string), "Argument 'cursor_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/iap/subscription"

	local query_params = {}

	local post_data = json.encode({
		["limit"] = limit_table,
		["cursor"] = cursor_string,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- validate_subscription_apple
-- Validate Apple Subscription Receipt
-- @param client
-- @param receipt_string (string) Base64 encoded Apple receipt data payload. (REQUIRED)
-- @param persist_boolean (boolean) Persist the subscription. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.validate_subscription_apple(client, receipt_string, persist_boolean, callback, retry_policy, cancellation_token)
	log("validate_subscription_apple()")
	assert(client, "You must provide a client")
	assert(not receipt_string or check_string(receipt_string), "Argument 'receipt_string' must be 'nil' or of type 'string'")
	assert(not persist_boolean or check_boolean(persist_boolean), "Argument 'persist_boolean' must be 'nil' or of type 'boolean'")


	local url_path = "/v2/iap/subscription/apple"

	local query_params = {}

	local post_data = json.encode({
		["receipt"] = receipt_string,
		["persist"] = persist_boolean,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- validate_subscription_google
-- Validate Google Subscription Receipt
-- @param client
-- @param receipt_string (string) JSON encoded Google purchase payload. (REQUIRED)
-- @param persist_boolean (boolean) Persist the subscription. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.validate_subscription_google(client, receipt_string, persist_boolean, callback, retry_policy, cancellation_token)
	log("validate_subscription_google()")
	assert(client, "You must provide a client")
	assert(not receipt_string or check_string(receipt_string), "Argument 'receipt_string' must be 'nil' or of type 'string'")
	assert(not persist_boolean or check_boolean(persist_boolean), "Argument 'persist_boolean' must be 'nil' or of type 'boolean'")


	local url_path = "/v2/iap/subscription/google"

	local query_params = {}

	local post_data = json.encode({
		["receipt"] = receipt_string,
		["persist"] = persist_boolean,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- get_subscription
-- Get subscription by product id.
-- @param client
-- @param productId_string (string) Product id of the subscription (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.get_subscription(client, productId_string, callback, retry_policy, cancellation_token)
	log("get_subscription()")
	assert(client, "You must provide a client")
	assert(not productId_string or check_string(productId_string), "Argument 'productId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/iap/subscription/{productId}"
	url_path = url_path:gsub("{" .. "productId" .. "}", uri_encode(productId_string))

	local query_params = {}

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- list_leaderboard_records
-- List leaderboard records.
-- @param client
-- @param leaderboardId_string (string) The ID of the leaderboard to list for. (REQUIRED)
-- @param ownerIds_table (table) One or more owners to retrieve records for.
-- @param limit_table (table) Max number of records to return. Between 1 and 100.
-- @param cursor_string (string) A next or previous page cursor.
-- @param expiry_string (string) Expiry in seconds (since epoch) to begin fetching records from. Optional. 0 means from current time.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.list_leaderboard_records(client, leaderboardId_string, ownerIds_table, limit_table, cursor_string, expiry_string, callback, retry_policy, cancellation_token)
	log("list_leaderboard_records()")
	assert(client, "You must provide a client")
	assert(not leaderboardId_string or check_string(leaderboardId_string), "Argument 'leaderboardId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/leaderboard/{leaderboardId}"
	url_path = url_path:gsub("{" .. "leaderboardId" .. "}", uri_encode(leaderboardId_string))

	local query_params = {}
	query_params["ownerIds"] = ownerIds_table
	query_params["limit"] = limit_table
	query_params["cursor"] = cursor_string
	query_params["expiry"] = expiry_string

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- delete_leaderboard_record
-- Delete a leaderboard record.
-- @param client
-- @param leaderboardId_string (string) The leaderboard ID to delete from. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.delete_leaderboard_record(client, leaderboardId_string, callback, retry_policy, cancellation_token)
	log("delete_leaderboard_record()")
	assert(client, "You must provide a client")
	assert(not leaderboardId_string or check_string(leaderboardId_string), "Argument 'leaderboardId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/leaderboard/{leaderboardId}"
	url_path = url_path:gsub("{" .. "leaderboardId" .. "}", uri_encode(leaderboardId_string))

	local query_params = {}

	local post_data = nil

	return http(client, callback, url_path, query_params, "DELETE", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- write_leaderboard_record
-- Write a record to a leaderboard.
-- @param client
-- @param leaderboardId_string (string) The ID of the leaderboard to write to. (REQUIRED)
-- @param score_string (string) The score value to submit. (REQUIRED)
-- @param subscore_string (string) An optional secondary value. (REQUIRED)
-- @param metadata_string (string) Optional record metadata. (REQUIRED)
-- @param operator_table (table) Operator override. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.write_leaderboard_record(client, leaderboardId_string, score_string, subscore_string, metadata_string, operator_table, callback, retry_policy, cancellation_token)
	log("write_leaderboard_record()")
	assert(client, "You must provide a client")
	assert(not leaderboardId_string or check_string(leaderboardId_string), "Argument 'leaderboardId_string' must be 'nil' or of type 'string'")
	assert(not score_string or check_string(score_string), "Argument 'score_string' must be 'nil' or of type 'string'")
	assert(not subscore_string or check_string(subscore_string), "Argument 'subscore_string' must be 'nil' or of type 'string'")
	assert(not metadata_string or check_string(metadata_string), "Argument 'metadata_string' must be 'nil' or of type 'string'")
	assert(not operator_table or check_(operator_table), "Argument 'operator_table' must be 'nil' or of type ''")


	local url_path = "/v2/leaderboard/{leaderboardId}"
	url_path = url_path:gsub("{" .. "leaderboardId" .. "}", uri_encode(leaderboardId_string))

	local query_params = {}

	local post_data = json.encode({
		["score"] = score_string,
		["subscore"] = subscore_string,
		["metadata"] = metadata_string,
		["operator"] = operator_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- list_leaderboard_records_around_owner
-- List leaderboard records that belong to a user.
-- @param client
-- @param leaderboardId_string (string) The ID of the tournament to list for. (REQUIRED)
-- @param ownerId_string (string) The owner to retrieve records around. (REQUIRED)
-- @param limit_table (table) Max number of records to return. Between 1 and 100.
-- @param expiry_string (string) Expiry in seconds (since epoch) to begin fetching records from.
-- @param cursor_string (string) A next or previous page cursor.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.list_leaderboard_records_around_owner(client, leaderboardId_string, ownerId_string, limit_table, expiry_string, cursor_string, callback, retry_policy, cancellation_token)
	log("list_leaderboard_records_around_owner()")
	assert(client, "You must provide a client")
	assert(not leaderboardId_string or check_string(leaderboardId_string), "Argument 'leaderboardId_string' must be 'nil' or of type 'string'")
	assert(not ownerId_string or check_string(ownerId_string), "Argument 'ownerId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/leaderboard/{leaderboardId}/owner/{ownerId}"
	url_path = url_path:gsub("{" .. "leaderboardId" .. "}", uri_encode(leaderboardId_string))
	url_path = url_path:gsub("{" .. "ownerId" .. "}", uri_encode(ownerId_string))

	local query_params = {}
	query_params["limit"] = limit_table
	query_params["expiry"] = expiry_string
	query_params["cursor"] = cursor_string

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- list_matches
-- Fetch list of running matches.
-- @param client
-- @param limit_table (table) Limit the number of returned matches.
-- @param authoritative_boolean (boolean) Authoritative or relayed matches.
-- @param label_string (string) Label filter.
-- @param minSize_table (table) Minimum user count.
-- @param maxSize_table (table) Maximum user count.
-- @param query_string (string) Arbitrary label query.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.list_matches(client, limit_table, authoritative_boolean, label_string, minSize_table, maxSize_table, query_string, callback, retry_policy, cancellation_token)
	log("list_matches()")
	assert(client, "You must provide a client")


	local url_path = "/v2/match"

	local query_params = {}
	query_params["limit"] = limit_table
	query_params["authoritative"] = authoritative_boolean
	query_params["label"] = label_string
	query_params["minSize"] = minSize_table
	query_params["maxSize"] = maxSize_table
	query_params["query"] = query_string

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- list_notifications
-- Fetch list of notifications.
-- @param client
-- @param limit_table (table) The number of notifications to get. Between 1 and 100.
-- @param cacheableCursor_string (string) A cursor to page through notifications. May be cached by clients to get from point in time forwards.
-- 
-- value from NotificationList.cacheable_cursor.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.list_notifications(client, limit_table, cacheableCursor_string, callback, retry_policy, cancellation_token)
	log("list_notifications()")
	assert(client, "You must provide a client")


	local url_path = "/v2/notification"

	local query_params = {}
	query_params["limit"] = limit_table
	query_params["cacheableCursor"] = cacheableCursor_string

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- delete_notifications
-- Delete one or more notifications for the current user.
-- @param client
-- @param ids_table (table) The id of notifications.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.delete_notifications(client, ids_table, callback, retry_policy, cancellation_token)
	log("delete_notifications()")
	assert(client, "You must provide a client")


	local url_path = "/v2/notification"

	local query_params = {}
	query_params["ids"] = ids_table

	local post_data = nil

	return http(client, callback, url_path, query_params, "DELETE", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- rpc_func2
-- Execute a Lua function on the server.
-- @param client
-- @param id_string (string) The identifier of the function. (REQUIRED)
-- @param payload_string (string) The payload of the function which must be a JSON object.
-- @param httpKey_string (string) The authentication key used when executed as a non-client HTTP request.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.rpc_func2(client, id_string, payload_string, httpKey_string, callback, retry_policy, cancellation_token)
	log("rpc_func2()")
	assert(client, "You must provide a client")
	assert(not id_string or check_string(id_string), "Argument 'id_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/rpc/{id}"
	url_path = url_path:gsub("{" .. "id" .. "}", uri_encode(id_string))

	local query_params = {}
	query_params["payload"] = payload_string
	query_params["httpKey"] = httpKey_string

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- rpc_func
-- Execute a Lua function on the server.
-- @param client
-- @param id_string (string) The identifier of the function. (REQUIRED)
-- @param payload_string (string) The payload of the function which must be a JSON object. (REQUIRED)
-- @param httpKey_string (string) The authentication key used when executed as a non-client HTTP request.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.rpc_func(client, id_string, payload_string, httpKey_string, callback, retry_policy, cancellation_token)
	log("rpc_func()")
	assert(client, "You must provide a client")
	assert(not id_string or check_string(id_string), "Argument 'id_string' must be 'nil' or of type 'string'")
	assert(not payload_string or check_string(payload_string), "Argument 'payload_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/rpc/{id}"
	url_path = url_path:gsub("{" .. "id" .. "}", uri_encode(id_string))

	local query_params = {}
	query_params["httpKey"] = httpKey_string

	local post_data = json.encode({
		["payload"] = payload_string,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- session_logout
-- Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user.
-- @param client
-- @param token_string (string) Session token to log out. (REQUIRED)
-- @param refreshToken_string (string) Refresh token to invalidate. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.session_logout(client, token_string, refreshToken_string, callback, retry_policy, cancellation_token)
	log("session_logout()")
	assert(client, "You must provide a client")
	assert(not token_string or check_string(token_string), "Argument 'token_string' must be 'nil' or of type 'string'")
	assert(not refreshToken_string or check_string(refreshToken_string), "Argument 'refreshToken_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/session/logout"

	local query_params = {}

	local post_data = json.encode({
		["token"] = token_string,
		["refreshToken"] = refreshToken_string,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- read_storage_objects
-- Get storage objects.
-- @param client
-- @param objectIds_table (table) Batch of storage objects. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.read_storage_objects(client, objectIds_table, callback, retry_policy, cancellation_token)
	log("read_storage_objects()")
	assert(client, "You must provide a client")
	assert(not objectIds_table or check_array(objectIds_table), "Argument 'objectIds_table' must be 'nil' or of type 'array'")


	local url_path = "/v2/storage"

	local query_params = {}

	local post_data = json.encode({
		["objectIds"] = objectIds_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- write_storage_objects
-- Write objects into the storage engine.
-- @param client
-- @param objects_table (table) The objects to store on the server. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.write_storage_objects(client, objects_table, callback, retry_policy, cancellation_token)
	log("write_storage_objects()")
	assert(client, "You must provide a client")
	assert(not objects_table or check_array(objects_table), "Argument 'objects_table' must be 'nil' or of type 'array'")


	local url_path = "/v2/storage"

	local query_params = {}

	local post_data = json.encode({
		["objects"] = objects_table,
	})

	return http(client, callback, url_path, query_params, "PUT", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- delete_storage_objects
-- Delete one or more objects by ID or username.
-- @param client
-- @param objectIds_table (table) Batch of storage objects. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.delete_storage_objects(client, objectIds_table, callback, retry_policy, cancellation_token)
	log("delete_storage_objects()")
	assert(client, "You must provide a client")
	assert(not objectIds_table or check_array(objectIds_table), "Argument 'objectIds_table' must be 'nil' or of type 'array'")


	local url_path = "/v2/storage/delete"

	local query_params = {}

	local post_data = json.encode({
		["objectIds"] = objectIds_table,
	})

	return http(client, callback, url_path, query_params, "PUT", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- list_storage_objects
-- List publicly readable storage objects in a given collection.
-- @param client
-- @param collection_string (string) The collection which stores the object. (REQUIRED)
-- @param userId_string (string) ID of the user.
-- @param limit_table (table) The number of storage objects to list. Between 1 and 100.
-- @param cursor_string (string) The cursor to page through results from.
-- 
-- value from StorageObjectList.cursor.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.list_storage_objects(client, collection_string, userId_string, limit_table, cursor_string, callback, retry_policy, cancellation_token)
	log("list_storage_objects()")
	assert(client, "You must provide a client")
	assert(not collection_string or check_string(collection_string), "Argument 'collection_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/storage/{collection}"
	url_path = url_path:gsub("{" .. "collection" .. "}", uri_encode(collection_string))

	local query_params = {}
	query_params["userId"] = userId_string
	query_params["limit"] = limit_table
	query_params["cursor"] = cursor_string

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- list_storage_objects2
-- List publicly readable storage objects in a given collection.
-- @param client
-- @param collection_string (string) The collection which stores the object. (REQUIRED)
-- @param userId_string (string) ID of the user. (REQUIRED)
-- @param limit_table (table) The number of storage objects to list. Between 1 and 100.
-- @param cursor_string (string) The cursor to page through results from.
-- 
-- value from StorageObjectList.cursor.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.list_storage_objects2(client, collection_string, userId_string, limit_table, cursor_string, callback, retry_policy, cancellation_token)
	log("list_storage_objects2()")
	assert(client, "You must provide a client")
	assert(not collection_string or check_string(collection_string), "Argument 'collection_string' must be 'nil' or of type 'string'")
	assert(not userId_string or check_string(userId_string), "Argument 'userId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/storage/{collection}/{userId}"
	url_path = url_path:gsub("{" .. "collection" .. "}", uri_encode(collection_string))
	url_path = url_path:gsub("{" .. "userId" .. "}", uri_encode(userId_string))

	local query_params = {}
	query_params["limit"] = limit_table
	query_params["cursor"] = cursor_string

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- list_tournaments
-- List current or upcoming tournaments.
-- @param client
-- @param categoryStart_table (table) The start of the categories to include. Defaults to 0.
-- @param categoryEnd_table (table) The end of the categories to include. Defaults to 128.
-- @param startTime_table (table) The start time for tournaments. Defaults to epoch.
-- @param endTime_table (table) The end time for tournaments. Defaults to +1 year from current Unix time.
-- @param limit_table (table) Max number of records to return. Between 1 and 100.
-- @param cursor_string (string) A next page cursor for listings (optional).
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.list_tournaments(client, categoryStart_table, categoryEnd_table, startTime_table, endTime_table, limit_table, cursor_string, callback, retry_policy, cancellation_token)
	log("list_tournaments()")
	assert(client, "You must provide a client")


	local url_path = "/v2/tournament"

	local query_params = {}
	query_params["categoryStart"] = categoryStart_table
	query_params["categoryEnd"] = categoryEnd_table
	query_params["startTime"] = startTime_table
	query_params["endTime"] = endTime_table
	query_params["limit"] = limit_table
	query_params["cursor"] = cursor_string

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- list_tournament_records
-- List tournament records.
-- @param client
-- @param tournamentId_string (string) The ID of the tournament to list for. (REQUIRED)
-- @param ownerIds_table (table) One or more owners to retrieve records for.
-- @param limit_table (table) Max number of records to return. Between 1 and 100.
-- @param cursor_string (string) A next or previous page cursor.
-- @param expiry_string (string) Expiry in seconds (since epoch) to begin fetching records from.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.list_tournament_records(client, tournamentId_string, ownerIds_table, limit_table, cursor_string, expiry_string, callback, retry_policy, cancellation_token)
	log("list_tournament_records()")
	assert(client, "You must provide a client")
	assert(not tournamentId_string or check_string(tournamentId_string), "Argument 'tournamentId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/tournament/{tournamentId}"
	url_path = url_path:gsub("{" .. "tournamentId" .. "}", uri_encode(tournamentId_string))

	local query_params = {}
	query_params["ownerIds"] = ownerIds_table
	query_params["limit"] = limit_table
	query_params["cursor"] = cursor_string
	query_params["expiry"] = expiry_string

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- delete_tournament_record
-- Delete a tournament record.
-- @param client
-- @param tournamentId_string (string) The tournament ID to delete from. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.delete_tournament_record(client, tournamentId_string, callback, retry_policy, cancellation_token)
	log("delete_tournament_record()")
	assert(client, "You must provide a client")
	assert(not tournamentId_string or check_string(tournamentId_string), "Argument 'tournamentId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/tournament/{tournamentId}"
	url_path = url_path:gsub("{" .. "tournamentId" .. "}", uri_encode(tournamentId_string))

	local query_params = {}

	local post_data = nil

	return http(client, callback, url_path, query_params, "DELETE", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- write_tournament_record2
-- Write a record to a tournament.
-- @param client
-- @param tournamentId_string (string) The tournament ID to write the record for. (REQUIRED)
-- @param score_string (string) The score value to submit. (REQUIRED)
-- @param subscore_string (string) An optional secondary value. (REQUIRED)
-- @param metadata_string (string) A JSON object of additional properties (optional). (REQUIRED)
-- @param operator_table (table) Operator override. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.write_tournament_record2(client, tournamentId_string, score_string, subscore_string, metadata_string, operator_table, callback, retry_policy, cancellation_token)
	log("write_tournament_record2()")
	assert(client, "You must provide a client")
	assert(not tournamentId_string or check_string(tournamentId_string), "Argument 'tournamentId_string' must be 'nil' or of type 'string'")
	assert(not score_string or check_string(score_string), "Argument 'score_string' must be 'nil' or of type 'string'")
	assert(not subscore_string or check_string(subscore_string), "Argument 'subscore_string' must be 'nil' or of type 'string'")
	assert(not metadata_string or check_string(metadata_string), "Argument 'metadata_string' must be 'nil' or of type 'string'")
	assert(not operator_table or check_(operator_table), "Argument 'operator_table' must be 'nil' or of type ''")


	local url_path = "/v2/tournament/{tournamentId}"
	url_path = url_path:gsub("{" .. "tournamentId" .. "}", uri_encode(tournamentId_string))

	local query_params = {}

	local post_data = json.encode({
		["score"] = score_string,
		["subscore"] = subscore_string,
		["metadata"] = metadata_string,
		["operator"] = operator_table,
	})

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- write_tournament_record
-- Write a record to a tournament.
-- @param client
-- @param tournamentId_string (string) The tournament ID to write the record for. (REQUIRED)
-- @param score_string (string) The score value to submit. (REQUIRED)
-- @param subscore_string (string) An optional secondary value. (REQUIRED)
-- @param metadata_string (string) A JSON object of additional properties (optional). (REQUIRED)
-- @param operator_table (table) Operator override. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.write_tournament_record(client, tournamentId_string, score_string, subscore_string, metadata_string, operator_table, callback, retry_policy, cancellation_token)
	log("write_tournament_record()")
	assert(client, "You must provide a client")
	assert(not tournamentId_string or check_string(tournamentId_string), "Argument 'tournamentId_string' must be 'nil' or of type 'string'")
	assert(not score_string or check_string(score_string), "Argument 'score_string' must be 'nil' or of type 'string'")
	assert(not subscore_string or check_string(subscore_string), "Argument 'subscore_string' must be 'nil' or of type 'string'")
	assert(not metadata_string or check_string(metadata_string), "Argument 'metadata_string' must be 'nil' or of type 'string'")
	assert(not operator_table or check_(operator_table), "Argument 'operator_table' must be 'nil' or of type ''")


	local url_path = "/v2/tournament/{tournamentId}"
	url_path = url_path:gsub("{" .. "tournamentId" .. "}", uri_encode(tournamentId_string))

	local query_params = {}

	local post_data = json.encode({
		["score"] = score_string,
		["subscore"] = subscore_string,
		["metadata"] = metadata_string,
		["operator"] = operator_table,
	})

	return http(client, callback, url_path, query_params, "PUT", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- join_tournament
-- Attempt to join an open and running tournament.
-- @param client
-- @param tournamentId_string (string) The ID of the tournament to join. The tournament must already exist. (REQUIRED)
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.join_tournament(client, tournamentId_string, callback, retry_policy, cancellation_token)
	log("join_tournament()")
	assert(client, "You must provide a client")
	assert(not tournamentId_string or check_string(tournamentId_string), "Argument 'tournamentId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/tournament/{tournamentId}/join"
	url_path = url_path:gsub("{" .. "tournamentId" .. "}", uri_encode(tournamentId_string))

	local query_params = {}

	local post_data = nil

	return http(client, callback, url_path, query_params, "POST", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- list_tournament_records_around_owner
-- List tournament records for a given owner.
-- @param client
-- @param tournamentId_string (string) The ID of the tournament to list for. (REQUIRED)
-- @param ownerId_string (string) The owner to retrieve records around. (REQUIRED)
-- @param limit_table (table) Max number of records to return. Between 1 and 100.
-- @param expiry_string (string) Expiry in seconds (since epoch) to begin fetching records from.
-- @param cursor_string (string) A next or previous page cursor.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.list_tournament_records_around_owner(client, tournamentId_string, ownerId_string, limit_table, expiry_string, cursor_string, callback, retry_policy, cancellation_token)
	log("list_tournament_records_around_owner()")
	assert(client, "You must provide a client")
	assert(not tournamentId_string or check_string(tournamentId_string), "Argument 'tournamentId_string' must be 'nil' or of type 'string'")
	assert(not ownerId_string or check_string(ownerId_string), "Argument 'ownerId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/tournament/{tournamentId}/owner/{ownerId}"
	url_path = url_path:gsub("{" .. "tournamentId" .. "}", uri_encode(tournamentId_string))
	url_path = url_path:gsub("{" .. "ownerId" .. "}", uri_encode(ownerId_string))

	local query_params = {}
	query_params["limit"] = limit_table
	query_params["expiry"] = expiry_string
	query_params["cursor"] = cursor_string

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- get_users
-- Fetch zero or more users by ID and/or username.
-- @param client
-- @param ids_table (table) The account id of a user.
-- @param usernames_table (table) The account username of a user.
-- @param facebookIds_table (table) The Facebook ID of a user.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.get_users(client, ids_table, usernames_table, facebookIds_table, callback, retry_policy, cancellation_token)
	log("get_users()")
	assert(client, "You must provide a client")


	local url_path = "/v2/user"

	local query_params = {}
	query_params["ids"] = ids_table
	query_params["usernames"] = usernames_table
	query_params["facebookIds"] = facebookIds_table

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end

--- list_user_groups
-- List groups the current user belongs to.
-- @param client
-- @param userId_string (string) ID of the user. (REQUIRED)
-- @param limit_table (table) Max number of records to return. Between 1 and 100.
-- @param state_table (table) The user group state to list.
-- @param cursor_string (string) An optional next page cursor.
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.list_user_groups(client, userId_string, limit_table, state_table, cursor_string, callback, retry_policy, cancellation_token)
	log("list_user_groups()")
	assert(client, "You must provide a client")
	assert(not userId_string or check_string(userId_string), "Argument 'userId_string' must be 'nil' or of type 'string'")


	local url_path = "/v2/user/{userId}/group"
	url_path = url_path:gsub("{" .. "userId" .. "}", uri_encode(userId_string))

	local query_params = {}
	query_params["limit"] = limit_table
	query_params["state"] = state_table
	query_params["cursor"] = cursor_string

	local post_data = nil

	return http(client, callback, url_path, query_params, "GET", post_data, retry_policy, cancellation_token, function(result)
		return result
	end)
end



return M
