-- Code generated by codegen/main.go. DO NOT EDIT.

local json = require "nakama.util.json"
local log = require "nakama.util.log"
local async = require "nakama.util.async"
local api_session = require "nakama.session"

local uri = require "nakama.util.uri"
local uri_encode = uri.encode

local M = {}

--------------------------------------------------------------------------------
--- create_group_user_list_group_user
-- A single user-role pair.
function M.create_group_user_list_group_user(
	state_int -- 'number' () Their relationship to the group.
	,user_api_user -- 'table' (api_user) User.
	)
	assert(not state_int or type(state_int) == "number", "Argument 'state_int' must be 'nil' or of type 'number'")
	assert(not user_api_user or type(user_api_user) == "table", "Argument 'user_api_user' must be 'nil' or of type 'table'")
	return {
		state = state_int or 0,
		user = user_api_user or M.create_api_user(),
	}
end

--------------------------------------------------------------------------------
--- create_user_group_list_user_group
-- A single group-role pair.
function M.create_user_group_list_user_group(
	group_api_group -- 'table' (api_group) Group.
	,state_int -- 'number' () The user's relationship to the group.
	)
	assert(not group_api_group or type(group_api_group) == "table", "Argument 'group_api_group' must be 'nil' or of type 'table'")
	assert(not state_int or type(state_int) == "number", "Argument 'state_int' must be 'nil' or of type 'number'")
	return {
		group = group_api_group or M.create_api_group(),
		state = state_int or 0,
	}
end

--------------------------------------------------------------------------------
--- create_write_leaderboard_record_request_leaderboard_record_write
-- Record values to write.
function M.create_write_leaderboard_record_request_leaderboard_record_write(
	metadata_str -- 'string' () Optional record metadata.
	,score_str -- 'string' () The score value to submit.
	,subscore_str -- 'string' () An optional secondary value.
	)
	assert(not metadata_str or type(metadata_str) == "string", "Argument 'metadata_str' must be 'nil' or of type 'string'")
	assert(not score_str or type(score_str) == "string", "Argument 'score_str' must be 'nil' or of type 'string'")
	assert(not subscore_str or type(subscore_str) == "string", "Argument 'subscore_str' must be 'nil' or of type 'string'")
	return {
		metadata = metadata_str or "",
		score = score_str or "",
		subscore = subscore_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_write_tournament_record_request_tournament_record_write
-- Record values to write.
function M.create_write_tournament_record_request_tournament_record_write(
	metadata_str -- 'string' () A JSON object of additional properties (optional).
	,score_str -- 'string' () The score value to submit.
	,subscore_str -- 'string' () An optional secondary value.
	)
	assert(not metadata_str or type(metadata_str) == "string", "Argument 'metadata_str' must be 'nil' or of type 'string'")
	assert(not score_str or type(score_str) == "string", "Argument 'score_str' must be 'nil' or of type 'string'")
	assert(not subscore_str or type(subscore_str) == "string", "Argument 'subscore_str' must be 'nil' or of type 'string'")
	return {
		metadata = metadata_str or "",
		score = score_str or "",
		subscore = subscore_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_api_account
-- A user with additional account details. Always the current user.
function M.create_api_account(
	custom_id_str -- 'string' () The custom id in the user's account.
	,devices_arr -- 'table' () The devices which belong to the user's account.
	,disable_time_str -- 'string' () The UNIX time when the user's account was disabled/banned.
	,email_str -- 'string' () The email address of the user.
	,user_api_user -- 'table' (api_user) The user object.
	,verify_time_str -- 'string' () The UNIX time when the user's email was verified.
	,wallet_str -- 'string' () The user's wallet data.
	)
	assert(not custom_id_str or type(custom_id_str) == "string", "Argument 'custom_id_str' must be 'nil' or of type 'string'")
	assert(not devices_arr or type(devices_arr) == "table", "Argument 'devices_arr' must be 'nil' or of type 'table'")
	assert(not disable_time_str or type(disable_time_str) == "string", "Argument 'disable_time_str' must be 'nil' or of type 'string'")
	assert(not email_str or type(email_str) == "string", "Argument 'email_str' must be 'nil' or of type 'string'")
	assert(not user_api_user or type(user_api_user) == "table", "Argument 'user_api_user' must be 'nil' or of type 'table'")
	assert(not verify_time_str or type(verify_time_str) == "string", "Argument 'verify_time_str' must be 'nil' or of type 'string'")
	assert(not wallet_str or type(wallet_str) == "string", "Argument 'wallet_str' must be 'nil' or of type 'string'")
	return {
		customId = custom_id_str or "",
		devices = devices_arr or {},
		disableTime = disable_time_str or "",
		email = email_str or "",
		user = user_api_user or M.create_api_user(),
		verifyTime = verify_time_str or "",
		wallet = wallet_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_api_account_apple
-- Send a Apple Sign In token to the server. Used with authenticate/link/unlink.
function M.create_api_account_apple(
	token_str -- 'string' () The ID token received from Apple to validate.
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not token_str or type(token_str) == "string", "Argument 'token_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		token = token_str or "",
		vars = vars_obj or { _ = '' },
	}
end

--------------------------------------------------------------------------------
--- create_api_account_custom
-- Send a custom ID to the server. Used with authenticate/link/unlink.
function M.create_api_account_custom(
	id_str -- 'string' () A custom identifier.
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		id = id_str or "",
		vars = vars_obj or { _ = '' },
	}
end

--------------------------------------------------------------------------------
--- create_api_account_device
-- Send a device to the server. Used with authenticate/link/unlink and user.
function M.create_api_account_device(
	id_str -- 'string' () A device identifier. Should be obtained by a platform-specific device API.
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		id = id_str or "",
		vars = vars_obj or { _ = '' },
	}
end

--------------------------------------------------------------------------------
--- create_api_account_email
-- Send an email with password to the server. Used with authenticate/link/unlink.
function M.create_api_account_email(
	email_str -- 'string' () A valid RFC-5322 email address.
	,password_str -- 'string' () A password for the user account.
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not email_str or type(email_str) == "string", "Argument 'email_str' must be 'nil' or of type 'string'")
	assert(not password_str or type(password_str) == "string", "Argument 'password_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		email = email_str or "",
		password = password_str or "",
		vars = vars_obj or { _ = '' },
	}
end

--------------------------------------------------------------------------------
--- create_api_account_facebook
-- Send a Facebook token to the server. Used with authenticate/link/unlink.
function M.create_api_account_facebook(
	token_str -- 'string' () The OAuth token received from Facebook to access their profile API.
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not token_str or type(token_str) == "string", "Argument 'token_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		token = token_str or "",
		vars = vars_obj or { _ = '' },
	}
end

--------------------------------------------------------------------------------
--- create_api_account_facebook_instant_game
-- Send a Facebook Instant Game token to the server. Used with authenticate/link/unlink.
function M.create_api_account_facebook_instant_game(
	signed_player_info_str -- 'string' () 
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not signed_player_info_str or type(signed_player_info_str) == "string", "Argument 'signed_player_info_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		signedPlayerInfo = signed_player_info_str or "",
		vars = vars_obj or { _ = '' },
	}
end

--------------------------------------------------------------------------------
--- create_api_account_game_center
-- Send Apple's Game Center account credentials to the server. Used with authenticate/link/unlink.
function M.create_api_account_game_center(
	bundle_id_str -- 'string' () Bundle ID (generated by GameCenter).
	,player_id_str -- 'string' () Player ID (generated by GameCenter).
	,public_key_url_str -- 'string' () The URL for the public encryption key.
	,salt_str -- 'string' () A random "NSString" used to compute the hash and keep it randomized.
	,signature_str -- 'string' () The verification signature data generated.
	,timestamp_seconds_str -- 'string' () Time since UNIX epoch when the signature was created.
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not bundle_id_str or type(bundle_id_str) == "string", "Argument 'bundle_id_str' must be 'nil' or of type 'string'")
	assert(not player_id_str or type(player_id_str) == "string", "Argument 'player_id_str' must be 'nil' or of type 'string'")
	assert(not public_key_url_str or type(public_key_url_str) == "string", "Argument 'public_key_url_str' must be 'nil' or of type 'string'")
	assert(not salt_str or type(salt_str) == "string", "Argument 'salt_str' must be 'nil' or of type 'string'")
	assert(not signature_str or type(signature_str) == "string", "Argument 'signature_str' must be 'nil' or of type 'string'")
	assert(not timestamp_seconds_str or type(timestamp_seconds_str) == "string", "Argument 'timestamp_seconds_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		bundleId = bundle_id_str or "",
		playerId = player_id_str or "",
		publicKeyUrl = public_key_url_str or "",
		salt = salt_str or "",
		signature = signature_str or "",
		timestampSeconds = timestamp_seconds_str or "",
		vars = vars_obj or { _ = '' },
	}
end

--------------------------------------------------------------------------------
--- create_api_account_google
-- Send a Google token to the server. Used with authenticate/link/unlink.
function M.create_api_account_google(
	token_str -- 'string' () The OAuth token received from Google to access their profile API.
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not token_str or type(token_str) == "string", "Argument 'token_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		token = token_str or "",
		vars = vars_obj or { _ = '' },
	}
end

--------------------------------------------------------------------------------
--- create_api_account_steam
-- Send a Steam token to the server. Used with authenticate/link/unlink.
function M.create_api_account_steam(
	token_str -- 'string' () The account token received from Steam to access their profile API.
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not token_str or type(token_str) == "string", "Argument 'token_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		token = token_str or "",
		vars = vars_obj or { _ = '' },
	}
end

--------------------------------------------------------------------------------
--- create_api_channel_message
-- A message sent on a channel.
function M.create_api_channel_message(
	channel_id_str -- 'string' () The channel this message belongs to.
	,code_int -- 'number' () The code representing a message type or category.
	,content_str -- 'string' () The content payload.
	,create_time_str -- 'string' () The UNIX time when the message was created.
	,group_id_str -- 'string' () The ID of the group, or an empty string if this message was not sent through a group channel.
	,message_id_str -- 'string' () The unique ID of this message.
	,persistent_bool -- 'boolean' () True if the message was persisted to the channel's history, false otherwise.
	,room_name_str -- 'string' () The name of the chat room, or an empty string if this message was not sent through a chat room.
	,sender_id_str -- 'string' () Message sender, usually a user ID.
	,update_time_str -- 'string' () The UNIX time when the message was last updated.
	,user_id_one_str -- 'string' () The ID of the first DM user, or an empty string if this message was not sent through a DM chat.
	,user_id_two_str -- 'string' () The ID of the second DM user, or an empty string if this message was not sent through a DM chat.
	,username_str -- 'string' () The username of the message sender, if any.
	)
	assert(not channel_id_str or type(channel_id_str) == "string", "Argument 'channel_id_str' must be 'nil' or of type 'string'")
	assert(not code_int or type(code_int) == "number", "Argument 'code_int' must be 'nil' or of type 'number'")
	assert(not content_str or type(content_str) == "string", "Argument 'content_str' must be 'nil' or of type 'string'")
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not group_id_str or type(group_id_str) == "string", "Argument 'group_id_str' must be 'nil' or of type 'string'")
	assert(not message_id_str or type(message_id_str) == "string", "Argument 'message_id_str' must be 'nil' or of type 'string'")
	assert(not persistent_bool or type(persistent_bool) == "boolean", "Argument 'persistent_bool' must be 'nil' or of type 'boolean'")
	assert(not room_name_str or type(room_name_str) == "string", "Argument 'room_name_str' must be 'nil' or of type 'string'")
	assert(not sender_id_str or type(sender_id_str) == "string", "Argument 'sender_id_str' must be 'nil' or of type 'string'")
	assert(not update_time_str or type(update_time_str) == "string", "Argument 'update_time_str' must be 'nil' or of type 'string'")
	assert(not user_id_one_str or type(user_id_one_str) == "string", "Argument 'user_id_one_str' must be 'nil' or of type 'string'")
	assert(not user_id_two_str or type(user_id_two_str) == "string", "Argument 'user_id_two_str' must be 'nil' or of type 'string'")
	assert(not username_str or type(username_str) == "string", "Argument 'username_str' must be 'nil' or of type 'string'")
	return {
		channelId = channel_id_str or "",
		code = code_int or 0,
		content = content_str or "",
		createTime = create_time_str or "",
		groupId = group_id_str or "",
		messageId = message_id_str or "",
		persistent = persistent_bool or false,
		roomName = room_name_str or "",
		senderId = sender_id_str or "",
		updateTime = update_time_str or "",
		userIdOne = user_id_one_str or "",
		userIdTwo = user_id_two_str or "",
		username = username_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_api_channel_message_list
-- A list of channel messages, usually a result of a list operation.
function M.create_api_channel_message_list(
	messages_arr -- 'table' () A list of messages.
	,next_cursor_str -- 'string' () The cursor to send when retireving the next page, if any.
	,prev_cursor_str -- 'string' () The cursor to send when retrieving the previous page, if any.
	)
	assert(not messages_arr or type(messages_arr) == "table", "Argument 'messages_arr' must be 'nil' or of type 'table'")
	assert(not next_cursor_str or type(next_cursor_str) == "string", "Argument 'next_cursor_str' must be 'nil' or of type 'string'")
	assert(not prev_cursor_str or type(prev_cursor_str) == "string", "Argument 'prev_cursor_str' must be 'nil' or of type 'string'")
	return {
		messages = messages_arr or {},
		nextCursor = next_cursor_str or "",
		prevCursor = prev_cursor_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_api_create_group_request
-- Create a group with the current user as owner.
function M.create_api_create_group_request(
	avatar_url_str -- 'string' () A URL for an avatar image.
	,description_str -- 'string' () A description for the group.
	,lang_tag_str -- 'string' () The language expected to be a tag which follows the BCP-47 spec.
	,max_count_int -- 'number' () Maximum number of group members.
	,name_str -- 'string' () A unique name for the group.
	,open_bool -- 'boolean' () Mark a group as open or not where only admins can accept members.
	)
	assert(not avatar_url_str or type(avatar_url_str) == "string", "Argument 'avatar_url_str' must be 'nil' or of type 'string'")
	assert(not description_str or type(description_str) == "string", "Argument 'description_str' must be 'nil' or of type 'string'")
	assert(not lang_tag_str or type(lang_tag_str) == "string", "Argument 'lang_tag_str' must be 'nil' or of type 'string'")
	assert(not max_count_int or type(max_count_int) == "number", "Argument 'max_count_int' must be 'nil' or of type 'number'")
	assert(not name_str or type(name_str) == "string", "Argument 'name_str' must be 'nil' or of type 'string'")
	assert(not open_bool or type(open_bool) == "boolean", "Argument 'open_bool' must be 'nil' or of type 'boolean'")
	return {
		avatarUrl = avatar_url_str or "",
		description = description_str or "",
		langTag = lang_tag_str or "",
		maxCount = max_count_int or 0,
		name = name_str or "",
		open = open_bool or false,
	}
end

--------------------------------------------------------------------------------
--- create_api_delete_storage_object_id
-- Storage objects to delete.
function M.create_api_delete_storage_object_id(
	collection_str -- 'string' () The collection which stores the object.
	,key_str -- 'string' () The key of the object within the collection.
	,version_str -- 'string' () The version hash of the object.
	)
	assert(not collection_str or type(collection_str) == "string", "Argument 'collection_str' must be 'nil' or of type 'string'")
	assert(not key_str or type(key_str) == "string", "Argument 'key_str' must be 'nil' or of type 'string'")
	assert(not version_str or type(version_str) == "string", "Argument 'version_str' must be 'nil' or of type 'string'")
	return {
		collection = collection_str or "",
		key = key_str or "",
		version = version_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_api_delete_storage_objects_request
-- Batch delete storage objects.
function M.create_api_delete_storage_objects_request(
	object_ids_arr -- 'table' () Batch of storage objects.
	)
	assert(not object_ids_arr or type(object_ids_arr) == "table", "Argument 'object_ids_arr' must be 'nil' or of type 'table'")
	return {
		objectIds = object_ids_arr or {},
	}
end

--------------------------------------------------------------------------------
--- create_api_event
-- Represents an event to be passed through the server to registered event handlers.
function M.create_api_event(
	external_bool -- 'boolean' () True if the event came directly from a client call, false otherwise.
	,name_str -- 'string' () An event name, type, category, or identifier.
	,properties_obj -- 'table' () Arbitrary event property values.
	,timestamp_str -- 'string' () The time when the event was triggered.
	)
	assert(not external_bool or type(external_bool) == "boolean", "Argument 'external_bool' must be 'nil' or of type 'boolean'")
	assert(not name_str or type(name_str) == "string", "Argument 'name_str' must be 'nil' or of type 'string'")
	assert(not properties_obj or type(properties_obj) == "table", "Argument 'properties_obj' must be 'nil' or of type 'table'")
	assert(not timestamp_str or type(timestamp_str) == "string", "Argument 'timestamp_str' must be 'nil' or of type 'string'")
	return {
		external = external_bool or false,
		name = name_str or "",
		properties = properties_obj or { _ = '' },
		timestamp = timestamp_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_api_friend
-- A friend of a user.
function M.create_api_friend(
	state_int -- 'number' () The friend status.
	,update_time_str -- 'string' () Time of the latest relationship update.
	,user_api_user -- 'table' (api_user) The user object.
	)
	assert(not state_int or type(state_int) == "number", "Argument 'state_int' must be 'nil' or of type 'number'")
	assert(not update_time_str or type(update_time_str) == "string", "Argument 'update_time_str' must be 'nil' or of type 'string'")
	assert(not user_api_user or type(user_api_user) == "table", "Argument 'user_api_user' must be 'nil' or of type 'table'")
	return {
		state = state_int or 0,
		updateTime = update_time_str or "",
		user = user_api_user or M.create_api_user(),
	}
end

--------------------------------------------------------------------------------
--- create_api_friend_list
-- A collection of zero or more friends of the user.
function M.create_api_friend_list(
	cursor_str -- 'string' () Cursor for the next page of results, if any.
	,friends_arr -- 'table' () The Friend objects.
	)
	assert(not cursor_str or type(cursor_str) == "string", "Argument 'cursor_str' must be 'nil' or of type 'string'")
	assert(not friends_arr or type(friends_arr) == "table", "Argument 'friends_arr' must be 'nil' or of type 'table'")
	return {
		cursor = cursor_str or "",
		friends = friends_arr or {},
	}
end

--------------------------------------------------------------------------------
--- create_api_group
-- A group in the server.
function M.create_api_group(
	avatar_url_str -- 'string' () A URL for an avatar image.
	,create_time_str -- 'string' () The UNIX time when the group was created.
	,creator_id_str -- 'string' () The id of the user who created the group.
	,description_str -- 'string' () A description for the group.
	,edge_count_int -- 'number' () The current count of all members in the group.
	,id_str -- 'string' () The id of a group.
	,lang_tag_str -- 'string' () The language expected to be a tag which follows the BCP-47 spec.
	,max_count_int -- 'number' () The maximum number of members allowed.
	,metadata_str -- 'string' () Additional information stored as a JSON object.
	,name_str -- 'string' () The unique name of the group.
	,open_bool -- 'boolean' () Anyone can join open groups, otherwise only admins can accept members.
	,update_time_str -- 'string' () The UNIX time when the group was last updated.
	)
	assert(not avatar_url_str or type(avatar_url_str) == "string", "Argument 'avatar_url_str' must be 'nil' or of type 'string'")
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not creator_id_str or type(creator_id_str) == "string", "Argument 'creator_id_str' must be 'nil' or of type 'string'")
	assert(not description_str or type(description_str) == "string", "Argument 'description_str' must be 'nil' or of type 'string'")
	assert(not edge_count_int or type(edge_count_int) == "number", "Argument 'edge_count_int' must be 'nil' or of type 'number'")
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not lang_tag_str or type(lang_tag_str) == "string", "Argument 'lang_tag_str' must be 'nil' or of type 'string'")
	assert(not max_count_int or type(max_count_int) == "number", "Argument 'max_count_int' must be 'nil' or of type 'number'")
	assert(not metadata_str or type(metadata_str) == "string", "Argument 'metadata_str' must be 'nil' or of type 'string'")
	assert(not name_str or type(name_str) == "string", "Argument 'name_str' must be 'nil' or of type 'string'")
	assert(not open_bool or type(open_bool) == "boolean", "Argument 'open_bool' must be 'nil' or of type 'boolean'")
	assert(not update_time_str or type(update_time_str) == "string", "Argument 'update_time_str' must be 'nil' or of type 'string'")
	return {
		avatarUrl = avatar_url_str or "",
		createTime = create_time_str or "",
		creatorId = creator_id_str or "",
		description = description_str or "",
		edgeCount = edge_count_int or 0,
		id = id_str or "",
		langTag = lang_tag_str or "",
		maxCount = max_count_int or 0,
		metadata = metadata_str or "",
		name = name_str or "",
		open = open_bool or false,
		updateTime = update_time_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_api_group_list
-- One or more groups returned from a listing operation.
function M.create_api_group_list(
	cursor_str -- 'string' () A cursor used to get the next page.
	,groups_arr -- 'table' () One or more groups.
	)
	assert(not cursor_str or type(cursor_str) == "string", "Argument 'cursor_str' must be 'nil' or of type 'string'")
	assert(not groups_arr or type(groups_arr) == "table", "Argument 'groups_arr' must be 'nil' or of type 'table'")
	return {
		cursor = cursor_str or "",
		groups = groups_arr or {},
	}
end

--------------------------------------------------------------------------------
--- create_api_group_user_list
-- A list of users belonging to a group, along with their role.
function M.create_api_group_user_list(
	cursor_str -- 'string' () Cursor for the next page of results, if any.
	,group_users_arr -- 'table' () User-role pairs for a group.
	)
	assert(not cursor_str or type(cursor_str) == "string", "Argument 'cursor_str' must be 'nil' or of type 'string'")
	assert(not group_users_arr or type(group_users_arr) == "table", "Argument 'group_users_arr' must be 'nil' or of type 'table'")
	return {
		cursor = cursor_str or "",
		groupUsers = group_users_arr or {},
	}
end

--------------------------------------------------------------------------------
--- create_api_leaderboard_record
-- Represents a complete leaderboard record with all scores and associated metadata.
function M.create_api_leaderboard_record(
	create_time_str -- 'string' () The UNIX time when the leaderboard record was created.
	,expiry_time_str -- 'string' () The UNIX time when the leaderboard record expires.
	,leaderboard_id_str -- 'string' () The ID of the leaderboard this score belongs to.
	,max_num_score_int -- 'number' () The maximum number of score updates allowed by the owner.
	,metadata_str -- 'string' () Metadata.
	,num_score_int -- 'number' () The number of submissions to this score record.
	,owner_id_str -- 'string' () The ID of the score owner, usually a user or group.
	,rank_str -- 'string' () The rank of this record.
	,score_str -- 'string' () The score value.
	,subscore_str -- 'string' () An optional subscore value.
	,update_time_str -- 'string' () The UNIX time when the leaderboard record was updated.
	,username_str -- 'string' () The username of the score owner, if the owner is a user.
	)
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not expiry_time_str or type(expiry_time_str) == "string", "Argument 'expiry_time_str' must be 'nil' or of type 'string'")
	assert(not leaderboard_id_str or type(leaderboard_id_str) == "string", "Argument 'leaderboard_id_str' must be 'nil' or of type 'string'")
	assert(not max_num_score_int or type(max_num_score_int) == "number", "Argument 'max_num_score_int' must be 'nil' or of type 'number'")
	assert(not metadata_str or type(metadata_str) == "string", "Argument 'metadata_str' must be 'nil' or of type 'string'")
	assert(not num_score_int or type(num_score_int) == "number", "Argument 'num_score_int' must be 'nil' or of type 'number'")
	assert(not owner_id_str or type(owner_id_str) == "string", "Argument 'owner_id_str' must be 'nil' or of type 'string'")
	assert(not rank_str or type(rank_str) == "string", "Argument 'rank_str' must be 'nil' or of type 'string'")
	assert(not score_str or type(score_str) == "string", "Argument 'score_str' must be 'nil' or of type 'string'")
	assert(not subscore_str or type(subscore_str) == "string", "Argument 'subscore_str' must be 'nil' or of type 'string'")
	assert(not update_time_str or type(update_time_str) == "string", "Argument 'update_time_str' must be 'nil' or of type 'string'")
	assert(not username_str or type(username_str) == "string", "Argument 'username_str' must be 'nil' or of type 'string'")
	return {
		createTime = create_time_str or "",
		expiryTime = expiry_time_str or "",
		leaderboardId = leaderboard_id_str or "",
		maxNumScore = max_num_score_int or 0,
		metadata = metadata_str or "",
		numScore = num_score_int or 0,
		ownerId = owner_id_str or "",
		rank = rank_str or "",
		score = score_str or "",
		subscore = subscore_str or "",
		updateTime = update_time_str or "",
		username = username_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_api_leaderboard_record_list
-- A set of leaderboard records, may be part of a leaderboard records page or a batch of individual records.
function M.create_api_leaderboard_record_list(
	next_cursor_str -- 'string' () The cursor to send when retrieving the next page, if any.
	,owner_records_arr -- 'table' () A batched set of leaderboard records belonging to specified owners.
	,prev_cursor_str -- 'string' () The cursor to send when retrieving the previous page, if any.
	,records_arr -- 'table' () A list of leaderboard records.
	)
	assert(not next_cursor_str or type(next_cursor_str) == "string", "Argument 'next_cursor_str' must be 'nil' or of type 'string'")
	assert(not owner_records_arr or type(owner_records_arr) == "table", "Argument 'owner_records_arr' must be 'nil' or of type 'table'")
	assert(not prev_cursor_str or type(prev_cursor_str) == "string", "Argument 'prev_cursor_str' must be 'nil' or of type 'string'")
	assert(not records_arr or type(records_arr) == "table", "Argument 'records_arr' must be 'nil' or of type 'table'")
	return {
		nextCursor = next_cursor_str or "",
		ownerRecords = owner_records_arr or {},
		prevCursor = prev_cursor_str or "",
		records = records_arr or {},
	}
end

--------------------------------------------------------------------------------
--- create_api_match
-- Represents a realtime match.
function M.create_api_match(
	authoritative_bool -- 'boolean' () True if it's an server-managed authoritative match, false otherwise.
	,label_str -- 'string' () Match label, if any.
	,match_id_str -- 'string' () The ID of the match, can be used to join.
	,size_int -- 'number' () Current number of users in the match.
	)
	assert(not authoritative_bool or type(authoritative_bool) == "boolean", "Argument 'authoritative_bool' must be 'nil' or of type 'boolean'")
	assert(not label_str or type(label_str) == "string", "Argument 'label_str' must be 'nil' or of type 'string'")
	assert(not match_id_str or type(match_id_str) == "string", "Argument 'match_id_str' must be 'nil' or of type 'string'")
	assert(not size_int or type(size_int) == "number", "Argument 'size_int' must be 'nil' or of type 'number'")
	return {
		authoritative = authoritative_bool or false,
		label = label_str or "",
		matchId = match_id_str or "",
		size = size_int or 0,
	}
end

--------------------------------------------------------------------------------
--- create_api_match_list
-- A list of realtime matches.
function M.create_api_match_list(
	matches_arr -- 'table' () A number of matches corresponding to a list operation.
	)
	assert(not matches_arr or type(matches_arr) == "table", "Argument 'matches_arr' must be 'nil' or of type 'table'")
	return {
		matches = matches_arr or {},
	}
end

--------------------------------------------------------------------------------
--- create_api_notification
-- A notification in the server.
function M.create_api_notification(
	code_int -- 'number' () Category code for this notification.
	,content_str -- 'string' () Content of the notification in JSON.
	,create_time_str -- 'string' () The UNIX time when the notification was created.
	,id_str -- 'string' () ID of the Notification.
	,persistent_bool -- 'boolean' () True if this notification was persisted to the database.
	,sender_id_str -- 'string' () ID of the sender, if a user. Otherwise 'null'.
	,subject_str -- 'string' () Subject of the notification.
	)
	assert(not code_int or type(code_int) == "number", "Argument 'code_int' must be 'nil' or of type 'number'")
	assert(not content_str or type(content_str) == "string", "Argument 'content_str' must be 'nil' or of type 'string'")
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not persistent_bool or type(persistent_bool) == "boolean", "Argument 'persistent_bool' must be 'nil' or of type 'boolean'")
	assert(not sender_id_str or type(sender_id_str) == "string", "Argument 'sender_id_str' must be 'nil' or of type 'string'")
	assert(not subject_str or type(subject_str) == "string", "Argument 'subject_str' must be 'nil' or of type 'string'")
	return {
		code = code_int or 0,
		content = content_str or "",
		createTime = create_time_str or "",
		id = id_str or "",
		persistent = persistent_bool or false,
		senderId = sender_id_str or "",
		subject = subject_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_api_notification_list
-- A collection of zero or more notifications.
function M.create_api_notification_list(
	cacheable_cursor_str -- 'string' () Use this cursor to paginate notifications. Cache this to catch up to new notifications.
	,notifications_arr -- 'table' () Collection of notifications.
	)
	assert(not cacheable_cursor_str or type(cacheable_cursor_str) == "string", "Argument 'cacheable_cursor_str' must be 'nil' or of type 'string'")
	assert(not notifications_arr or type(notifications_arr) == "table", "Argument 'notifications_arr' must be 'nil' or of type 'table'")
	return {
		cacheableCursor = cacheable_cursor_str or "",
		notifications = notifications_arr or {},
	}
end

--------------------------------------------------------------------------------
--- create_api_read_storage_object_id
-- Storage objects to get.
function M.create_api_read_storage_object_id(
	collection_str -- 'string' () The collection which stores the object.
	,key_str -- 'string' () The key of the object within the collection.
	,user_id_str -- 'string' () The user owner of the object.
	)
	assert(not collection_str or type(collection_str) == "string", "Argument 'collection_str' must be 'nil' or of type 'string'")
	assert(not key_str or type(key_str) == "string", "Argument 'key_str' must be 'nil' or of type 'string'")
	assert(not user_id_str or type(user_id_str) == "string", "Argument 'user_id_str' must be 'nil' or of type 'string'")
	return {
		collection = collection_str or "",
		key = key_str or "",
		userId = user_id_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_api_read_storage_objects_request
-- Batch get storage objects.
function M.create_api_read_storage_objects_request(
	object_ids_arr -- 'table' () Batch of storage objects.
	)
	assert(not object_ids_arr or type(object_ids_arr) == "table", "Argument 'object_ids_arr' must be 'nil' or of type 'table'")
	return {
		objectIds = object_ids_arr or {},
	}
end

--------------------------------------------------------------------------------
--- create_api_rpc
-- Execute an Lua function on the server.
function M.create_api_rpc(
	http_key_str -- 'string' () The authentication key used when executed as a non-client HTTP request.
	,id_str -- 'string' () The identifier of the function.
	,payload_str -- 'string' () The payload of the function which must be a JSON object.
	)
	assert(not http_key_str or type(http_key_str) == "string", "Argument 'http_key_str' must be 'nil' or of type 'string'")
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not payload_str or type(payload_str) == "string", "Argument 'payload_str' must be 'nil' or of type 'string'")
	return {
		httpKey = http_key_str or "",
		id = id_str or "",
		payload = payload_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_api_session
-- A user's session used to authenticate messages.
function M.create_api_session(
	created_bool -- 'boolean' () True if the corresponding account was just created, false otherwise.
	,token_str -- 'string' () Authentication credentials.
	)
	assert(not created_bool or type(created_bool) == "boolean", "Argument 'created_bool' must be 'nil' or of type 'boolean'")
	assert(not token_str or type(token_str) == "string", "Argument 'token_str' must be 'nil' or of type 'string'")
	return {
		created = created_bool or false,
		token = token_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_api_storage_object
-- An object within the storage engine.
function M.create_api_storage_object(
	collection_str -- 'string' () The collection which stores the object.
	,create_time_str -- 'string' () The UNIX time when the object was created.
	,key_str -- 'string' () The key of the object within the collection.
	,permission_read_int -- 'number' () The read access permissions for the object.
	,permission_write_int -- 'number' () The write access permissions for the object.
	,update_time_str -- 'string' () The UNIX time when the object was last updated.
	,user_id_str -- 'string' () The user owner of the object.
	,value_str -- 'string' () The value of the object.
	,version_str -- 'string' () The version hash of the object.
	)
	assert(not collection_str or type(collection_str) == "string", "Argument 'collection_str' must be 'nil' or of type 'string'")
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not key_str or type(key_str) == "string", "Argument 'key_str' must be 'nil' or of type 'string'")
	assert(not permission_read_int or type(permission_read_int) == "number", "Argument 'permission_read_int' must be 'nil' or of type 'number'")
	assert(not permission_write_int or type(permission_write_int) == "number", "Argument 'permission_write_int' must be 'nil' or of type 'number'")
	assert(not update_time_str or type(update_time_str) == "string", "Argument 'update_time_str' must be 'nil' or of type 'string'")
	assert(not user_id_str or type(user_id_str) == "string", "Argument 'user_id_str' must be 'nil' or of type 'string'")
	assert(not value_str or type(value_str) == "string", "Argument 'value_str' must be 'nil' or of type 'string'")
	assert(not version_str or type(version_str) == "string", "Argument 'version_str' must be 'nil' or of type 'string'")
	return {
		collection = collection_str or "",
		createTime = create_time_str or "",
		key = key_str or "",
		permissionRead = permission_read_int or 0,
		permissionWrite = permission_write_int or 0,
		updateTime = update_time_str or "",
		userId = user_id_str or "",
		value = value_str or "",
		version = version_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_api_storage_object_ack
-- A storage acknowledgement.
function M.create_api_storage_object_ack(
	collection_str -- 'string' () The collection which stores the object.
	,key_str -- 'string' () The key of the object within the collection.
	,user_id_str -- 'string' () The owner of the object.
	,version_str -- 'string' () The version hash of the object.
	)
	assert(not collection_str or type(collection_str) == "string", "Argument 'collection_str' must be 'nil' or of type 'string'")
	assert(not key_str or type(key_str) == "string", "Argument 'key_str' must be 'nil' or of type 'string'")
	assert(not user_id_str or type(user_id_str) == "string", "Argument 'user_id_str' must be 'nil' or of type 'string'")
	assert(not version_str or type(version_str) == "string", "Argument 'version_str' must be 'nil' or of type 'string'")
	return {
		collection = collection_str or "",
		key = key_str or "",
		userId = user_id_str or "",
		version = version_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_api_storage_object_acks
-- Batch of acknowledgements for the storage object write.
function M.create_api_storage_object_acks(
	acks_arr -- 'table' () Batch of storage write acknowledgements.
	)
	assert(not acks_arr or type(acks_arr) == "table", "Argument 'acks_arr' must be 'nil' or of type 'table'")
	return {
		acks = acks_arr or {},
	}
end

--------------------------------------------------------------------------------
--- create_api_storage_object_list
-- List of storage objects.
function M.create_api_storage_object_list(
	cursor_str -- 'string' () The cursor for the next page of results, if any.
	,objects_arr -- 'table' () The list of storage objects.
	)
	assert(not cursor_str or type(cursor_str) == "string", "Argument 'cursor_str' must be 'nil' or of type 'string'")
	assert(not objects_arr or type(objects_arr) == "table", "Argument 'objects_arr' must be 'nil' or of type 'table'")
	return {
		cursor = cursor_str or "",
		objects = objects_arr or {},
	}
end

--------------------------------------------------------------------------------
--- create_api_storage_objects
-- Batch of storage objects.
function M.create_api_storage_objects(
	objects_arr -- 'table' () The batch of storage objects.
	)
	assert(not objects_arr or type(objects_arr) == "table", "Argument 'objects_arr' must be 'nil' or of type 'table'")
	return {
		objects = objects_arr or {},
	}
end

--------------------------------------------------------------------------------
--- create_api_tournament
-- A tournament on the server.
function M.create_api_tournament(
	can_enter_bool -- 'boolean' () True if the tournament is active and can enter. A computed value.
	,category_int -- 'number' () The category of the tournament. e.g. "vip" could be category 1.
	,create_time_str -- 'string' () The UNIX time when the tournament was created.
	,description_str -- 'string' () The description of the tournament. May be blank.
	,duration_int -- 'number' () Duration of the tournament in seconds.
	,end_active_int -- 'number' () The UNIX time when the tournament stops being active until next reset. A computed value.
	,end_time_str -- 'string' () The UNIX time when the tournament will be stopped.
	,id_str -- 'string' () The ID of the tournament.
	,max_num_score_int -- 'number' () The maximum score updates allowed per player for the current tournament.
	,max_size_int -- 'number' () The maximum number of players for the tournament.
	,metadata_str -- 'string' () Additional information stored as a JSON object.
	,next_reset_int -- 'number' () The UNIX time when the tournament is next playable. A computed value.
	,size_int -- 'number' () The current number of players in the tournament.
	,sort_order_int -- 'number' () ASC or DESC sort mode of scores in the tournament.
	,start_active_int -- 'number' () The UNIX time when the tournament start being active. A computed value.
	,start_time_str -- 'string' () The UNIX time when the tournament will start.
	,title_str -- 'string' () The title for the tournament.
	)
	assert(not can_enter_bool or type(can_enter_bool) == "boolean", "Argument 'can_enter_bool' must be 'nil' or of type 'boolean'")
	assert(not category_int or type(category_int) == "number", "Argument 'category_int' must be 'nil' or of type 'number'")
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not description_str or type(description_str) == "string", "Argument 'description_str' must be 'nil' or of type 'string'")
	assert(not duration_int or type(duration_int) == "number", "Argument 'duration_int' must be 'nil' or of type 'number'")
	assert(not end_active_int or type(end_active_int) == "number", "Argument 'end_active_int' must be 'nil' or of type 'number'")
	assert(not end_time_str or type(end_time_str) == "string", "Argument 'end_time_str' must be 'nil' or of type 'string'")
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not max_num_score_int or type(max_num_score_int) == "number", "Argument 'max_num_score_int' must be 'nil' or of type 'number'")
	assert(not max_size_int or type(max_size_int) == "number", "Argument 'max_size_int' must be 'nil' or of type 'number'")
	assert(not metadata_str or type(metadata_str) == "string", "Argument 'metadata_str' must be 'nil' or of type 'string'")
	assert(not next_reset_int or type(next_reset_int) == "number", "Argument 'next_reset_int' must be 'nil' or of type 'number'")
	assert(not size_int or type(size_int) == "number", "Argument 'size_int' must be 'nil' or of type 'number'")
	assert(not sort_order_int or type(sort_order_int) == "number", "Argument 'sort_order_int' must be 'nil' or of type 'number'")
	assert(not start_active_int or type(start_active_int) == "number", "Argument 'start_active_int' must be 'nil' or of type 'number'")
	assert(not start_time_str or type(start_time_str) == "string", "Argument 'start_time_str' must be 'nil' or of type 'string'")
	assert(not title_str or type(title_str) == "string", "Argument 'title_str' must be 'nil' or of type 'string'")
	return {
		canEnter = can_enter_bool or false,
		category = category_int or 0,
		createTime = create_time_str or "",
		description = description_str or "",
		duration = duration_int or 0,
		endActive = end_active_int or 0,
		endTime = end_time_str or "",
		id = id_str or "",
		maxNumScore = max_num_score_int or 0,
		maxSize = max_size_int or 0,
		metadata = metadata_str or "",
		nextReset = next_reset_int or 0,
		size = size_int or 0,
		sortOrder = sort_order_int or 0,
		startActive = start_active_int or 0,
		startTime = start_time_str or "",
		title = title_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_api_tournament_list
-- A list of tournaments.
function M.create_api_tournament_list(
	cursor_str -- 'string' () A pagination cursor (optional).
	,tournaments_arr -- 'table' () The list of tournaments returned.
	)
	assert(not cursor_str or type(cursor_str) == "string", "Argument 'cursor_str' must be 'nil' or of type 'string'")
	assert(not tournaments_arr or type(tournaments_arr) == "table", "Argument 'tournaments_arr' must be 'nil' or of type 'table'")
	return {
		cursor = cursor_str or "",
		tournaments = tournaments_arr or {},
	}
end

--------------------------------------------------------------------------------
--- create_api_tournament_record_list
-- A set of tournament records which may be part of a tournament records page or a batch of individual records.
function M.create_api_tournament_record_list(
	next_cursor_str -- 'string' () The cursor to send when retireving the next page (optional).
	,owner_records_arr -- 'table' () A batched set of tournament records belonging to specified owners.
	,prev_cursor_str -- 'string' () The cursor to send when retrieving the previous page (optional).
	,records_arr -- 'table' () A list of tournament records.
	)
	assert(not next_cursor_str or type(next_cursor_str) == "string", "Argument 'next_cursor_str' must be 'nil' or of type 'string'")
	assert(not owner_records_arr or type(owner_records_arr) == "table", "Argument 'owner_records_arr' must be 'nil' or of type 'table'")
	assert(not prev_cursor_str or type(prev_cursor_str) == "string", "Argument 'prev_cursor_str' must be 'nil' or of type 'string'")
	assert(not records_arr or type(records_arr) == "table", "Argument 'records_arr' must be 'nil' or of type 'table'")
	return {
		nextCursor = next_cursor_str or "",
		ownerRecords = owner_records_arr or {},
		prevCursor = prev_cursor_str or "",
		records = records_arr or {},
	}
end

--------------------------------------------------------------------------------
--- create_api_update_account_request
-- Update a user's account details.
function M.create_api_update_account_request(
	avatar_url_str -- 'string' () A URL for an avatar image.
	,display_name_str -- 'string' () The display name of the user.
	,lang_tag_str -- 'string' () The language expected to be a tag which follows the BCP-47 spec.
	,location_str -- 'string' () The location set by the user.
	,timezone_str -- 'string' () The timezone set by the user.
	,username_str -- 'string' () The username of the user's account.
	)
	assert(not avatar_url_str or type(avatar_url_str) == "string", "Argument 'avatar_url_str' must be 'nil' or of type 'string'")
	assert(not display_name_str or type(display_name_str) == "string", "Argument 'display_name_str' must be 'nil' or of type 'string'")
	assert(not lang_tag_str or type(lang_tag_str) == "string", "Argument 'lang_tag_str' must be 'nil' or of type 'string'")
	assert(not location_str or type(location_str) == "string", "Argument 'location_str' must be 'nil' or of type 'string'")
	assert(not timezone_str or type(timezone_str) == "string", "Argument 'timezone_str' must be 'nil' or of type 'string'")
	assert(not username_str or type(username_str) == "string", "Argument 'username_str' must be 'nil' or of type 'string'")
	return {
		avatarUrl = avatar_url_str or "",
		displayName = display_name_str or "",
		langTag = lang_tag_str or "",
		location = location_str or "",
		timezone = timezone_str or "",
		username = username_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_api_update_group_request
-- Update fields in a given group.
function M.create_api_update_group_request(
	avatar_url_str -- 'string' () Avatar URL.
	,description_str -- 'string' () Description string.
	,group_id_str -- 'string' () The ID of the group to update.
	,lang_tag_str -- 'string' () Lang tag.
	,name_str -- 'string' () Name.
	,open_bool -- 'boolean' () Open is true if anyone should be allowed to join, or false if joins must be approved by a group admin.
	)
	assert(not avatar_url_str or type(avatar_url_str) == "string", "Argument 'avatar_url_str' must be 'nil' or of type 'string'")
	assert(not description_str or type(description_str) == "string", "Argument 'description_str' must be 'nil' or of type 'string'")
	assert(not group_id_str or type(group_id_str) == "string", "Argument 'group_id_str' must be 'nil' or of type 'string'")
	assert(not lang_tag_str or type(lang_tag_str) == "string", "Argument 'lang_tag_str' must be 'nil' or of type 'string'")
	assert(not name_str or type(name_str) == "string", "Argument 'name_str' must be 'nil' or of type 'string'")
	assert(not open_bool or type(open_bool) == "boolean", "Argument 'open_bool' must be 'nil' or of type 'boolean'")
	return {
		avatarUrl = avatar_url_str or "",
		description = description_str or "",
		groupId = group_id_str or "",
		langTag = lang_tag_str or "",
		name = name_str or "",
		open = open_bool or false,
	}
end

--------------------------------------------------------------------------------
--- create_api_user
-- A user in the server.
function M.create_api_user(
	apple_id_str -- 'string' () The Apple Sign In ID in the user's account.
	,avatar_url_str -- 'string' () A URL for an avatar image.
	,create_time_str -- 'string' () The UNIX time when the user was created.
	,display_name_str -- 'string' () The display name of the user.
	,edge_count_int -- 'number' () Number of related edges to this user.
	,facebook_id_str -- 'string' () The Facebook id in the user's account.
	,facebook_instant_game_id_str -- 'string' () The Facebook Instant Game ID in the user's account.
	,gamecenter_id_str -- 'string' () The Apple Game Center in of the user's account.
	,google_id_str -- 'string' () The Google id in the user's account.
	,id_str -- 'string' () The id of the user's account.
	,lang_tag_str -- 'string' () The language expected to be a tag which follows the BCP-47 spec.
	,location_str -- 'string' () The location set by the user.
	,metadata_str -- 'string' () Additional information stored as a JSON object.
	,online_bool -- 'boolean' () Indicates whether the user is currently online.
	,steam_id_str -- 'string' () The Steam id in the user's account.
	,timezone_str -- 'string' () The timezone set by the user.
	,update_time_str -- 'string' () The UNIX time when the user was last updated.
	,username_str -- 'string' () The username of the user's account.
	)
	assert(not apple_id_str or type(apple_id_str) == "string", "Argument 'apple_id_str' must be 'nil' or of type 'string'")
	assert(not avatar_url_str or type(avatar_url_str) == "string", "Argument 'avatar_url_str' must be 'nil' or of type 'string'")
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not display_name_str or type(display_name_str) == "string", "Argument 'display_name_str' must be 'nil' or of type 'string'")
	assert(not edge_count_int or type(edge_count_int) == "number", "Argument 'edge_count_int' must be 'nil' or of type 'number'")
	assert(not facebook_id_str or type(facebook_id_str) == "string", "Argument 'facebook_id_str' must be 'nil' or of type 'string'")
	assert(not facebook_instant_game_id_str or type(facebook_instant_game_id_str) == "string", "Argument 'facebook_instant_game_id_str' must be 'nil' or of type 'string'")
	assert(not gamecenter_id_str or type(gamecenter_id_str) == "string", "Argument 'gamecenter_id_str' must be 'nil' or of type 'string'")
	assert(not google_id_str or type(google_id_str) == "string", "Argument 'google_id_str' must be 'nil' or of type 'string'")
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not lang_tag_str or type(lang_tag_str) == "string", "Argument 'lang_tag_str' must be 'nil' or of type 'string'")
	assert(not location_str or type(location_str) == "string", "Argument 'location_str' must be 'nil' or of type 'string'")
	assert(not metadata_str or type(metadata_str) == "string", "Argument 'metadata_str' must be 'nil' or of type 'string'")
	assert(not online_bool or type(online_bool) == "boolean", "Argument 'online_bool' must be 'nil' or of type 'boolean'")
	assert(not steam_id_str or type(steam_id_str) == "string", "Argument 'steam_id_str' must be 'nil' or of type 'string'")
	assert(not timezone_str or type(timezone_str) == "string", "Argument 'timezone_str' must be 'nil' or of type 'string'")
	assert(not update_time_str or type(update_time_str) == "string", "Argument 'update_time_str' must be 'nil' or of type 'string'")
	assert(not username_str or type(username_str) == "string", "Argument 'username_str' must be 'nil' or of type 'string'")
	return {
		appleId = apple_id_str or "",
		avatarUrl = avatar_url_str or "",
		createTime = create_time_str or "",
		displayName = display_name_str or "",
		edgeCount = edge_count_int or 0,
		facebookId = facebook_id_str or "",
		facebookInstantGameId = facebook_instant_game_id_str or "",
		gamecenterId = gamecenter_id_str or "",
		googleId = google_id_str or "",
		id = id_str or "",
		langTag = lang_tag_str or "",
		location = location_str or "",
		metadata = metadata_str or "",
		online = online_bool or false,
		steamId = steam_id_str or "",
		timezone = timezone_str or "",
		updateTime = update_time_str or "",
		username = username_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_api_user_group_list
-- A list of groups belonging to a user, along with the user's role in each group.
function M.create_api_user_group_list(
	cursor_str -- 'string' () Cursor for the next page of results, if any.
	,user_groups_arr -- 'table' () Group-role pairs for a user.
	)
	assert(not cursor_str or type(cursor_str) == "string", "Argument 'cursor_str' must be 'nil' or of type 'string'")
	assert(not user_groups_arr or type(user_groups_arr) == "table", "Argument 'user_groups_arr' must be 'nil' or of type 'table'")
	return {
		cursor = cursor_str or "",
		userGroups = user_groups_arr or {},
	}
end

--------------------------------------------------------------------------------
--- create_api_users
-- A collection of zero or more users.
function M.create_api_users(
	users_arr -- 'table' () The User objects.
	)
	assert(not users_arr or type(users_arr) == "table", "Argument 'users_arr' must be 'nil' or of type 'table'")
	return {
		users = users_arr or {},
	}
end

--------------------------------------------------------------------------------
--- create_api_write_storage_object
-- The object to store.
function M.create_api_write_storage_object(
	collection_str -- 'string' () The collection to store the object.
	,key_str -- 'string' () The key for the object within the collection.
	,permission_read_int -- 'number' () The read access permissions for the object.
	,permission_write_int -- 'number' () The write access permissions for the object.
	,value_str -- 'string' () The value of the object.
	,version_str -- 'string' () The version hash of the object to check. Possible values are: ["", "*", "#hash#"].
	)
	assert(not collection_str or type(collection_str) == "string", "Argument 'collection_str' must be 'nil' or of type 'string'")
	assert(not key_str or type(key_str) == "string", "Argument 'key_str' must be 'nil' or of type 'string'")
	assert(not permission_read_int or type(permission_read_int) == "number", "Argument 'permission_read_int' must be 'nil' or of type 'number'")
	assert(not permission_write_int or type(permission_write_int) == "number", "Argument 'permission_write_int' must be 'nil' or of type 'number'")
	assert(not value_str or type(value_str) == "string", "Argument 'value_str' must be 'nil' or of type 'string'")
	assert(not version_str or type(version_str) == "string", "Argument 'version_str' must be 'nil' or of type 'string'")
	return {
		collection = collection_str or "",
		key = key_str or "",
		permissionRead = permission_read_int or 0,
		permissionWrite = permission_write_int or 0,
		value = value_str or "",
		version = version_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_api_write_storage_objects_request
-- Write objects to the storage engine.
function M.create_api_write_storage_objects_request(
	objects_arr -- 'table' () The objects to store on the server.
	)
	assert(not objects_arr or type(objects_arr) == "table", "Argument 'objects_arr' must be 'nil' or of type 'table'")
	return {
		objects = objects_arr or {},
	}
end

--------------------------------------------------------------------------------
--- create_protobuf_any
-- `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example "foo.bar.com/x/y.z" will yield type name "y.z".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       "@type": "type.googleapis.com/google.profile.Person",       "firstName": <string>,       "lastName": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       "@type": "type.googleapis.com/google.protobuf.Duration",       "value": "1.212s"     }
function M.create_protobuf_any(
	type_url_str -- 'string' () A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one "/" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading "." is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
	,value_str -- 'string' () Must be a valid serialized protocol buffer of the above specified type.
	)
	assert(not type_url_str or type(type_url_str) == "string", "Argument 'type_url_str' must be 'nil' or of type 'string'")
	assert(not value_str or type(value_str) == "string", "Argument 'value_str' must be 'nil' or of type 'string'")
	return {
		typeUrl = type_url_str or "",
		value = value_str or "",
	}
end

--------------------------------------------------------------------------------
--- create_rpc_status
-- 
function M.create_rpc_status(
	code_int -- 'number' () 
	,details_arr -- 'table' () 
	,message_str -- 'string' () 
	)
	assert(not code_int or type(code_int) == "number", "Argument 'code_int' must be 'nil' or of type 'number'")
	assert(not details_arr or type(details_arr) == "table", "Argument 'details_arr' must be 'nil' or of type 'table'")
	assert(not message_str or type(message_str) == "string", "Argument 'message_str' must be 'nil' or of type 'string'")
	return {
		code = code_int or 0,
		details = details_arr or {},
		message = message_str or "",
	}
end


--------------------------------------------------------------------------------
-- The low level client for the Nakama API.

local _config = {}

--- Create a Nakama client instance
-- @param config
-- config.engine - Engine specific implementations
-- config.host
-- config.port
-- config.timeout
-- config.use_ssl - Use secure or non-secure sockets
-- config.bearer_token
-- config.username
-- config.password
-- @return Client instance
function M.create_client(config)
	assert(config, "You must provide a configuration")
	assert(config.host, "You must provide a host")
	assert(config.port, "You must provide a port")
	assert(config.engine, "You must provide an engine")
	assert(type(config.engine.http) == "function", "The engine must provide the 'http' function")
	assert(type(config.engine.socket_create) == "function", "The engine must provide the 'socket_create' function")
	assert(type(config.engine.socket_connect) == "function", "The engine must provide the 'socket_connect' function")
	assert(type(config.engine.socket_send) == "function", "The engine must provide the 'socket_send' function")
	log("init()")

	local client = {}
	local scheme = config.use_ssl and "https" or "http"
	client.engine = config.engine
	client.config = {}
	client.config.host = config.host
	client.config.port = config.port
	client.config.http_uri = ("%s://%s:%d"):format(scheme, config.host, config.port)
	client.config.bearer_token = config.bearer_token
	client.config.username = config.username
	client.config.password = config.password
	client.config.timeout = config.timeout or 10
	client.config.use_ssl = config.use_ssl

	return client
end

function M.on_notification(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_notification = fn
end
function M.on_matchdata(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_matchdata = fn
end
function M.on_matchpresence(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_matchpresence = fn
end
function M.on_matchmakermatched(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_matchmakermatched = fn
end
function M.on_statuspresence(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_statuspresence = fn
end
function M.on_streampresence(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_streampresence = fn
end
function M.on_streamdata(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_streamdata = fn
end
function M.on_channelmessage(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_channelmessage = fn
end
function M.on_channelpresence(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_channelpresence = fn
end
function M.on_disconnect(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_disconnect = fn
end

local function on_socket_message(socket, message)
	if message.notifications then
		if socket.on_notification then
			for n in ipairs(message.notifications.notifications) do
				socket.on_notification(message)
			end
		end
	elseif message.match_data then
		if socket.on_matchdata then socket.on_matchdata(message) end
	elseif message.match_presence_event then
		if socket.on_matchpresence then socket.on_matchpresence(message) end
	elseif message.matchmaker_matched then
		if socket.on_matchmakermatched then socket.on_matchmakermatched(message) end
	elseif message.status_presence_event then
		if socket.on_statuspresence then socket.on_statuspresence(message) end
	elseif message.stream_presence_event then
		if socket.on_streampresence then socket.on_streampresence(message) end
	elseif message.stream_data then
		if socket.on_streamdata then socket.on_streamdata(message) end
	elseif message.channel_message then
		if socket.on_channelmessage then socket.on_channelmessage(message) end
	elseif message.channel_presence_event then
		if socket.on_channelpresence then socket.on_channelpresence(message) end
	else
		log("Unhandled message")
	end
end

--- Create a Nakama socket
-- @param client The client to create the socket for
-- @return Socket instance
function M.create_socket(client)
	assert(client, "You must provide a client")
	local socket = client.engine.socket_create(client.config, on_socket_message)
	assert(socket, "No socket created")
	assert(type(socket) == "table", "The created instance must be a table")
	socket.client = client
	socket.engine = client.engine
	return socket
end

--- Attempt to connect a Nakama socket to the server
-- @param socket The client socket to connect (from call to create_socket)
-- @param callback Optional callback to invoke with the result
-- @return If no callback is provided the function returns the result
function M.socket_connect(socket, callback)
	assert(socket, "You must provide a socket")
	if callback then
		socket.engine.socket_connect(socket, callback)
	else
		return async(function(done)
			socket.engine.socket_connect(socket, done)
		end)
	end
end

--- Send message on Nakama socket
-- @param socket The client socket to use when sending the message
-- @param callback Optional callback to invoke with the result
-- @return If not callback is provided the function returns the result
function M.socket_send(socket, message, callback)
	assert(socket, "You must provide a socket")
	assert(message, "You must provide a message")
	if callback then
		socket.engine.socket_send(socket, message, callback)
	else
		return async(function(done)
			socket.engine.socket_send(socket, message, done)
		end)
	end
end

function M.sync(fn)
	local co = coroutine.create(fn)
	local ok, err = coroutine.resume(co)
	if not ok then
		log(err)
	end
end

function M.set_bearer_token(client, bearer_token)
	assert(client, "You must provide a client")
	client.config.bearer_token = bearer_token
end

--- healthcheck
-- A healthcheck which load balancers can use to check the service.
-- @param client Nakama client
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.healthcheck(
	client
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/healthcheck"

	local query_params = {}

	if callback then
		log("healthcheck() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			callback(result)
		end)
	else
		log("healthcheck() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- get_account
-- Fetch the current user's account.
-- @param client Nakama client
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.get_account(
	client
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account"

	local query_params = {}

	if callback then
		log("get_account() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_account then
				result = api_account.create(result)
			end
			callback(result)
		end)
	else
		log("get_account() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_account then
					result = api_account.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- update_account
-- Update fields in the current user's account.
-- @param client Nakama client
-- @param body_api_update_account_request (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.update_account(
	client
	,body_api_update_account_request
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account"

	local query_params = {}
	local post_data = json.encode(body_api_update_account_request)

	if callback then
		log("update_account() with callback")
		client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
			callback(result)
		end)
	else
		log("update_account() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- authenticate_apple
-- Authenticate a user with an Apple ID against the server.
-- @param client Nakama client
-- @param body_api_account_apple (table) The Apple account details.
-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.authenticate_apple(
	client
	,body_api_account_apple
	,create_bool
	,username_str
	,callback)
	assert(client, "You must provide a client")
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/apple"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_apple)

	if callback then
		log("authenticate_apple() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_apple() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_custom
-- Authenticate a user with a custom id against the server.
-- @param client Nakama client
-- @param body_api_account_custom (table) The custom account details.
-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.authenticate_custom(
	client
	,body_api_account_custom
	,create_bool
	,username_str
	,callback)
	assert(client, "You must provide a client")
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/custom"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_custom)

	if callback then
		log("authenticate_custom() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_custom() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_device
-- Authenticate a user with a device id against the server.
-- @param client Nakama client
-- @param body_api_account_device (table) The device account details.
-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.authenticate_device(
	client
	,body_api_account_device
	,create_bool
	,username_str
	,callback)
	assert(client, "You must provide a client")
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/device"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_device)

	if callback then
		log("authenticate_device() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_device() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_email
-- Authenticate a user with an email+password against the server.
-- @param client Nakama client
-- @param body_api_account_email (table) The email account details.
-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.authenticate_email(
	client
	,body_api_account_email
	,create_bool
	,username_str
	,callback)
	assert(client, "You must provide a client")
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/email"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_email)

	if callback then
		log("authenticate_email() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_email() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_facebook
-- Authenticate a user with a Facebook OAuth token against the server.
-- @param client Nakama client
-- @param body_api_account_facebook (table) The Facebook account details.
-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param sync_bool (boolean) Import Facebook friends for the user.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.authenticate_facebook(
	client
	,body_api_account_facebook
	,create_bool
	,username_str
	,sync_bool
	,callback)
	assert(client, "You must provide a client")
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/facebook"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	query_params["sync"] = sync_bool
	local post_data = json.encode(body_api_account_facebook)

	if callback then
		log("authenticate_facebook() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_facebook() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_facebook_instant_game
-- Authenticate a user with a Facebook Instant Game token against the server.
-- @param client Nakama client
-- @param body_api_account_facebook_instant_game (table) The Facebook Instant Game account details.
-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.authenticate_facebook_instant_game(
	client
	,body_api_account_facebook_instant_game
	,create_bool
	,username_str
	,callback)
	assert(client, "You must provide a client")
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/facebookinstantgame"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_facebook_instant_game)

	if callback then
		log("authenticate_facebook_instant_game() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_facebook_instant_game() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_game_center
-- Authenticate a user with Apple's GameCenter against the server.
-- @param client Nakama client
-- @param body_api_account_game_center (table) The Game Center account details.
-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.authenticate_game_center(
	client
	,body_api_account_game_center
	,create_bool
	,username_str
	,callback)
	assert(client, "You must provide a client")
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/gamecenter"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_game_center)

	if callback then
		log("authenticate_game_center() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_game_center() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_google
-- Authenticate a user with Google against the server.
-- @param client Nakama client
-- @param body_api_account_google (table) The Google account details.
-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.authenticate_google(
	client
	,body_api_account_google
	,create_bool
	,username_str
	,callback)
	assert(client, "You must provide a client")
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/google"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_google)

	if callback then
		log("authenticate_google() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_google() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_steam
-- Authenticate a user with Steam against the server.
-- @param client Nakama client
-- @param body_api_account_steam (table) The Steam account details.
-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.authenticate_steam(
	client
	,body_api_account_steam
	,create_bool
	,username_str
	,callback)
	assert(client, "You must provide a client")
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/steam"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_steam)

	if callback then
		log("authenticate_steam() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_steam() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- link_apple
-- Add an Apple ID to the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_apple (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.link_apple(
	client
	,body_api_account_apple
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/link/apple"

	local query_params = {}
	local post_data = json.encode(body_api_account_apple)

	if callback then
		log("link_apple() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_apple() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_custom
-- Add a custom ID to the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_custom (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.link_custom(
	client
	,body_api_account_custom
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/link/custom"

	local query_params = {}
	local post_data = json.encode(body_api_account_custom)

	if callback then
		log("link_custom() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_custom() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_device
-- Add a device ID to the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_device (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.link_device(
	client
	,body_api_account_device
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/link/device"

	local query_params = {}
	local post_data = json.encode(body_api_account_device)

	if callback then
		log("link_device() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_device() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_email
-- Add an email+password to the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_email (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.link_email(
	client
	,body_api_account_email
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/link/email"

	local query_params = {}
	local post_data = json.encode(body_api_account_email)

	if callback then
		log("link_email() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_email() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_facebook
-- Add Facebook to the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_facebook (table) The Facebook account details.
-- @param sync_bool (boolean) Import Facebook friends for the user.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.link_facebook(
	client
	,body_api_account_facebook
	,sync_bool
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/link/facebook"

	local query_params = {}
	query_params["sync"] = sync_bool
	local post_data = json.encode(body_api_account_facebook)

	if callback then
		log("link_facebook() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_facebook() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_facebook_instant_game
-- Add Facebook Instant Game to the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_facebook_instant_game (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.link_facebook_instant_game(
	client
	,body_api_account_facebook_instant_game
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/link/facebookinstantgame"

	local query_params = {}
	local post_data = json.encode(body_api_account_facebook_instant_game)

	if callback then
		log("link_facebook_instant_game() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_facebook_instant_game() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_game_center
-- Add Apple's GameCenter to the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_game_center (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.link_game_center(
	client
	,body_api_account_game_center
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/link/gamecenter"

	local query_params = {}
	local post_data = json.encode(body_api_account_game_center)

	if callback then
		log("link_game_center() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_game_center() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_google
-- Add Google to the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_google (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.link_google(
	client
	,body_api_account_google
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/link/google"

	local query_params = {}
	local post_data = json.encode(body_api_account_google)

	if callback then
		log("link_google() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_google() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_steam
-- Add Steam to the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_steam (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.link_steam(
	client
	,body_api_account_steam
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/link/steam"

	local query_params = {}
	local post_data = json.encode(body_api_account_steam)

	if callback then
		log("link_steam() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_steam() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_apple
-- Remove the Apple ID from the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_apple (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.unlink_apple(
	client
	,body_api_account_apple
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/unlink/apple"

	local query_params = {}
	local post_data = json.encode(body_api_account_apple)

	if callback then
		log("unlink_apple() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_apple() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_custom
-- Remove the custom ID from the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_custom (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.unlink_custom(
	client
	,body_api_account_custom
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/unlink/custom"

	local query_params = {}
	local post_data = json.encode(body_api_account_custom)

	if callback then
		log("unlink_custom() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_custom() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_device
-- Remove the device ID from the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_device (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.unlink_device(
	client
	,body_api_account_device
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/unlink/device"

	local query_params = {}
	local post_data = json.encode(body_api_account_device)

	if callback then
		log("unlink_device() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_device() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_email
-- Remove the email+password from the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_email (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.unlink_email(
	client
	,body_api_account_email
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/unlink/email"

	local query_params = {}
	local post_data = json.encode(body_api_account_email)

	if callback then
		log("unlink_email() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_email() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_facebook
-- Remove Facebook from the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_facebook (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.unlink_facebook(
	client
	,body_api_account_facebook
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/unlink/facebook"

	local query_params = {}
	local post_data = json.encode(body_api_account_facebook)

	if callback then
		log("unlink_facebook() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_facebook() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_facebook_instant_game
-- Remove Facebook Instant Game profile from the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_facebook_instant_game (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.unlink_facebook_instant_game(
	client
	,body_api_account_facebook_instant_game
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/unlink/facebookinstantgame"

	local query_params = {}
	local post_data = json.encode(body_api_account_facebook_instant_game)

	if callback then
		log("unlink_facebook_instant_game() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_facebook_instant_game() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_game_center
-- Remove Apple's GameCenter from the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_game_center (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.unlink_game_center(
	client
	,body_api_account_game_center
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/unlink/gamecenter"

	local query_params = {}
	local post_data = json.encode(body_api_account_game_center)

	if callback then
		log("unlink_game_center() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_game_center() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_google
-- Remove Google from the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_google (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.unlink_google(
	client
	,body_api_account_google
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/unlink/google"

	local query_params = {}
	local post_data = json.encode(body_api_account_google)

	if callback then
		log("unlink_google() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_google() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_steam
-- Remove Steam from the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_steam (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.unlink_steam(
	client
	,body_api_account_steam
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/unlink/steam"

	local query_params = {}
	local post_data = json.encode(body_api_account_steam)

	if callback then
		log("unlink_steam() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_steam() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_channel_messages
-- List a channel's message history.
-- @param client Nakama client
-- @param channel_id_str (string) The channel ID to list from.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param forward_bool (boolean) True if listing should be older messages to newer, false if reverse.
-- @param cursor_str (string) A pagination cursor, if any.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_channel_messages(
	client
	,channel_id_str
	,limit_int
	,forward_bool
	,cursor_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/channel/{channelId}"
	url_path = url_path:gsub("{channelId}", uri_encode(channel_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["forward"] = forward_bool
	query_params["cursor"] = cursor_str

	if callback then
		log("list_channel_messages() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_channel_message_list then
				result = api_channel_message_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_channel_messages() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_channel_message_list then
					result = api_channel_message_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- event
-- Submit an event for processing in the server's registered runtime custom events handler.
-- @param client Nakama client
-- @param body_api_event (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.event(
	client
	,body_api_event
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/event"

	local query_params = {}
	local post_data = json.encode(body_api_event)

	if callback then
		log("event() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("event() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- delete_friends
-- Delete one or more users by ID or username.
-- @param client Nakama client
-- @param ids_arr (table) The account id of a user.
-- @param usernames_arr (table) The account username of a user.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.delete_friends(
	client
	,ids_arr
	,usernames_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/friend"

	local query_params = {}
	query_params["ids"] = ids_arr
	query_params["usernames"] = usernames_arr

	if callback then
		log("delete_friends() with callback")
		client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
			callback(result)
		end)
	else
		log("delete_friends() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_friends
-- List all friends for the current user.
-- @param client Nakama client
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param state_int (number) The friend state to list.
-- @param cursor_str (string) An optional next page cursor.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_friends(
	client
	,limit_int
	,state_int
	,cursor_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/friend"

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["state"] = state_int
	query_params["cursor"] = cursor_str

	if callback then
		log("list_friends() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_friend_list then
				result = api_friend_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_friends() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_friend_list then
					result = api_friend_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- add_friends
-- Add friends by ID or username to a user's account.
-- @param client Nakama client
-- @param ids_arr (table) The account id of a user.
-- @param usernames_arr (table) The account username of a user.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.add_friends(
	client
	,ids_arr
	,usernames_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/friend"

	local query_params = {}
	query_params["ids"] = ids_arr
	query_params["usernames"] = usernames_arr

	if callback then
		log("add_friends() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("add_friends() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- block_friends
-- Block one or more users by ID or username.
-- @param client Nakama client
-- @param ids_arr (table) The account id of a user.
-- @param usernames_arr (table) The account username of a user.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.block_friends(
	client
	,ids_arr
	,usernames_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/friend/block"

	local query_params = {}
	query_params["ids"] = ids_arr
	query_params["usernames"] = usernames_arr

	if callback then
		log("block_friends() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("block_friends() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- import_facebook_friends
-- Import Facebook friends and add them to a user's account.
-- @param client Nakama client
-- @param body_api_account_facebook (table) The Facebook account details.
-- @param reset_bool (boolean) Reset the current user's friends list.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.import_facebook_friends(
	client
	,body_api_account_facebook
	,reset_bool
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/friend/facebook"

	local query_params = {}
	query_params["reset"] = reset_bool
	local post_data = json.encode(body_api_account_facebook)

	if callback then
		log("import_facebook_friends() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("import_facebook_friends() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_groups
-- List groups based on given filters.
-- @param client Nakama client
-- @param name_str (string) List groups that contain this value in their names.
-- @param cursor_str (string) Optional pagination cursor.
-- @param limit_int (number) Max number of groups to return. Between 1 and 100.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_groups(
	client
	,name_str
	,cursor_str
	,limit_int
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group"

	local query_params = {}
	query_params["name"] = name_str
	query_params["cursor"] = cursor_str
	query_params["limit"] = limit_int

	if callback then
		log("list_groups() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_group_list then
				result = api_group_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_groups() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_group_list then
					result = api_group_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- create_group
-- Create a new group with the current user as the owner.
-- @param client Nakama client
-- @param body_api_create_group_request (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.create_group(
	client
	,body_api_create_group_request
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group"

	local query_params = {}
	local post_data = json.encode(body_api_create_group_request)

	if callback then
		log("create_group() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_group then
				result = api_group.create(result)
			end
			callback(result)
		end)
	else
		log("create_group() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_group then
					result = api_group.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- delete_group
-- Delete a group by ID.
-- @param client Nakama client
-- @param group_id_str (string) The id of a group.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.delete_group(
	client
	,group_id_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}

	if callback then
		log("delete_group() with callback")
		client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
			callback(result)
		end)
	else
		log("delete_group() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- update_group
-- Update fields in a given group.
-- @param client Nakama client
-- @param group_id_str (string) The ID of the group to update.
-- @param body_api_update_group_request (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.update_group(
	client
	,group_id_str
	,body_api_update_group_request
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	local post_data = json.encode(body_api_update_group_request)

	if callback then
		log("update_group() with callback")
		client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
			callback(result)
		end)
	else
		log("update_group() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- add_group_users
-- Add users to a group.
-- @param client Nakama client
-- @param group_id_str (string) The group to add users to.
-- @param user_ids_arr (table) The users to add.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.add_group_users(
	client
	,group_id_str
	,user_ids_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/add"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	if callback then
		log("add_group_users() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("add_group_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- ban_group_users
-- Ban a set of users from a group.
-- @param client Nakama client
-- @param group_id_str (string) The group to ban users from.
-- @param user_ids_arr (table) The users to ban.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.ban_group_users(
	client
	,group_id_str
	,user_ids_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/ban"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	if callback then
		log("ban_group_users() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("ban_group_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- demote_group_users
-- Demote a set of users in a group to the next role down.
-- @param client Nakama client
-- @param group_id_str (string) The group ID to demote in.
-- @param user_ids_arr (table) The users to demote.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.demote_group_users(
	client
	,group_id_str
	,user_ids_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/demote"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	if callback then
		log("demote_group_users() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("demote_group_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- join_group
-- Immediately join an open group, or request to join a closed one.
-- @param client Nakama client
-- @param group_id_str (string) The group ID to join. The group must already exist.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.join_group(
	client
	,group_id_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/join"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}

	if callback then
		log("join_group() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("join_group() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- kick_group_users
-- Kick a set of users from a group.
-- @param client Nakama client
-- @param group_id_str (string) The group ID to kick from.
-- @param user_ids_arr (table) The users to kick.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.kick_group_users(
	client
	,group_id_str
	,user_ids_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/kick"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	if callback then
		log("kick_group_users() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("kick_group_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- leave_group
-- Leave a group the user is a member of.
-- @param client Nakama client
-- @param group_id_str (string) The group ID to leave.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.leave_group(
	client
	,group_id_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/leave"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}

	if callback then
		log("leave_group() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("leave_group() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- promote_group_users
-- Promote a set of users in a group to the next role up.
-- @param client Nakama client
-- @param group_id_str (string) The group ID to promote in.
-- @param user_ids_arr (table) The users to promote.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.promote_group_users(
	client
	,group_id_str
	,user_ids_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/promote"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	if callback then
		log("promote_group_users() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("promote_group_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_group_users
-- List all users that are part of a group.
-- @param client Nakama client
-- @param group_id_str (string) The group ID to list from.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param state_int (number) The group user state to list.
-- @param cursor_str (string) An optional next page cursor.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_group_users(
	client
	,group_id_str
	,limit_int
	,state_int
	,cursor_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/user"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["state"] = state_int
	query_params["cursor"] = cursor_str

	if callback then
		log("list_group_users() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_group_user_list then
				result = api_group_user_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_group_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_group_user_list then
					result = api_group_user_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- delete_leaderboard_record
-- Delete a leaderboard record.
-- @param client Nakama client
-- @param leaderboard_id_str (string) The leaderboard ID to delete from.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.delete_leaderboard_record(
	client
	,leaderboard_id_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/leaderboard/{leaderboardId}"
	url_path = url_path:gsub("{leaderboardId}", uri_encode(leaderboard_id_str))

	local query_params = {}

	if callback then
		log("delete_leaderboard_record() with callback")
		client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
			callback(result)
		end)
	else
		log("delete_leaderboard_record() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_leaderboard_records
-- List leaderboard records.
-- @param client Nakama client
-- @param leaderboard_id_str (string) The ID of the leaderboard to list for.
-- @param owner_ids_arr (table) One or more owners to retrieve records for.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param cursor_str (string) A next or previous page cursor.
-- @param expiry_str (string) Expiry in seconds (since epoch) to begin fetching records from. Optional. 0 means from current time.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_leaderboard_records(
	client
	,leaderboard_id_str
	,owner_ids_arr
	,limit_int
	,cursor_str
	,expiry_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/leaderboard/{leaderboardId}"
	url_path = url_path:gsub("{leaderboardId}", uri_encode(leaderboard_id_str))

	local query_params = {}
	query_params["ownerIds"] = owner_ids_arr
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str
	query_params["expiry"] = expiry_str

	if callback then
		log("list_leaderboard_records() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_leaderboard_record_list then
				result = api_leaderboard_record_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_leaderboard_records() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_leaderboard_record_list then
					result = api_leaderboard_record_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- write_leaderboard_record
-- Write a record to a leaderboard.
-- @param client Nakama client
-- @param leaderboard_id_str (string) The ID of the leaderboard to write to.
-- @param body_write_leaderboard_record_request_leaderboard_record_write (table) Record input.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.write_leaderboard_record(
	client
	,leaderboard_id_str
	,body_write_leaderboard_record_request_leaderboard_record_write
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/leaderboard/{leaderboardId}"
	url_path = url_path:gsub("{leaderboardId}", uri_encode(leaderboard_id_str))

	local query_params = {}
	local post_data = json.encode(body_write_leaderboard_record_request_leaderboard_record_write)

	if callback then
		log("write_leaderboard_record() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_leaderboard_record then
				result = api_leaderboard_record.create(result)
			end
			callback(result)
		end)
	else
		log("write_leaderboard_record() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_leaderboard_record then
					result = api_leaderboard_record.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- list_leaderboard_records_around_owner
-- List leaderboard records that belong to a user.
-- @param client Nakama client
-- @param leaderboard_id_str (string) The ID of the tournament to list for.
-- @param owner_id_str (string) The owner to retrieve records around.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param expiry_str (string) Expiry in seconds (since epoch) to begin fetching records from.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_leaderboard_records_around_owner(
	client
	,leaderboard_id_str
	,owner_id_str
	,limit_int
	,expiry_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/leaderboard/{leaderboardId}/owner/{ownerId}"
	url_path = url_path:gsub("{leaderboardId}", uri_encode(leaderboard_id_str))
	url_path = url_path:gsub("{ownerId}", uri_encode(owner_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["expiry"] = expiry_str

	if callback then
		log("list_leaderboard_records_around_owner() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_leaderboard_record_list then
				result = api_leaderboard_record_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_leaderboard_records_around_owner() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_leaderboard_record_list then
					result = api_leaderboard_record_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- list_matches
-- Fetch list of running matches.
-- @param client Nakama client
-- @param limit_int (number) Limit the number of returned matches.
-- @param authoritative_bool (boolean) Authoritative or relayed matches.
-- @param label_str (string) Label filter.
-- @param min_size_int (number) Minimum user count.
-- @param max_size_int (number) Maximum user count.
-- @param query_str (string) Arbitrary label query.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_matches(
	client
	,limit_int
	,authoritative_bool
	,label_str
	,min_size_int
	,max_size_int
	,query_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/match"

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["authoritative"] = authoritative_bool
	query_params["label"] = label_str
	query_params["minSize"] = min_size_int
	query_params["maxSize"] = max_size_int
	query_params["query"] = query_str

	if callback then
		log("list_matches() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_match_list then
				result = api_match_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_matches() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_match_list then
					result = api_match_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- delete_notifications
-- Delete one or more notifications for the current user.
-- @param client Nakama client
-- @param ids_arr (table) The id of notifications.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.delete_notifications(
	client
	,ids_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/notification"

	local query_params = {}
	query_params["ids"] = ids_arr

	if callback then
		log("delete_notifications() with callback")
		client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
			callback(result)
		end)
	else
		log("delete_notifications() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_notifications
-- Fetch list of notifications.
-- @param client Nakama client
-- @param limit_int (number) The number of notifications to get. Between 1 and 100.
-- @param cacheable_cursor_str (string) A cursor to page through notifications. May be cached by clients to get from point in time forwards.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_notifications(
	client
	,limit_int
	,cacheable_cursor_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/notification"

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["cacheableCursor"] = cacheable_cursor_str

	if callback then
		log("list_notifications() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_notification_list then
				result = api_notification_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_notifications() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_notification_list then
					result = api_notification_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- rpc_func2
-- Execute a Lua function on the server.
-- @param client Nakama client
-- @param id_str (string) The identifier of the function.
-- @param payload_str (string) The payload of the function which must be a JSON object.
-- @param http_key_str (string) The authentication key used when executed as a non-client HTTP request.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.rpc_func2(
	client
	,id_str
	,payload_str
	,http_key_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/rpc/{id}"
	url_path = url_path:gsub("{id}", uri_encode(id_str))

	local query_params = {}
	query_params["payload"] = payload_str
	query_params["httpKey"] = http_key_str

	if callback then
		log("rpc_func2() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_rpc then
				result = api_rpc.create(result)
			end
			callback(result)
		end)
	else
		log("rpc_func2() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_rpc then
					result = api_rpc.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- rpc_func
-- Execute a Lua function on the server.
-- @param client Nakama client
-- @param id_str (string) The identifier of the function.
-- @param body_ (table) The payload of the function which must be a JSON object.
-- @param http_key_str (string) The authentication key used when executed as a non-client HTTP request.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.rpc_func(
	client
	,id_str
	,body_
	,http_key_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/rpc/{id}"
	url_path = url_path:gsub("{id}", uri_encode(id_str))

	local query_params = {}
	query_params["httpKey"] = http_key_str
	local post_data = json.encode(body_)

	if callback then
		log("rpc_func() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_rpc then
				result = api_rpc.create(result)
			end
			callback(result)
		end)
	else
		log("rpc_func() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_rpc then
					result = api_rpc.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- read_storage_objects
-- Get storage objects.
-- @param client Nakama client
-- @param body_api_read_storage_objects_request (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.read_storage_objects(
	client
	,body_api_read_storage_objects_request
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/storage"

	local query_params = {}
	local post_data = json.encode(body_api_read_storage_objects_request)

	if callback then
		log("read_storage_objects() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_storage_objects then
				result = api_storage_objects.create(result)
			end
			callback(result)
		end)
	else
		log("read_storage_objects() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_storage_objects then
					result = api_storage_objects.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- write_storage_objects
-- Write objects into the storage engine.
-- @param client Nakama client
-- @param body_api_write_storage_objects_request (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.write_storage_objects(
	client
	,body_api_write_storage_objects_request
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/storage"

	local query_params = {}
	local post_data = json.encode(body_api_write_storage_objects_request)

	if callback then
		log("write_storage_objects() with callback")
		client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
			if not result.error and api_storage_object_acks then
				result = api_storage_object_acks.create(result)
			end
			callback(result)
		end)
	else
		log("write_storage_objects() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
				if not result.error and api_storage_object_acks then
					result = api_storage_object_acks.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- delete_storage_objects
-- Delete one or more objects by ID or username.
-- @param client Nakama client
-- @param body_api_delete_storage_objects_request (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.delete_storage_objects(
	client
	,body_api_delete_storage_objects_request
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/storage/delete"

	local query_params = {}
	local post_data = json.encode(body_api_delete_storage_objects_request)

	if callback then
		log("delete_storage_objects() with callback")
		client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
			callback(result)
		end)
	else
		log("delete_storage_objects() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_storage_objects
-- List publicly readable storage objects in a given collection.
-- @param client Nakama client
-- @param collection_str (string) The collection which stores the object.
-- @param user_id_str (string) ID of the user.
-- @param limit_int (number) The number of storage objects to list. Between 1 and 100.
-- @param cursor_str (string) The cursor to page through results from.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_storage_objects(
	client
	,collection_str
	,user_id_str
	,limit_int
	,cursor_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/storage/{collection}"
	url_path = url_path:gsub("{collection}", uri_encode(collection_str))

	local query_params = {}
	query_params["userId"] = user_id_str
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str

	if callback then
		log("list_storage_objects() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_storage_object_list then
				result = api_storage_object_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_storage_objects() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_storage_object_list then
					result = api_storage_object_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- list_storage_objects2
-- List publicly readable storage objects in a given collection.
-- @param client Nakama client
-- @param collection_str (string) The collection which stores the object.
-- @param user_id_str (string) ID of the user.
-- @param limit_int (number) The number of storage objects to list. Between 1 and 100.
-- @param cursor_str (string) The cursor to page through results from.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_storage_objects2(
	client
	,collection_str
	,user_id_str
	,limit_int
	,cursor_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/storage/{collection}/{userId}"
	url_path = url_path:gsub("{collection}", uri_encode(collection_str))
	url_path = url_path:gsub("{userId}", uri_encode(user_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str

	if callback then
		log("list_storage_objects2() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_storage_object_list then
				result = api_storage_object_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_storage_objects2() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_storage_object_list then
					result = api_storage_object_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- list_tournaments
-- List current or upcoming tournaments.
-- @param client Nakama client
-- @param category_start_int (number) The start of the categories to include. Defaults to 0.
-- @param category_end_int (number) The end of the categories to include. Defaults to 128.
-- @param start_time_int (number) The start time for tournaments. Defaults to epoch.
-- @param end_time_int (number) The end time for tournaments. Defaults to +1 year from current Unix time.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param cursor_str (string) A next page cursor for listings (optional).
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_tournaments(
	client
	,category_start_int
	,category_end_int
	,start_time_int
	,end_time_int
	,limit_int
	,cursor_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/tournament"

	local query_params = {}
	query_params["categoryStart"] = category_start_int
	query_params["categoryEnd"] = category_end_int
	query_params["startTime"] = start_time_int
	query_params["endTime"] = end_time_int
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str

	if callback then
		log("list_tournaments() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_tournament_list then
				result = api_tournament_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_tournaments() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_tournament_list then
					result = api_tournament_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- list_tournament_records
-- List tournament records.
-- @param client Nakama client
-- @param tournament_id_str (string) The ID of the tournament to list for.
-- @param owner_ids_arr (table) One or more owners to retrieve records for.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param cursor_str (string) A next or previous page cursor.
-- @param expiry_str (string) Expiry in seconds (since epoch) to begin fetching records from.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_tournament_records(
	client
	,tournament_id_str
	,owner_ids_arr
	,limit_int
	,cursor_str
	,expiry_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/tournament/{tournamentId}"
	url_path = url_path:gsub("{tournamentId}", uri_encode(tournament_id_str))

	local query_params = {}
	query_params["ownerIds"] = owner_ids_arr
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str
	query_params["expiry"] = expiry_str

	if callback then
		log("list_tournament_records() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_tournament_record_list then
				result = api_tournament_record_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_tournament_records() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_tournament_record_list then
					result = api_tournament_record_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- write_tournament_record
-- Write a record to a tournament.
-- @param client Nakama client
-- @param tournament_id_str (string) The tournament ID to write the record for.
-- @param body_write_tournament_record_request_tournament_record_write (table) Record input.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.write_tournament_record(
	client
	,tournament_id_str
	,body_write_tournament_record_request_tournament_record_write
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/tournament/{tournamentId}"
	url_path = url_path:gsub("{tournamentId}", uri_encode(tournament_id_str))

	local query_params = {}
	local post_data = json.encode(body_write_tournament_record_request_tournament_record_write)

	if callback then
		log("write_tournament_record() with callback")
		client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
			if not result.error and api_leaderboard_record then
				result = api_leaderboard_record.create(result)
			end
			callback(result)
		end)
	else
		log("write_tournament_record() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
				if not result.error and api_leaderboard_record then
					result = api_leaderboard_record.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- join_tournament
-- Attempt to join an open and running tournament.
-- @param client Nakama client
-- @param tournament_id_str (string) The ID of the tournament to join. The tournament must already exist.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.join_tournament(
	client
	,tournament_id_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/tournament/{tournamentId}/join"
	url_path = url_path:gsub("{tournamentId}", uri_encode(tournament_id_str))

	local query_params = {}

	if callback then
		log("join_tournament() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("join_tournament() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_tournament_records_around_owner
-- List tournament records for a given owner.
-- @param client Nakama client
-- @param tournament_id_str (string) The ID of the tournament to list for.
-- @param owner_id_str (string) The owner to retrieve records around.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param expiry_str (string) Expiry in seconds (since epoch) to begin fetching records from.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_tournament_records_around_owner(
	client
	,tournament_id_str
	,owner_id_str
	,limit_int
	,expiry_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/tournament/{tournamentId}/owner/{ownerId}"
	url_path = url_path:gsub("{tournamentId}", uri_encode(tournament_id_str))
	url_path = url_path:gsub("{ownerId}", uri_encode(owner_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["expiry"] = expiry_str

	if callback then
		log("list_tournament_records_around_owner() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_tournament_record_list then
				result = api_tournament_record_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_tournament_records_around_owner() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_tournament_record_list then
					result = api_tournament_record_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- get_users
-- Fetch zero or more users by ID and/or username.
-- @param client Nakama client
-- @param ids_arr (table) The account id of a user.
-- @param usernames_arr (table) The account username of a user.
-- @param facebook_ids_arr (table) The Facebook ID of a user.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.get_users(
	client
	,ids_arr
	,usernames_arr
	,facebook_ids_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/user"

	local query_params = {}
	query_params["ids"] = ids_arr
	query_params["usernames"] = usernames_arr
	query_params["facebookIds"] = facebook_ids_arr

	if callback then
		log("get_users() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_users then
				result = api_users.create(result)
			end
			callback(result)
		end)
	else
		log("get_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_users then
					result = api_users.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- list_user_groups
-- List groups the current user belongs to.
-- @param client Nakama client
-- @param user_id_str (string) ID of the user.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param state_int (number) The user group state to list.
-- @param cursor_str (string) An optional next page cursor.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_user_groups(
	client
	,user_id_str
	,limit_int
	,state_int
	,cursor_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/user/{userId}/group"
	url_path = url_path:gsub("{userId}", uri_encode(user_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["state"] = state_int
	query_params["cursor"] = cursor_str

	if callback then
		log("list_user_groups() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_user_group_list then
				result = api_user_group_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_user_groups() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_user_group_list then
					result = api_user_group_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

return M
