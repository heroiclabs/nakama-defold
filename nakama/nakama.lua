-- Code generated by codegen/main.go. DO NOT EDIT.

--[[--
The Nakama client SDK for Defold.

@module nakama
]]

local json = require "nakama.util.json"
local b64 = require "nakama.util.b64"
local log = require "nakama.util.log"
local async = require "nakama.util.async"
local api_session = require "nakama.session"

local uri = require "nakama.util.uri"
local uri_encode = uri.encode

local M = {}


--- Create a match.
-- @return The result of match_create.
function M.create_match_create_message()
	local message = {
		match_create = {}
	}
	return message
end


--- Add a current user to a match.
-- @param match_id The match id string.
-- @param token The authorization token.
-- @param metadata A table of metadata.
-- @return The result of match_join.
function M.create_match_join_message(match_id, token, metadata)
	assert(not match_id or (match_id and type(match_id) == "string"), "Argument 'match_id' must be 'nil' or of type 'string'")
	assert(not token or (token and type(token) == "string"), "Argument 'token' must be 'nil' or of type 'string'")
	local message = {
		match_join = {
			match_id = match_id,
			token = token,
			metadata = metadata,
		}
	}
	return message
end


--- Remove the current user from a match.
-- @param match_id The match id string.
-- @return The result of match_leave.
function M.create_match_leave_message(match_id)
	assert(match_id and type(match_id) == "string", "Argument 'match_id' must be of type 'string'")
	local message = {
		match_leave = {
			match_id = match_id,
		}
	}
	return message
end


--- Send a channel chat message if the current user has permission.
-- @param channel_id The channel id string.
-- @param content The message content string.
-- @return The result of channel_message_send.
function M.create_channel_message_send_message(channel_id, content)
	assert(channel_id and type(channel_id) == "string", "Argument 'channel_id' must be of type 'string'")
	assert(content and type(content) == "string", "Argument 'content' must be of type 'string'")
	local message = {
		channel_message_send = {
			channel_id = channel_id,
			content = content,
		}
	}
	return message
end


--- Update a channel chat message if the current user has permission.
-- @param channel_id The channel id string.
-- @param message_id The message id string.
-- @param content The message content string.
-- @return The result of channel_message_update.
function M.create_channel_message_update_message(channel_id, message_id, content)
	assert(channel_id and type(channel_id) == "string", "Argument 'channel_id' must be of type 'string'")
	assert(message_id and type(message_id) == "string", "Argument 'message_id' must be of type 'string'")
	assert(content and type(content) == "string", "Argument 'content' must be of type 'string'")
	local message = {
		channel_message_update = {
			channel_id = channel_id,
			message_id = message_id,
			content = content,
		}
	}
	return message
end


--- Remove a channel chat message if the current user has permission.
-- @param channel_id The channel id string.
-- @param message_id The message id string.
-- @return The result of channel_message_remove.
function M.create_channel_message_remove_message(channel_id, message_id)
	assert(channel_id and type(channel_id) == "string", "Argument 'channel_id' must be of type 'string'")
	assert(message_id and type(message_id) == "string", "Argument 'message_id' must be of type 'string'")
	local message = {
		channel_message_remove = {
			channel_id = channel_id,
			message_id = message_id,
		}
	}
	return message
end


--- Add the current user to a chat channel.
-- @param target The target channel id.
-- @param type The message type {"string","number"}.
-- @param persistence Is the message persistant boolean.
-- @param hidden Is the message hidden boolean.
-- @return The result of channel_join.
function M.create_channel_join_message(target, type, persistence, hidden)
	assert(target and type(target) == "string", "Argument 'target' must be of type 'string'")
	assert(type and type(type) == "number", "Argument 'type' must be of type 'number'")
	assert(persistence and type(persistence) == "boolean", "Argument 'persistence' must be of type 'boolean'")
	assert(hidden and type(hidden) == "boolean", "Argument 'hidden' must be of type 'boolean'")
	local message = {
		channel_join = {
			target = target,
			type = type,
			persistence = persistence,
			hidden = hidden,
		}
	}
	return message
end


--- Remove the current user from a chat channel.
-- @param channel_id The channel id string.
-- @return The result of channel_leave.
function M.create_channel_leave_message(channel_id)
	assert(channel_id and type(channel_id) == "string", "Argument 'channel_id' must be of type 'string'")
	local message = {
		channel_leave = {
			channel_id = channel_id,
		}
	}
	return message
end


--- Add the current user to a matchmaker.
-- @param query The matchmaker query string.
-- @param min_count The minimum user count.
-- @param max_count The maximum user count.
-- @param string_properties A table of user string properties.
-- @param numeric_properties A table of user numeric properties.
-- @return The result of matchmaker_add.
function M.create_matchmaker_add_message(query, min_count, max_count, string_properties, numeric_properties)
	assert(query and type(query) == "string", "Argument 'query' must be of type 'string'")
	assert(min_count and type(min_count) == "number", "Argument 'min_count' must be of type 'number'")
	assert(max_count and type(max_count) == "number", "Argument 'max_count' must be of type 'number'")
	local message = {
		matchmaker_add = {
			query = query,
			min_count = tostring(min_count),
			max_count = tostring(max_count),
			string_properties = string_properties,
			numeric_properties = numeric_properties,
		}
	}
	return message
end


--- Remove the current user from a matchmaker.
-- @param ticket The matchmaker ticket.
-- @return The result of matchmaker_remove.
function M.create_matchmaker_remove_message(ticket)
	assert(ticket and type(ticket) == "string", "Argument 'ticket' must be of type 'string'")
	local message = {
		matchmaker_remove = {
			ticket = ticket
		}
	}
	return message
end


--- Send match data for the current user.
-- @param match_id The match id string.
-- @param op_code The op_code number.
-- @param data The data string.
-- @return The result of match_data_send.
function M.create_match_data_message(match_id, op_code, data)
	assert(match_id and type(match_id) == "string", "Argument 'match_id' must be of type 'string'")
	assert(op_code and type(op_code) == "number", "Argument 'op_code' must be of type 'number'")
	assert(data and type(data) == "string", "Argument 'data' must be of type 'string'")
	local message = {
		match_data_send = {
			match_id = match_id,
			op_code = op_code,
			data = b64.encode(data),
		}
	}
	return message
end


--- Subscribe the current user to follow another user's status updates.
-- @param user_ids The user id string to follow.
-- @return The result of status_follow.
function M.create_status_follow_message(user_ids)
	assert(user_ids and type(user_ids) == "table", "Argument 'user_ids' must be of type 'table'")
	local message = {
		status_follow = {
			user_ids = user_ids
		}
	}
	return message
end


--- Unsubscribe the current user from following another user's status updates.
-- @param user_ids The user id string to unfollow.
-- @return The result of status_unfollow.
function M.create_status_unfollow_message(user_ids)
	assert(user_ids and type(user_ids) == "table", "Argument 'user_ids' must be of type 'table'")
	local message = {
		status_unfollow = {
			user_ids = user_ids
		}
	}
	return message
end


--- Update the current user's status.
-- @param status The status update string.
-- @return The result of status_update.
function M.create_status_update_message(status)
	assert(status and type(status) == "string", "Argument 'status' must be of type 'string'")
	local message = {
		status_update = {
			status = status
		}
	}
	return message
end

--- validated_purchase_environment
-- - UNKNOWN: Unknown environment.
-- - SANDBOX: Sandbox/test environment.
-- - PRODUCTION: Production environment.
M.VALIDATEDPURCHASEENVIRONMENT_UNKNOWN = "UNKNOWN"
M.VALIDATEDPURCHASEENVIRONMENT_SANDBOX = "SANDBOX"
M.VALIDATEDPURCHASEENVIRONMENT_PRODUCTION = "PRODUCTION"

--- validated_purchase_store
-- - APPLE_APP_STORE: Apple App Store
-- - GOOGLE_PLAY_STORE: Google Play Store
-- - HUAWEI_APP_GALLERY: Huawei App Gallery
M.VALIDATEDPURCHASESTORE_APPLE_APP_STORE = "APPLE_APP_STORE"
M.VALIDATEDPURCHASESTORE_GOOGLE_PLAY_STORE = "GOOGLE_PLAY_STORE"
M.VALIDATEDPURCHASESTORE_HUAWEI_APP_GALLERY = "HUAWEI_APP_GALLERY"

--- api_operator
-- Operator that can be used to override the one set in the leaderboard.
--
-- - NO_OVERRIDE: Do not override the leaderboard operator.
-- - BEST: Override the leaderboard operator with BEST.
-- - SET: Override the leaderboard operator with SET.
-- - INCREMENT: Override the leaderboard operator with INCREMENT.
-- - DECREMENT: Override the leaderboard operator with DECREMENT.
M.APIOPERATOR_NO_OVERRIDE = "NO_OVERRIDE"
M.APIOPERATOR_BEST = "BEST"
M.APIOPERATOR_SET = "SET"
M.APIOPERATOR_INCREMENT = "INCREMENT"
M.APIOPERATOR_DECREMENT = "DECREMENT"


-- The low level client for the Nakama API.

local _config = {}

--- Create a Nakama client instance.
-- @param config A table of configuration options.
-- config.engine - Engine specific implementations.
-- config.host
-- config.port
-- config.timeout
-- config.use_ssl - Use secure or non-secure sockets.
-- config.bearer_token
-- config.username
-- config.password
-- @return Nakama Client instance.
function M.create_client(config)
	assert(config, "You must provide a configuration")
	assert(config.host, "You must provide a host")
	assert(config.port, "You must provide a port")
	assert(config.engine, "You must provide an engine")
	assert(type(config.engine.http) == "function", "The engine must provide the 'http' function")
	assert(type(config.engine.socket_create) == "function", "The engine must provide the 'socket_create' function")
	assert(type(config.engine.socket_connect) == "function", "The engine must provide the 'socket_connect' function")
	assert(type(config.engine.socket_send) == "function", "The engine must provide the 'socket_send' function")
	log("init()")

	local client = {}
	local scheme = config.use_ssl and "https" or "http"
	client.engine = config.engine
	client.config = {}
	client.config.host = config.host
	client.config.port = config.port
	client.config.http_uri = ("%s://%s:%d"):format(scheme, config.host, config.port)
	client.config.bearer_token = config.bearer_token
	client.config.username = config.username
	client.config.password = config.password
	client.config.timeout = config.timeout or 10
	client.config.use_ssl = config.use_ssl

	return client
end


--- On notification hook.
-- @param socket Nakama Client Socket.
-- @param fn The callback function.
function M.on_notification(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_notification = fn
end

--- On match data hook.
-- @param socket Nakama Client Socket.
-- @param fn The callback function.
function M.on_matchdata(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_matchdata = fn
end

--- On match presence hook.
-- @param socket Nakama Client Socket.
-- @param fn The callback function.
function M.on_matchpresence(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_matchpresence = fn
end

--- On matchmaker matched hook.
-- @param socket Nakama Client Socket.
-- @param fn The callback function.
function M.on_matchmakermatched(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_matchmakermatched = fn
end

--- On status presence hook.
-- @param socket Nakama Client Socket.
-- @param fn The callback function.
function M.on_statuspresence(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_statuspresence = fn
end

--- On stream presence hook.
-- @param socket Nakama Client Socket.
-- @param fn The callback function.
function M.on_streampresence(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_streampresence = fn
end

--- On stream data hook.
-- @param socket Nakama Client Socket.
-- @param fn The callback function.
function M.on_streamdata(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_streamdata = fn
end

--- On channel message hook.
-- @param socket Nakama Client Socket.
-- @param fn The callback function.
function M.on_channelmessage(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_channelmessage = fn
end

--- On channel presence hook.
-- @param socket Nakama Client Socket.
-- @param fn The callback function.
function M.on_channelpresence(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_channelpresence = fn
end

--- On disconnect hook.
-- @param socket Nakama Client Socket.
-- @param fn The callback function.
function M.on_disconnect(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_disconnect = fn
end

-- Private socket message handler, will call specific event handlers.
local function on_socket_message(socket, message)
	if message.notifications then
		if socket.on_notification then
			for n in ipairs(message.notifications.notifications) do
				socket.on_notification(message)
			end
		end
	elseif message.match_data then
		if socket.on_matchdata then
			message.match_data.data = b64.decode(message.match_data.data)
			socket.on_matchdata(message)
		end
	elseif message.match_presence_event then
		if socket.on_matchpresence then socket.on_matchpresence(message) end
	elseif message.matchmaker_matched then
		if socket.on_matchmakermatched then socket.on_matchmakermatched(message) end
	elseif message.status_presence_event then
		if socket.on_statuspresence then socket.on_statuspresence(message) end
	elseif message.stream_presence_event then
		if socket.on_streampresence then socket.on_streampresence(message) end
	elseif message.stream_data then
		if socket.on_streamdata then socket.on_streamdata(message) end
	elseif message.channel_message then
		if socket.on_channelmessage then socket.on_channelmessage(message) end
	elseif message.channel_presence_event then
		if socket.on_channelpresence then socket.on_channelpresence(message) end
	else
		log("Unhandled message")
	end
end

--- Create a Nakama socket.
-- @param client The client to create the socket for.
-- @return Socket instance.
function M.create_socket(client)
	assert(client, "You must provide a client")
	local socket = client.engine.socket_create(client.config, on_socket_message)
	assert(socket, "No socket created")
	assert(type(socket) == "table", "The created instance must be a table")
	socket.client = client
	socket.engine = client.engine
	return socket
end

--- Attempt to connect a Nakama socket to the server.
-- @param socket The client socket to connect (from call to create_socket).
-- @param callback Optional callback to invoke with the result.
-- @return If no callback is provided the function returns the result.
function M.socket_connect(socket, callback)
	assert(socket, "You must provide a socket")
	if callback then
		socket.engine.socket_connect(socket, callback)
	else
		return async(function(done)
			socket.engine.socket_connect(socket, done)
		end)
	end
end

--- Send message on Nakama socket.
-- @param socket The client socket to use when sending the message.
-- @param message The message string.
-- @param callback Optional callback to invoke with the result.
-- @return If no callback is provided the function returns the result.
function M.socket_send(socket, message, callback)
	assert(socket, "You must provide a socket")
	assert(message, "You must provide a message")
	if callback then
		socket.engine.socket_send(socket, message, callback)
	else
		return async(function(done)
			socket.engine.socket_send(socket, message, done)
		end)
	end
end

-- Private
function M.sync(fn)
	local co = coroutine.create(fn)
	local ok, err = coroutine.resume(co)
	if not ok then
		log(err)
	end
end

--- Set Nakama client bearer token.
-- @param client Nakama client.
-- @param bearer_token Authorization bearer token.
function M.set_bearer_token(client, bearer_token)
	assert(client, "You must provide a client")
	client.config.bearer_token = bearer_token
end

--- healthcheck
-- A healthcheck which load balancers can use to check the service.
-- @param client Nakama client.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.healthcheck(client,callback)
	assert(client, "You must provide a client")

	local url_path = "/healthcheck"

	local query_params = {}

	if callback then
		log("healthcheck() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			callback(result)
		end)
	else
		log("healthcheck() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- get_account
-- Fetch the current user's account.
-- @param client Nakama client.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.get_account(client,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account"

	local query_params = {}

	if callback then
		log("get_account() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_account then
				result = api_account.create(result)
			end
			callback(result)
		end)
	else
		log("get_account() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_account then
					result = api_account.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- update_account
-- Update fields in the current user's account.
-- @param client Nakama client.
-- @param langTag (string) The language expected to be a tag which follows the BCP-47 spec.
-- @param location (string) The location set by the user.
-- @param timezone (string) The timezone set by the user.
-- @param username (string) The username of the user's account.
-- @param displayName (string) The display name of the user.
-- @param avatarUrl (string) A URL for an avatar image.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.update_account(client, avatarUrl, langTag, location, timezone, username, displayName,callback)
	assert(client, "You must provide a client")
	assert(not username or type(username) == "string", "Argument 'username' must be 'nil' or of type 'string'")
	assert(not displayName or type(displayName) == "string", "Argument 'displayName' must be 'nil' or of type 'string'")
	assert(not avatarUrl or type(avatarUrl) == "string", "Argument 'avatarUrl' must be 'nil' or of type 'string'")
	assert(not langTag or type(langTag) == "string", "Argument 'langTag' must be 'nil' or of type 'string'")
	assert(not location or type(location) == "string", "Argument 'location' must be 'nil' or of type 'string'")
	assert(not timezone or type(timezone) == "string", "Argument 'timezone' must be 'nil' or of type 'string'")


	local url_path = "/v2/account"

	local query_params = {}
	
	local post_data = json.encode({
	langTag = langTag,
	location = location,
	timezone = timezone,
	username = username,
	displayName = displayName,
	avatarUrl = avatarUrl,
	})

	if callback then
		log("update_account() with callback")
		client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
			callback(result)
		end)
	else
		log("update_account() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- authenticate_apple
-- Authenticate a user with an Apple ID against the server.
-- @param client Nakama client.
-- @param token (string) The ID token received from Apple to validate.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.authenticate_apple(client, vars, token, create_bool, username_str,callback)
	assert(client, "You must provide a client")
	assert(not token or type(token) == "string", "Argument 'token' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/apple"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	
	local post_data = json.encode({
	vars = vars,
	token = token,
	})

	if callback then
		log("authenticate_apple() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_apple() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_custom
-- Authenticate a user with a custom id against the server.
-- @param client Nakama client.
-- @param id (string) A custom identifier.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.authenticate_custom(client, id, vars, create_bool, username_str,callback)
	assert(client, "You must provide a client")
	assert(not id or type(id) == "string", "Argument 'id' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/custom"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	
	local post_data = json.encode({
	id = id,
	vars = vars,
	})

	if callback then
		log("authenticate_custom() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_custom() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_device
-- Authenticate a user with a device id against the server.
-- @param client Nakama client.
-- @param id (string) A device identifier. Should be obtained by a platform-specific device API.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.authenticate_device(client, id, vars, create_bool, username_str,callback)
	assert(client, "You must provide a client")
	assert(not id or type(id) == "string", "Argument 'id' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/device"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	
	local post_data = json.encode({
	id = id,
	vars = vars,
	})

	if callback then
		log("authenticate_device() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_device() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_email
-- Authenticate a user with an email+password against the server.
-- @param client Nakama client.
-- @param vars (object) Extra information that will be bundled in the session token.
-- @param email (string) A valid RFC-5322 email address.
-- @param password (string) A password for the user account.

-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.authenticate_email(client, email, password, vars, create_bool, username_str,callback)
	assert(client, "You must provide a client")
	assert(not email or type(email) == "string", "Argument 'email' must be 'nil' or of type 'string'")
	assert(not password or type(password) == "string", "Argument 'password' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/email"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	
	local post_data = json.encode({
	email = email,
	password = password,
	vars = vars,
	})

	if callback then
		log("authenticate_email() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_email() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_facebook
-- Authenticate a user with a Facebook OAuth token against the server.
-- @param client Nakama client.
-- @param token (string) The OAuth token received from Facebook to access their profile API.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param sync_bool (boolean) Import Facebook friends for the user.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.authenticate_facebook(client, token, vars, create_bool, username_str, sync_bool,callback)
	assert(client, "You must provide a client")
	assert(not token or type(token) == "string", "Argument 'token' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/facebook"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	query_params["sync"] = sync_bool
	
	local post_data = json.encode({
	token = token,
	vars = vars,
	})

	if callback then
		log("authenticate_facebook() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_facebook() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_facebook_instant_game
-- Authenticate a user with a Facebook Instant Game token against the server.
-- @param client Nakama client.
-- @param signedPlayerInfo (string) 
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.authenticate_facebook_instant_game(client, signedPlayerInfo, vars, create_bool, username_str,callback)
	assert(client, "You must provide a client")
	assert(not signedPlayerInfo or type(signedPlayerInfo) == "string", "Argument 'signedPlayerInfo' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/facebookinstantgame"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	
	local post_data = json.encode({
	signedPlayerInfo = signedPlayerInfo,
	vars = vars,
	})

	if callback then
		log("authenticate_facebook_instant_game() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_facebook_instant_game() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_game_center
-- Authenticate a user with Apple's GameCenter against the server.
-- @param client Nakama client.
-- @param timestampSeconds (string) Time since UNIX epoch when the signature was created.
-- @param salt (string) A random "NSString" used to compute the hash and keep it randomized.
-- @param signature (string) The verification signature data generated.
-- @param publicKeyUrl (string) The URL for the public encryption key.
-- @param vars (object) Extra information that will be bundled in the session token.
-- @param playerId (string) Player ID (generated by GameCenter).
-- @param bundleId (string) Bundle ID (generated by GameCenter).

-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.authenticate_game_center(client, signature, publicKeyUrl, vars, playerId, bundleId, timestampSeconds, salt, create_bool, username_str,callback)
	assert(client, "You must provide a client")
	assert(not playerId or type(playerId) == "string", "Argument 'playerId' must be 'nil' or of type 'string'")
	assert(not bundleId or type(bundleId) == "string", "Argument 'bundleId' must be 'nil' or of type 'string'")
	assert(not timestampSeconds or type(timestampSeconds) == "string", "Argument 'timestampSeconds' must be 'nil' or of type 'string'")
	assert(not salt or type(salt) == "string", "Argument 'salt' must be 'nil' or of type 'string'")
	assert(not signature or type(signature) == "string", "Argument 'signature' must be 'nil' or of type 'string'")
	assert(not publicKeyUrl or type(publicKeyUrl) == "string", "Argument 'publicKeyUrl' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/gamecenter"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	
	local post_data = json.encode({
	playerId = playerId,
	bundleId = bundleId,
	timestampSeconds = timestampSeconds,
	salt = salt,
	signature = signature,
	publicKeyUrl = publicKeyUrl,
	vars = vars,
	})

	if callback then
		log("authenticate_game_center() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_game_center() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_google
-- Authenticate a user with Google against the server.
-- @param client Nakama client.
-- @param token (string) The OAuth token received from Google to access their profile API.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.authenticate_google(client, token, vars, create_bool, username_str,callback)
	assert(client, "You must provide a client")
	assert(not token or type(token) == "string", "Argument 'token' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/google"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	
	local post_data = json.encode({
	token = token,
	vars = vars,
	})

	if callback then
		log("authenticate_google() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_google() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_steam
-- Authenticate a user with Steam against the server.
-- @param client Nakama client.
-- @param token (string) The account token received from Steam to access their profile API.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param sync_bool (boolean) Import Steam friends for the user.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.authenticate_steam(client, token, vars, create_bool, username_str, sync_bool,callback)
	assert(client, "You must provide a client")
	assert(not token or type(token) == "string", "Argument 'token' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")

	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/steam"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	query_params["sync"] = sync_bool
	
	local post_data = json.encode({
	token = token,
	vars = vars,
	})

	if callback then
		log("authenticate_steam() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_steam() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- link_apple
-- Add an Apple ID to the social profiles on the current user's account.
-- @param client Nakama client.
-- @param token (string) The ID token received from Apple to validate.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.link_apple(client, token, vars,callback)
	assert(client, "You must provide a client")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")
	assert(not token or type(token) == "string", "Argument 'token' must be 'nil' or of type 'string'")


	local url_path = "/v2/account/link/apple"

	local query_params = {}
	
	local post_data = json.encode({
	token = token,
	vars = vars,
	})

	if callback then
		log("link_apple() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_apple() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_custom
-- Add a custom ID to the social profiles on the current user's account.
-- @param client Nakama client.
-- @param id (string) A custom identifier.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.link_custom(client, id, vars,callback)
	assert(client, "You must provide a client")
	assert(not id or type(id) == "string", "Argument 'id' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")


	local url_path = "/v2/account/link/custom"

	local query_params = {}
	
	local post_data = json.encode({
	id = id,
	vars = vars,
	})

	if callback then
		log("link_custom() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_custom() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_device
-- Add a device ID to the social profiles on the current user's account.
-- @param client Nakama client.
-- @param id (string) A device identifier. Should be obtained by a platform-specific device API.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.link_device(client, id, vars,callback)
	assert(client, "You must provide a client")
	assert(not id or type(id) == "string", "Argument 'id' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")


	local url_path = "/v2/account/link/device"

	local query_params = {}
	
	local post_data = json.encode({
	id = id,
	vars = vars,
	})

	if callback then
		log("link_device() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_device() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_email
-- Add an email+password to the social profiles on the current user's account.
-- @param client Nakama client.
-- @param email (string) A valid RFC-5322 email address.
-- @param password (string) A password for the user account.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.link_email(client, email, password, vars,callback)
	assert(client, "You must provide a client")
	assert(not email or type(email) == "string", "Argument 'email' must be 'nil' or of type 'string'")
	assert(not password or type(password) == "string", "Argument 'password' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")


	local url_path = "/v2/account/link/email"

	local query_params = {}
	
	local post_data = json.encode({
	email = email,
	password = password,
	vars = vars,
	})

	if callback then
		log("link_email() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_email() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_facebook
-- Add Facebook to the social profiles on the current user's account.
-- @param client Nakama client.
-- @param token (string) The OAuth token received from Facebook to access their profile API.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param sync_bool (boolean) Import Facebook friends for the user.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.link_facebook(client, vars, token, sync_bool,callback)
	assert(client, "You must provide a client")
	assert(not token or type(token) == "string", "Argument 'token' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")


	local url_path = "/v2/account/link/facebook"

	local query_params = {}
	query_params["sync"] = sync_bool
	
	local post_data = json.encode({
	token = token,
	vars = vars,
	})

	if callback then
		log("link_facebook() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_facebook() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_facebook_instant_game
-- Add Facebook Instant Game to the social profiles on the current user's account.
-- @param client Nakama client.
-- @param signedPlayerInfo (string) 
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.link_facebook_instant_game(client, signedPlayerInfo, vars,callback)
	assert(client, "You must provide a client")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")
	assert(not signedPlayerInfo or type(signedPlayerInfo) == "string", "Argument 'signedPlayerInfo' must be 'nil' or of type 'string'")


	local url_path = "/v2/account/link/facebookinstantgame"

	local query_params = {}
	
	local post_data = json.encode({
	vars = vars,
	signedPlayerInfo = signedPlayerInfo,
	})

	if callback then
		log("link_facebook_instant_game() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_facebook_instant_game() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_game_center
-- Add Apple's GameCenter to the social profiles on the current user's account.
-- @param client Nakama client.
-- @param timestampSeconds (string) Time since UNIX epoch when the signature was created.
-- @param salt (string) A random "NSString" used to compute the hash and keep it randomized.
-- @param signature (string) The verification signature data generated.
-- @param publicKeyUrl (string) The URL for the public encryption key.
-- @param vars (object) Extra information that will be bundled in the session token.
-- @param playerId (string) Player ID (generated by GameCenter).
-- @param bundleId (string) Bundle ID (generated by GameCenter).

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.link_game_center(client, playerId, bundleId, timestampSeconds, salt, signature, publicKeyUrl, vars,callback)
	assert(client, "You must provide a client")
	assert(not signature or type(signature) == "string", "Argument 'signature' must be 'nil' or of type 'string'")
	assert(not publicKeyUrl or type(publicKeyUrl) == "string", "Argument 'publicKeyUrl' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")
	assert(not playerId or type(playerId) == "string", "Argument 'playerId' must be 'nil' or of type 'string'")
	assert(not bundleId or type(bundleId) == "string", "Argument 'bundleId' must be 'nil' or of type 'string'")
	assert(not timestampSeconds or type(timestampSeconds) == "string", "Argument 'timestampSeconds' must be 'nil' or of type 'string'")
	assert(not salt or type(salt) == "string", "Argument 'salt' must be 'nil' or of type 'string'")


	local url_path = "/v2/account/link/gamecenter"

	local query_params = {}
	
	local post_data = json.encode({
	salt = salt,
	signature = signature,
	publicKeyUrl = publicKeyUrl,
	vars = vars,
	playerId = playerId,
	bundleId = bundleId,
	timestampSeconds = timestampSeconds,
	})

	if callback then
		log("link_game_center() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_game_center() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_google
-- Add Google to the social profiles on the current user's account.
-- @param client Nakama client.
-- @param token (string) The OAuth token received from Google to access their profile API.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.link_google(client, token, vars,callback)
	assert(client, "You must provide a client")
	assert(not token or type(token) == "string", "Argument 'token' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")


	local url_path = "/v2/account/link/google"

	local query_params = {}
	
	local post_data = json.encode({
	token = token,
	vars = vars,
	})

	if callback then
		log("link_google() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_google() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_steam
-- Add Steam to the social profiles on the current user's account.
-- @param client Nakama client.
-- @param account () The Facebook account details.
-- @param sync (boolean) Import Steam friends for the user.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.link_steam(client, account, sync,callback)
	assert(client, "You must provide a client")
	assert(not account or type(account) == "table", "Argument 'account' must be 'nil' or of type 'table'")
	assert(not sync or type(sync) == "boolean", "Argument 'sync' must be 'nil' or of type 'boolean'")


	local url_path = "/v2/account/link/steam"

	local query_params = {}
	
	local post_data = json.encode({
	account = account,
	sync = sync,
	})

	if callback then
		log("link_steam() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_steam() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- session_refresh
-- Refresh a user's session using a refresh token retrieved from a previous authentication request.
-- @param client Nakama client.
-- @param token (string) Refresh token.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.session_refresh(client, token, vars,callback)
	assert(client, "You must provide a client")
	assert(not token or type(token) == "string", "Argument 'token' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")


	local url_path = "/v2/account/session/refresh"

	local query_params = {}
	
	local post_data = json.encode({
	token = token,
	vars = vars,
	})

	if callback then
		log("session_refresh() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("session_refresh() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- unlink_apple
-- Remove the Apple ID from the social profiles on the current user's account.
-- @param client Nakama client.
-- @param token (string) The ID token received from Apple to validate.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.unlink_apple(client, token, vars,callback)
	assert(client, "You must provide a client")
	assert(not token or type(token) == "string", "Argument 'token' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")


	local url_path = "/v2/account/unlink/apple"

	local query_params = {}
	
	local post_data = json.encode({
	token = token,
	vars = vars,
	})

	if callback then
		log("unlink_apple() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_apple() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_custom
-- Remove the custom ID from the social profiles on the current user's account.
-- @param client Nakama client.
-- @param vars (object) Extra information that will be bundled in the session token.
-- @param id (string) A custom identifier.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.unlink_custom(client, id, vars,callback)
	assert(client, "You must provide a client")
	assert(not id or type(id) == "string", "Argument 'id' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")


	local url_path = "/v2/account/unlink/custom"

	local query_params = {}
	
	local post_data = json.encode({
	id = id,
	vars = vars,
	})

	if callback then
		log("unlink_custom() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_custom() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_device
-- Remove the device ID from the social profiles on the current user's account.
-- @param client Nakama client.
-- @param id (string) A device identifier. Should be obtained by a platform-specific device API.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.unlink_device(client, id, vars,callback)
	assert(client, "You must provide a client")
	assert(not id or type(id) == "string", "Argument 'id' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")


	local url_path = "/v2/account/unlink/device"

	local query_params = {}
	
	local post_data = json.encode({
	id = id,
	vars = vars,
	})

	if callback then
		log("unlink_device() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_device() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_email
-- Remove the email+password from the social profiles on the current user's account.
-- @param client Nakama client.
-- @param email (string) A valid RFC-5322 email address.
-- @param password (string) A password for the user account.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.unlink_email(client, email, password, vars,callback)
	assert(client, "You must provide a client")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")
	assert(not email or type(email) == "string", "Argument 'email' must be 'nil' or of type 'string'")
	assert(not password or type(password) == "string", "Argument 'password' must be 'nil' or of type 'string'")


	local url_path = "/v2/account/unlink/email"

	local query_params = {}
	
	local post_data = json.encode({
	vars = vars,
	email = email,
	password = password,
	})

	if callback then
		log("unlink_email() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_email() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_facebook
-- Remove Facebook from the social profiles on the current user's account.
-- @param client Nakama client.
-- @param token (string) The OAuth token received from Facebook to access their profile API.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.unlink_facebook(client, token, vars,callback)
	assert(client, "You must provide a client")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")
	assert(not token or type(token) == "string", "Argument 'token' must be 'nil' or of type 'string'")


	local url_path = "/v2/account/unlink/facebook"

	local query_params = {}
	
	local post_data = json.encode({
	token = token,
	vars = vars,
	})

	if callback then
		log("unlink_facebook() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_facebook() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_facebook_instant_game
-- Remove Facebook Instant Game profile from the social profiles on the current user's account.
-- @param client Nakama client.
-- @param signedPlayerInfo (string) 
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.unlink_facebook_instant_game(client, signedPlayerInfo, vars,callback)
	assert(client, "You must provide a client")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")
	assert(not signedPlayerInfo or type(signedPlayerInfo) == "string", "Argument 'signedPlayerInfo' must be 'nil' or of type 'string'")


	local url_path = "/v2/account/unlink/facebookinstantgame"

	local query_params = {}
	
	local post_data = json.encode({
	signedPlayerInfo = signedPlayerInfo,
	vars = vars,
	})

	if callback then
		log("unlink_facebook_instant_game() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_facebook_instant_game() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_game_center
-- Remove Apple's GameCenter from the social profiles on the current user's account.
-- @param client Nakama client.
-- @param salt (string) A random "NSString" used to compute the hash and keep it randomized.
-- @param signature (string) The verification signature data generated.
-- @param publicKeyUrl (string) The URL for the public encryption key.
-- @param vars (object) Extra information that will be bundled in the session token.
-- @param playerId (string) Player ID (generated by GameCenter).
-- @param bundleId (string) Bundle ID (generated by GameCenter).
-- @param timestampSeconds (string) Time since UNIX epoch when the signature was created.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.unlink_game_center(client, bundleId, timestampSeconds, salt, signature, publicKeyUrl, vars, playerId,callback)
	assert(client, "You must provide a client")
	assert(not bundleId or type(bundleId) == "string", "Argument 'bundleId' must be 'nil' or of type 'string'")
	assert(not timestampSeconds or type(timestampSeconds) == "string", "Argument 'timestampSeconds' must be 'nil' or of type 'string'")
	assert(not salt or type(salt) == "string", "Argument 'salt' must be 'nil' or of type 'string'")
	assert(not signature or type(signature) == "string", "Argument 'signature' must be 'nil' or of type 'string'")
	assert(not publicKeyUrl or type(publicKeyUrl) == "string", "Argument 'publicKeyUrl' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")
	assert(not playerId or type(playerId) == "string", "Argument 'playerId' must be 'nil' or of type 'string'")


	local url_path = "/v2/account/unlink/gamecenter"

	local query_params = {}
	
	local post_data = json.encode({
	playerId = playerId,
	bundleId = bundleId,
	timestampSeconds = timestampSeconds,
	salt = salt,
	signature = signature,
	publicKeyUrl = publicKeyUrl,
	vars = vars,
	})

	if callback then
		log("unlink_game_center() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_game_center() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_google
-- Remove Google from the social profiles on the current user's account.
-- @param client Nakama client.
-- @param token (string) The OAuth token received from Google to access their profile API.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.unlink_google(client, token, vars,callback)
	assert(client, "You must provide a client")
	assert(not token or type(token) == "string", "Argument 'token' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")


	local url_path = "/v2/account/unlink/google"

	local query_params = {}
	
	local post_data = json.encode({
	token = token,
	vars = vars,
	})

	if callback then
		log("unlink_google() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_google() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_steam
-- Remove Steam from the social profiles on the current user's account.
-- @param client Nakama client.
-- @param vars (object) Extra information that will be bundled in the session token.
-- @param token (string) The account token received from Steam to access their profile API.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.unlink_steam(client, vars, token,callback)
	assert(client, "You must provide a client")
	assert(not token or type(token) == "string", "Argument 'token' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")


	local url_path = "/v2/account/unlink/steam"

	local query_params = {}
	
	local post_data = json.encode({
	token = token,
	vars = vars,
	})

	if callback then
		log("unlink_steam() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_steam() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_channel_messages
-- List a channel's message history.
-- @param client Nakama client.
-- @param channel_id_str (string) The channel ID to list from.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param forward_bool (boolean) True if listing should be older messages to newer, false if reverse.
-- @param cursor_str (string) A pagination cursor, if any.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.list_channel_messages(client, channel_id_str, limit_int, forward_bool, cursor_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/channel/{channelId}"
	url_path = url_path:gsub("{channelId}", uri_encode(channel_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["forward"] = forward_bool
	query_params["cursor"] = cursor_str

	if callback then
		log("list_channel_messages() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_channel_message_list then
				result = api_channel_message_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_channel_messages() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_channel_message_list then
					result = api_channel_message_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- event
-- Submit an event for processing in the server's registered runtime custom events handler.
-- @param client Nakama client.
-- @param name (string) An event name, type, category, or identifier.
-- @param properties (object) Arbitrary event property values.
-- @param timestamp (string) The time when the event was triggered.
-- @param external (boolean) True if the event came directly from a client call, false otherwise.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.event(client, name, properties, timestamp, external,callback)
	assert(client, "You must provide a client")
	assert(not name or type(name) == "string", "Argument 'name' must be 'nil' or of type 'string'")
	assert(not properties or type(properties) == "table", "Argument 'properties' must be 'nil' or of type 'table'")
	assert(not timestamp or type(timestamp) == "string", "Argument 'timestamp' must be 'nil' or of type 'string'")
	assert(not external or type(external) == "boolean", "Argument 'external' must be 'nil' or of type 'boolean'")


	local url_path = "/v2/event"

	local query_params = {}
	
	local post_data = json.encode({
	timestamp = timestamp,
	external = external,
	name = name,
	properties = properties,
	})

	if callback then
		log("event() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("event() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- delete_friends
-- Delete one or more users by ID or username.
-- @param client Nakama client.
-- @param ids_arr (table) The account id of a user.
-- @param usernames_arr (table) The account username of a user.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.delete_friends(client, ids_arr, usernames_arr,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/friend"

	local query_params = {}
	query_params["ids"] = ids_arr
	query_params["usernames"] = usernames_arr

	if callback then
		log("delete_friends() with callback")
		client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
			callback(result)
		end)
	else
		log("delete_friends() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_friends
-- List all friends for the current user.
-- @param client Nakama client.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param state_int (number) The friend state to list.
-- @param cursor_str (string) An optional next page cursor.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.list_friends(client, limit_int, state_int, cursor_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/friend"

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["state"] = state_int
	query_params["cursor"] = cursor_str

	if callback then
		log("list_friends() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_friend_list then
				result = api_friend_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_friends() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_friend_list then
					result = api_friend_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- add_friends
-- Add friends by ID or username to a user's account.
-- @param client Nakama client.
-- @param ids_arr (table) The account id of a user.
-- @param usernames_arr (table) The account username of a user.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.add_friends(client, ids_arr, usernames_arr,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/friend"

	local query_params = {}
	query_params["ids"] = ids_arr
	query_params["usernames"] = usernames_arr

	if callback then
		log("add_friends() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("add_friends() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- block_friends
-- Block one or more users by ID or username.
-- @param client Nakama client.
-- @param ids_arr (table) The account id of a user.
-- @param usernames_arr (table) The account username of a user.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.block_friends(client, ids_arr, usernames_arr,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/friend/block"

	local query_params = {}
	query_params["ids"] = ids_arr
	query_params["usernames"] = usernames_arr

	if callback then
		log("block_friends() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("block_friends() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- import_facebook_friends
-- Import Facebook friends and add them to a user's account.
-- @param client Nakama client.
-- @param token (string) The OAuth token received from Facebook to access their profile API.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param reset_bool (boolean) Reset the current user's friends list.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.import_facebook_friends(client, token, vars, reset_bool,callback)
	assert(client, "You must provide a client")
	assert(not token or type(token) == "string", "Argument 'token' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")


	local url_path = "/v2/friend/facebook"

	local query_params = {}
	query_params["reset"] = reset_bool
	
	local post_data = json.encode({
	vars = vars,
	token = token,
	})

	if callback then
		log("import_facebook_friends() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("import_facebook_friends() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- import_steam_friends
-- Import Steam friends and add them to a user's account.
-- @param client Nakama client.
-- @param token (string) The account token received from Steam to access their profile API.
-- @param vars (object) Extra information that will be bundled in the session token.

-- @param reset_bool (boolean) Reset the current user's friends list.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.import_steam_friends(client, token, vars, reset_bool,callback)
	assert(client, "You must provide a client")
	assert(not token or type(token) == "string", "Argument 'token' must be 'nil' or of type 'string'")
	assert(not vars or type(vars) == "table", "Argument 'vars' must be 'nil' or of type 'table'")


	local url_path = "/v2/friend/steam"

	local query_params = {}
	query_params["reset"] = reset_bool
	
	local post_data = json.encode({
	token = token,
	vars = vars,
	})

	if callback then
		log("import_steam_friends() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("import_steam_friends() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_groups
-- List groups based on given filters.
-- @param client Nakama client.
-- @param name_str (string) List groups that contain this value in their names.
-- @param cursor_str (string) Optional pagination cursor.
-- @param limit_int (number) Max number of groups to return. Between 1 and 100.
-- @param lang_tag_str (string) Language tag filter.
-- @param members_int (number) Number of group members.
-- @param open_bool (boolean) Optional Open/Closed filter.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.list_groups(client, name_str, cursor_str, limit_int, lang_tag_str, members_int, open_bool,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group"

	local query_params = {}
	query_params["name"] = name_str
	query_params["cursor"] = cursor_str
	query_params["limit"] = limit_int
	query_params["langTag"] = lang_tag_str
	query_params["members"] = members_int
	query_params["open"] = open_bool

	if callback then
		log("list_groups() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_group_list then
				result = api_group_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_groups() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_group_list then
					result = api_group_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- create_group
-- Create a new group with the current user as the owner.
-- @param client Nakama client.
-- @param avatarUrl (string) A URL for an avatar image.
-- @param open (boolean) Mark a group as open or not where only admins can accept members.
-- @param maxCount (integer) Maximum number of group members.
-- @param name (string) A unique name for the group.
-- @param description (string) A description for the group.
-- @param langTag (string) The language expected to be a tag which follows the BCP-47 spec.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.create_group(client, name, description, langTag, avatarUrl, open, maxCount,callback)
	assert(client, "You must provide a client")
	assert(not name or type(name) == "string", "Argument 'name' must be 'nil' or of type 'string'")
	assert(not description or type(description) == "string", "Argument 'description' must be 'nil' or of type 'string'")
	assert(not langTag or type(langTag) == "string", "Argument 'langTag' must be 'nil' or of type 'string'")
	assert(not avatarUrl or type(avatarUrl) == "string", "Argument 'avatarUrl' must be 'nil' or of type 'string'")
	assert(not open or type(open) == "boolean", "Argument 'open' must be 'nil' or of type 'boolean'")
	assert(not maxCount or type(maxCount) == "number", "Argument 'maxCount' must be 'nil' or of type 'number'")


	local url_path = "/v2/group"

	local query_params = {}
	
	local post_data = json.encode({
	name = name,
	description = description,
	langTag = langTag,
	avatarUrl = avatarUrl,
	open = open,
	maxCount = maxCount,
	})

	if callback then
		log("create_group() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_group then
				result = api_group.create(result)
			end
			callback(result)
		end)
	else
		log("create_group() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_group then
					result = api_group.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- delete_group
-- Delete a group by ID.
-- @param client Nakama client.
-- @param group_id_str (string) The id of a group.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.delete_group(client, group_id_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}

	if callback then
		log("delete_group() with callback")
		client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
			callback(result)
		end)
	else
		log("delete_group() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- update_group
-- Update fields in a given group.
-- @param client Nakama client.
-- @param group_id_str (string) The ID of the group to update.
-- @param avatarUrl (string) Avatar URL.
-- @param open (boolean) Open is true if anyone should be allowed to join, or false if joins must be approved by a group admin.
-- @param groupId (string) The ID of the group to update.
-- @param name (string) Name.
-- @param description (string) Description string.
-- @param langTag (string) Lang tag.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.update_group(client, group_id_str, name, description, langTag, avatarUrl, open, groupId,callback)
	assert(client, "You must provide a client")
	assert(not avatarUrl or type(avatarUrl) == "string", "Argument 'avatarUrl' must be 'nil' or of type 'string'")
	assert(not open or type(open) == "boolean", "Argument 'open' must be 'nil' or of type 'boolean'")
	assert(not groupId or type(groupId) == "string", "Argument 'groupId' must be 'nil' or of type 'string'")
	assert(not name or type(name) == "string", "Argument 'name' must be 'nil' or of type 'string'")
	assert(not description or type(description) == "string", "Argument 'description' must be 'nil' or of type 'string'")
	assert(not langTag or type(langTag) == "string", "Argument 'langTag' must be 'nil' or of type 'string'")


	local url_path = "/v2/group/{groupId}"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	
	local post_data = json.encode({
	groupId = groupId,
	name = name,
	description = description,
	langTag = langTag,
	avatarUrl = avatarUrl,
	open = open,
	})

	if callback then
		log("update_group() with callback")
		client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
			callback(result)
		end)
	else
		log("update_group() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- add_group_users
-- Add users to a group.
-- @param client Nakama client.
-- @param group_id_str (string) The group to add users to.
-- @param user_ids_arr (table) The users to add.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.add_group_users(client, group_id_str, user_ids_arr,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/add"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	if callback then
		log("add_group_users() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("add_group_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- ban_group_users
-- Ban a set of users from a group.
-- @param client Nakama client.
-- @param group_id_str (string) The group to ban users from.
-- @param user_ids_arr (table) The users to ban.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.ban_group_users(client, group_id_str, user_ids_arr,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/ban"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	if callback then
		log("ban_group_users() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("ban_group_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- demote_group_users
-- Demote a set of users in a group to the next role down.
-- @param client Nakama client.
-- @param group_id_str (string) The group ID to demote in.
-- @param user_ids_arr (table) The users to demote.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.demote_group_users(client, group_id_str, user_ids_arr,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/demote"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	if callback then
		log("demote_group_users() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("demote_group_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- join_group
-- Immediately join an open group, or request to join a closed one.
-- @param client Nakama client.
-- @param group_id_str (string) The group ID to join. The group must already exist.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.join_group(client, group_id_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/join"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}

	if callback then
		log("join_group() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("join_group() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- kick_group_users
-- Kick a set of users from a group.
-- @param client Nakama client.
-- @param group_id_str (string) The group ID to kick from.
-- @param user_ids_arr (table) The users to kick.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.kick_group_users(client, group_id_str, user_ids_arr,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/kick"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	if callback then
		log("kick_group_users() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("kick_group_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- leave_group
-- Leave a group the user is a member of.
-- @param client Nakama client.
-- @param group_id_str (string) The group ID to leave.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.leave_group(client, group_id_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/leave"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}

	if callback then
		log("leave_group() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("leave_group() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- promote_group_users
-- Promote a set of users in a group to the next role up.
-- @param client Nakama client.
-- @param group_id_str (string) The group ID to promote in.
-- @param user_ids_arr (table) The users to promote.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.promote_group_users(client, group_id_str, user_ids_arr,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/promote"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	if callback then
		log("promote_group_users() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("promote_group_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_group_users
-- List all users that are part of a group.
-- @param client Nakama client.
-- @param group_id_str (string) The group ID to list from.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param state_int (number) The group user state to list.
-- @param cursor_str (string) An optional next page cursor.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.list_group_users(client, group_id_str, limit_int, state_int, cursor_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/user"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["state"] = state_int
	query_params["cursor"] = cursor_str

	if callback then
		log("list_group_users() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_group_user_list then
				result = api_group_user_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_group_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_group_user_list then
					result = api_group_user_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- validate_purchase_apple
-- Validate Apple IAP Receipt
-- @param client Nakama client.
-- @param receipt (string) Base64 encoded Apple receipt data payload.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.validate_purchase_apple(client, receipt,callback)
	assert(client, "You must provide a client")
	assert(not receipt or type(receipt) == "string", "Argument 'receipt' must be 'nil' or of type 'string'")


	local url_path = "/v2/iap/purchase/apple"

	local query_params = {}
	
	local post_data = json.encode({
	receipt = receipt,
	})

	if callback then
		log("validate_purchase_apple() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_validate_purchase_response then
				result = api_validate_purchase_response.create(result)
			end
			callback(result)
		end)
	else
		log("validate_purchase_apple() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_validate_purchase_response then
					result = api_validate_purchase_response.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- validate_purchase_google
-- Validate Google IAP Receipt
-- @param client Nakama client.
-- @param purchase (string) JSON encoded Google purchase payload.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.validate_purchase_google(client, purchase,callback)
	assert(client, "You must provide a client")
	assert(not purchase or type(purchase) == "string", "Argument 'purchase' must be 'nil' or of type 'string'")


	local url_path = "/v2/iap/purchase/google"

	local query_params = {}
	
	local post_data = json.encode({
	purchase = purchase,
	})

	if callback then
		log("validate_purchase_google() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_validate_purchase_response then
				result = api_validate_purchase_response.create(result)
			end
			callback(result)
		end)
	else
		log("validate_purchase_google() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_validate_purchase_response then
					result = api_validate_purchase_response.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- validate_purchase_huawei
-- Validate Huawei IAP Receipt
-- @param client Nakama client.
-- @param purchase (string) JSON encoded Huawei InAppPurchaseData.
-- @param signature (string) InAppPurchaseData signature.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.validate_purchase_huawei(client, purchase, signature,callback)
	assert(client, "You must provide a client")
	assert(not purchase or type(purchase) == "string", "Argument 'purchase' must be 'nil' or of type 'string'")
	assert(not signature or type(signature) == "string", "Argument 'signature' must be 'nil' or of type 'string'")


	local url_path = "/v2/iap/purchase/huawei"

	local query_params = {}
	
	local post_data = json.encode({
	purchase = purchase,
	signature = signature,
	})

	if callback then
		log("validate_purchase_huawei() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_validate_purchase_response then
				result = api_validate_purchase_response.create(result)
			end
			callback(result)
		end)
	else
		log("validate_purchase_huawei() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_validate_purchase_response then
					result = api_validate_purchase_response.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- delete_leaderboard_record
-- Delete a leaderboard record.
-- @param client Nakama client.
-- @param leaderboard_id_str (string) The leaderboard ID to delete from.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.delete_leaderboard_record(client, leaderboard_id_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/leaderboard/{leaderboardId}"
	url_path = url_path:gsub("{leaderboardId}", uri_encode(leaderboard_id_str))

	local query_params = {}

	if callback then
		log("delete_leaderboard_record() with callback")
		client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
			callback(result)
		end)
	else
		log("delete_leaderboard_record() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_leaderboard_records
-- List leaderboard records.
-- @param client Nakama client.
-- @param leaderboard_id_str (string) The ID of the leaderboard to list for.
-- @param owner_ids_arr (table) One or more owners to retrieve records for.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param cursor_str (string) A next or previous page cursor.
-- @param expiry_str (string) Expiry in seconds (since epoch) to begin fetching records from. Optional. 0 means from current time.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.list_leaderboard_records(client, leaderboard_id_str, owner_ids_arr, limit_int, cursor_str, expiry_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/leaderboard/{leaderboardId}"
	url_path = url_path:gsub("{leaderboardId}", uri_encode(leaderboard_id_str))

	local query_params = {}
	query_params["ownerIds"] = owner_ids_arr
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str
	query_params["expiry"] = expiry_str

	if callback then
		log("list_leaderboard_records() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_leaderboard_record_list then
				result = api_leaderboard_record_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_leaderboard_records() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_leaderboard_record_list then
					result = api_leaderboard_record_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- write_leaderboard_record
-- Write a record to a leaderboard.
-- @param client Nakama client.
-- @param leaderboard_id_str (string) The ID of the leaderboard to write to.
-- @param metadata (string) Optional record metadata.
-- @param operator () Operator override.
-- @param score (string) The score value to submit.
-- @param subscore (string) An optional secondary value.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.write_leaderboard_record(client, leaderboard_id_str, score, subscore, metadata, operator,callback)
	assert(client, "You must provide a client")
	assert(not operator or type(operator) == "string", "Argument 'operator' must be 'nil' or of type 'string'")
	assert(not score or type(score) == "string", "Argument 'score' must be 'nil' or of type 'string'")
	assert(not subscore or type(subscore) == "string", "Argument 'subscore' must be 'nil' or of type 'string'")
	assert(not metadata or type(metadata) == "string", "Argument 'metadata' must be 'nil' or of type 'string'")


	local url_path = "/v2/leaderboard/{leaderboardId}"
	url_path = url_path:gsub("{leaderboardId}", uri_encode(leaderboard_id_str))

	local query_params = {}
	
	local post_data = json.encode({
	subscore = subscore,
	metadata = metadata,
	operator = operator,
	score = score,
	})

	if callback then
		log("write_leaderboard_record() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_leaderboard_record then
				result = api_leaderboard_record.create(result)
			end
			callback(result)
		end)
	else
		log("write_leaderboard_record() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_leaderboard_record then
					result = api_leaderboard_record.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- list_leaderboard_records_around_owner
-- List leaderboard records that belong to a user.
-- @param client Nakama client.
-- @param leaderboard_id_str (string) The ID of the tournament to list for.
-- @param owner_id_str (string) The owner to retrieve records around.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param expiry_str (string) Expiry in seconds (since epoch) to begin fetching records from.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.list_leaderboard_records_around_owner(client, leaderboard_id_str, owner_id_str, limit_int, expiry_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/leaderboard/{leaderboardId}/owner/{ownerId}"
	url_path = url_path:gsub("{leaderboardId}", uri_encode(leaderboard_id_str))
	url_path = url_path:gsub("{ownerId}", uri_encode(owner_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["expiry"] = expiry_str

	if callback then
		log("list_leaderboard_records_around_owner() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_leaderboard_record_list then
				result = api_leaderboard_record_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_leaderboard_records_around_owner() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_leaderboard_record_list then
					result = api_leaderboard_record_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- list_matches
-- Fetch list of running matches.
-- @param client Nakama client.
-- @param limit_int (number) Limit the number of returned matches.
-- @param authoritative_bool (boolean) Authoritative or relayed matches.
-- @param label_str (string) Label filter.
-- @param min_size_int (number) Minimum user count.
-- @param max_size_int (number) Maximum user count.
-- @param query_str (string) Arbitrary label query.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.list_matches(client, limit_int, authoritative_bool, label_str, min_size_int, max_size_int, query_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/match"

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["authoritative"] = authoritative_bool
	query_params["label"] = label_str
	query_params["minSize"] = min_size_int
	query_params["maxSize"] = max_size_int
	query_params["query"] = query_str

	if callback then
		log("list_matches() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_match_list then
				result = api_match_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_matches() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_match_list then
					result = api_match_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- delete_notifications
-- Delete one or more notifications for the current user.
-- @param client Nakama client.
-- @param ids_arr (table) The id of notifications.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.delete_notifications(client, ids_arr,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/notification"

	local query_params = {}
	query_params["ids"] = ids_arr

	if callback then
		log("delete_notifications() with callback")
		client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
			callback(result)
		end)
	else
		log("delete_notifications() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_notifications
-- Fetch list of notifications.
-- @param client Nakama client.
-- @param limit_int (number) The number of notifications to get. Between 1 and 100.
-- @param cacheable_cursor_str (string) A cursor to page through notifications. May be cached by clients to get from point in time forwards.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.list_notifications(client, limit_int, cacheable_cursor_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/notification"

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["cacheableCursor"] = cacheable_cursor_str

	if callback then
		log("list_notifications() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_notification_list then
				result = api_notification_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_notifications() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_notification_list then
					result = api_notification_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- rpc_func2
-- Execute a Lua function on the server.
-- @param client Nakama client.
-- @param id_str (string) The identifier of the function.
-- @param payload_str (string) The payload of the function which must be a JSON object.
-- @param http_key_str (string) The authentication key used when executed as a non-client HTTP request.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.rpc_func2(client, id_str, payload_str, http_key_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/rpc/{id}"
	url_path = url_path:gsub("{id}", uri_encode(id_str))

	local query_params = {}
	query_params["payload"] = payload_str
	query_params["httpKey"] = http_key_str

	if callback then
		log("rpc_func2() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_rpc then
				result = api_rpc.create(result)
			end
			callback(result)
		end)
	else
		log("rpc_func2() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_rpc then
					result = api_rpc.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- rpc_func
-- Execute a Lua function on the server.
-- @param client Nakama client.
-- @param id_str (string) The identifier of the function.

-- @param http_key_str (string) The authentication key used when executed as a non-client HTTP request.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.rpc_func(client, id_str, http_key_str,callback)
	assert(client, "You must provide a client")


	local url_path = "/v2/rpc/{id}"
	url_path = url_path:gsub("{id}", uri_encode(id_str))

	local query_params = {}
	query_params["httpKey"] = http_key_str
	
	local post_data = json.encode({
	})

	if callback then
		log("rpc_func() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_rpc then
				result = api_rpc.create(result)
			end
			callback(result)
		end)
	else
		log("rpc_func() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_rpc then
					result = api_rpc.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- session_logout
-- Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user.
-- @param client Nakama client.
-- @param token (string) Session token to log out.
-- @param refreshToken (string) Refresh token to invalidate.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.session_logout(client, token, refreshToken,callback)
	assert(client, "You must provide a client")
	assert(not token or type(token) == "string", "Argument 'token' must be 'nil' or of type 'string'")
	assert(not refreshToken or type(refreshToken) == "string", "Argument 'refreshToken' must be 'nil' or of type 'string'")


	local url_path = "/v2/session/logout"

	local query_params = {}
	
	local post_data = json.encode({
	refreshToken = refreshToken,
	token = token,
	})

	if callback then
		log("session_logout() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("session_logout() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- read_storage_objects
-- Get storage objects.
-- @param client Nakama client.
-- @param objectIds (array) Batch of storage objects.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.read_storage_objects(client, objectIds,callback)
	assert(client, "You must provide a client")
	assert(not objectIds or type(objectIds) == "table", "Argument 'objectIds' must be 'nil' or of type 'table'")


	local url_path = "/v2/storage"

	local query_params = {}
	
	local post_data = json.encode({
	objectIds = objectIds,
	})

	if callback then
		log("read_storage_objects() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_storage_objects then
				result = api_storage_objects.create(result)
			end
			callback(result)
		end)
	else
		log("read_storage_objects() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_storage_objects then
					result = api_storage_objects.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- write_storage_objects
-- Write objects into the storage engine.
-- @param client Nakama client.
-- @param objects (array) The objects to store on the server.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.write_storage_objects(client, objects,callback)
	assert(client, "You must provide a client")
	assert(not objects or type(objects) == "table", "Argument 'objects' must be 'nil' or of type 'table'")


	local url_path = "/v2/storage"

	local query_params = {}
	
	local post_data = json.encode({
	objects = objects,
	})

	if callback then
		log("write_storage_objects() with callback")
		client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
			if not result.error and api_storage_object_acks then
				result = api_storage_object_acks.create(result)
			end
			callback(result)
		end)
	else
		log("write_storage_objects() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
				if not result.error and api_storage_object_acks then
					result = api_storage_object_acks.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- delete_storage_objects
-- Delete one or more objects by ID or username.
-- @param client Nakama client.
-- @param objectIds (array) Batch of storage objects.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.delete_storage_objects(client, objectIds,callback)
	assert(client, "You must provide a client")
	assert(not objectIds or type(objectIds) == "table", "Argument 'objectIds' must be 'nil' or of type 'table'")


	local url_path = "/v2/storage/delete"

	local query_params = {}
	
	local post_data = json.encode({
	objectIds = objectIds,
	})

	if callback then
		log("delete_storage_objects() with callback")
		client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
			callback(result)
		end)
	else
		log("delete_storage_objects() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_storage_objects
-- List publicly readable storage objects in a given collection.
-- @param client Nakama client.
-- @param collection_str (string) The collection which stores the object.
-- @param user_id_str (string) ID of the user.
-- @param limit_int (number) The number of storage objects to list. Between 1 and 100.
-- @param cursor_str (string) The cursor to page through results from.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.list_storage_objects(client, collection_str, user_id_str, limit_int, cursor_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/storage/{collection}"
	url_path = url_path:gsub("{collection}", uri_encode(collection_str))

	local query_params = {}
	query_params["userId"] = user_id_str
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str

	if callback then
		log("list_storage_objects() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_storage_object_list then
				result = api_storage_object_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_storage_objects() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_storage_object_list then
					result = api_storage_object_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- list_storage_objects2
-- List publicly readable storage objects in a given collection.
-- @param client Nakama client.
-- @param collection_str (string) The collection which stores the object.
-- @param user_id_str (string) ID of the user.
-- @param limit_int (number) The number of storage objects to list. Between 1 and 100.
-- @param cursor_str (string) The cursor to page through results from.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.list_storage_objects2(client, collection_str, user_id_str, limit_int, cursor_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/storage/{collection}/{userId}"
	url_path = url_path:gsub("{collection}", uri_encode(collection_str))
	url_path = url_path:gsub("{userId}", uri_encode(user_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str

	if callback then
		log("list_storage_objects2() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_storage_object_list then
				result = api_storage_object_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_storage_objects2() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_storage_object_list then
					result = api_storage_object_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- list_tournaments
-- List current or upcoming tournaments.
-- @param client Nakama client.
-- @param category_start_int (number) The start of the categories to include. Defaults to 0.
-- @param category_end_int (number) The end of the categories to include. Defaults to 128.
-- @param start_time_int (number) The start time for tournaments. Defaults to epoch.
-- @param end_time_int (number) The end time for tournaments. Defaults to +1 year from current Unix time.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param cursor_str (string) A next page cursor for listings (optional).
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.list_tournaments(client, category_start_int, category_end_int, start_time_int, end_time_int, limit_int, cursor_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/tournament"

	local query_params = {}
	query_params["categoryStart"] = category_start_int
	query_params["categoryEnd"] = category_end_int
	query_params["startTime"] = start_time_int
	query_params["endTime"] = end_time_int
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str

	if callback then
		log("list_tournaments() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_tournament_list then
				result = api_tournament_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_tournaments() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_tournament_list then
					result = api_tournament_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- list_tournament_records
-- List tournament records.
-- @param client Nakama client.
-- @param tournament_id_str (string) The ID of the tournament to list for.
-- @param owner_ids_arr (table) One or more owners to retrieve records for.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param cursor_str (string) A next or previous page cursor.
-- @param expiry_str (string) Expiry in seconds (since epoch) to begin fetching records from.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.list_tournament_records(client, tournament_id_str, owner_ids_arr, limit_int, cursor_str, expiry_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/tournament/{tournamentId}"
	url_path = url_path:gsub("{tournamentId}", uri_encode(tournament_id_str))

	local query_params = {}
	query_params["ownerIds"] = owner_ids_arr
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str
	query_params["expiry"] = expiry_str

	if callback then
		log("list_tournament_records() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_tournament_record_list then
				result = api_tournament_record_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_tournament_records() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_tournament_record_list then
					result = api_tournament_record_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- write_tournament_record2
-- Write a record to a tournament.
-- @param client Nakama client.
-- @param tournament_id_str (string) The tournament ID to write the record for.
-- @param score (string) The score value to submit.
-- @param subscore (string) An optional secondary value.
-- @param metadata (string) A JSON object of additional properties (optional).
-- @param operator () Operator override.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.write_tournament_record2(client, tournament_id_str, score, subscore, metadata, operator,callback)
	assert(client, "You must provide a client")
	assert(not metadata or type(metadata) == "string", "Argument 'metadata' must be 'nil' or of type 'string'")
	assert(not operator or type(operator) == "string", "Argument 'operator' must be 'nil' or of type 'string'")
	assert(not score or type(score) == "string", "Argument 'score' must be 'nil' or of type 'string'")
	assert(not subscore or type(subscore) == "string", "Argument 'subscore' must be 'nil' or of type 'string'")


	local url_path = "/v2/tournament/{tournamentId}"
	url_path = url_path:gsub("{tournamentId}", uri_encode(tournament_id_str))

	local query_params = {}
	
	local post_data = json.encode({
	score = score,
	subscore = subscore,
	metadata = metadata,
	operator = operator,
	})

	if callback then
		log("write_tournament_record2() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_leaderboard_record then
				result = api_leaderboard_record.create(result)
			end
			callback(result)
		end)
	else
		log("write_tournament_record2() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_leaderboard_record then
					result = api_leaderboard_record.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- write_tournament_record
-- Write a record to a tournament.
-- @param client Nakama client.
-- @param tournament_id_str (string) The tournament ID to write the record for.
-- @param score (string) The score value to submit.
-- @param subscore (string) An optional secondary value.
-- @param metadata (string) A JSON object of additional properties (optional).
-- @param operator () Operator override.

-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.write_tournament_record(client, tournament_id_str, score, subscore, metadata, operator,callback)
	assert(client, "You must provide a client")
	assert(not operator or type(operator) == "string", "Argument 'operator' must be 'nil' or of type 'string'")
	assert(not score or type(score) == "string", "Argument 'score' must be 'nil' or of type 'string'")
	assert(not subscore or type(subscore) == "string", "Argument 'subscore' must be 'nil' or of type 'string'")
	assert(not metadata or type(metadata) == "string", "Argument 'metadata' must be 'nil' or of type 'string'")


	local url_path = "/v2/tournament/{tournamentId}"
	url_path = url_path:gsub("{tournamentId}", uri_encode(tournament_id_str))

	local query_params = {}
	
	local post_data = json.encode({
	score = score,
	subscore = subscore,
	metadata = metadata,
	operator = operator,
	})

	if callback then
		log("write_tournament_record() with callback")
		client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
			if not result.error and api_leaderboard_record then
				result = api_leaderboard_record.create(result)
			end
			callback(result)
		end)
	else
		log("write_tournament_record() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
				if not result.error and api_leaderboard_record then
					result = api_leaderboard_record.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- join_tournament
-- Attempt to join an open and running tournament.
-- @param client Nakama client.
-- @param tournament_id_str (string) The ID of the tournament to join. The tournament must already exist.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.join_tournament(client, tournament_id_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/tournament/{tournamentId}/join"
	url_path = url_path:gsub("{tournamentId}", uri_encode(tournament_id_str))

	local query_params = {}

	if callback then
		log("join_tournament() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("join_tournament() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_tournament_records_around_owner
-- List tournament records for a given owner.
-- @param client Nakama client.
-- @param tournament_id_str (string) The ID of the tournament to list for.
-- @param owner_id_str (string) The owner to retrieve records around.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param expiry_str (string) Expiry in seconds (since epoch) to begin fetching records from.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.list_tournament_records_around_owner(client, tournament_id_str, owner_id_str, limit_int, expiry_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/tournament/{tournamentId}/owner/{ownerId}"
	url_path = url_path:gsub("{tournamentId}", uri_encode(tournament_id_str))
	url_path = url_path:gsub("{ownerId}", uri_encode(owner_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["expiry"] = expiry_str

	if callback then
		log("list_tournament_records_around_owner() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_tournament_record_list then
				result = api_tournament_record_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_tournament_records_around_owner() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_tournament_record_list then
					result = api_tournament_record_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- get_users
-- Fetch zero or more users by ID and/or username.
-- @param client Nakama client.
-- @param ids_arr (table) The account id of a user.
-- @param usernames_arr (table) The account username of a user.
-- @param facebook_ids_arr (table) The Facebook ID of a user.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.get_users(client, ids_arr, usernames_arr, facebook_ids_arr,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/user"

	local query_params = {}
	query_params["ids"] = ids_arr
	query_params["usernames"] = usernames_arr
	query_params["facebookIds"] = facebook_ids_arr

	if callback then
		log("get_users() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_users then
				result = api_users.create(result)
			end
			callback(result)
		end)
	else
		log("get_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_users then
					result = api_users.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- list_user_groups
-- List groups the current user belongs to.
-- @param client Nakama client.
-- @param user_id_str (string) ID of the user.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param state_int (number) The user group state to list.
-- @param cursor_str (string) An optional next page cursor.
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.list_user_groups(client, user_id_str, limit_int, state_int, cursor_str,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/user/{userId}/group"
	url_path = url_path:gsub("{userId}", uri_encode(user_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["state"] = state_int
	query_params["cursor"] = cursor_str

	if callback then
		log("list_user_groups() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_user_group_list then
				result = api_user_group_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_user_groups() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_user_group_list then
					result = api_user_group_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

return M
