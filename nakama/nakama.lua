-- Code generated by codegen/main.go. DO NOT EDIT.

local json = require "nakama.util.json"
local b64 = require "nakama.util.b64"
local log = require "nakama.util.log"
local async = require "nakama.util.async"
local api_session = require "nakama.session"

local uri = require "nakama.util.uri"
local uri_encode = uri.encode

local M = {}



--------------------------------------------------------------------------------
--- Create a match_create socket message
function M.create_match_create_message()
	local message = {
		match_create = {}
	}
	return message
end

--------------------------------------------------------------------------------
--- Create a match_join socket message
function M.create_match_join_message(match_id, token, metadata)
	assert(not match_id or (match_id and type(match_id) == "string"), "Argument 'match_id' must be 'nil' or of type 'string'")
	assert(not token or (token and type(token) == "string"), "Argument 'token' must be 'nil' or of type 'string'")
	local message = {
		match_join = {
			match_id = match_id,
			token = token,
			metadata = metadata,
		}
	}
	return message
end

--------------------------------------------------------------------------------
--- Create a match_leave socket message
function M.create_match_leave_message(match_id)
	assert(match_id and type(match_id) == "string", "Argument 'match_id' must be of type 'string'")
	local message = {
		match_leave = {
			match_id = match_id,
		}
	}
	return message
end

--------------------------------------------------------------------------------
--- Create a channel_message_send socket message
function M.create_channel_message_send_message(channel_id, content)
	assert(channel_id and type(channel_id) == "string", "Argument 'channel_id' must be of type 'string'")
	assert(content and type(content) == "string", "Argument 'content' must be of type 'string'")
	local message = {
		channel_message_send = {
			channel_id = channel_id,
			content = content,
		}
	}
	return message
end

--------------------------------------------------------------------------------
--- Create a channel_message_update socket message
function M.create_channel_message_update_message(channel_id, message_id, content)
	assert(channel_id and type(channel_id) == "string", "Argument 'channel_id' must be of type 'string'")
	assert(message_id and type(message_id) == "string", "Argument 'message_id' must be of type 'string'")
	assert(content and type(content) == "string", "Argument 'content' must be of type 'string'")
	local message = {
		channel_message_update = {
			channel_id = channel_id,
			message_id = message_id,
			content = content,
		}
	}
	return message
end

--------------------------------------------------------------------------------
--- Create a channel_message_remove socket message
function M.create_channel_message_remove_message(channel_id, message_id)
	assert(channel_id and type(channel_id) == "string", "Argument 'channel_id' must be of type 'string'")
	assert(message_id and type(message_id) == "string", "Argument 'message_id' must be of type 'string'")
	local message = {
		channel_message_remove = {
			channel_id = channel_id,
			message_id = message_id,
		}
	}
	return message
end

--------------------------------------------------------------------------------
--- Create a channel_join socket message
function M.create_channel_join_message(target, type, persistence, hidden)
	assert(target and type(target) == "string", "Argument 'target' must be of type 'string'")
	assert(type and type(type) == "number", "Argument 'type' must be of type 'number'")
	assert(persistence and type(persistence) == "boolean", "Argument 'persistence' must be of type 'boolean'")
	assert(hidden and type(hidden) == "boolean", "Argument 'hidden' must be of type 'boolean'")
	local message = {
		channel_join = {
			target = target,
			type = type,
			persistence = persistence,
			hidden = hidden,
		}
	}
	return message
end

--------------------------------------------------------------------------------
--- Create a channel_leave socket message
function M.create_channel_leave_message(channel_id)
	assert(channel_id and type(channel_id) == "string", "Argument 'channel_id' must be of type 'string'")
	local message = {
		channel_leave = {
			channel_id = channel_id,
		}
	}
	return message
end

--------------------------------------------------------------------------------
--- Create a matchmaker_add socket message
function M.create_matchmaker_add_message(query, min_count, max_count, string_properties, numeric_properties)
	assert(query and type(query) == "string", "Argument 'query' must be of type 'string'")
	assert(min_count and type(min_count) == "number", "Argument 'min_count' must be of type 'number'")
	assert(max_count and type(max_count) == "number", "Argument 'max_count' must be of type 'number'")
	local message = {
		matchmaker_add = {
			query = query,
			min_count = tostring(min_count),
			max_count = tostring(max_count),
			string_properties = string_properties,
			numeric_properties = numeric_properties,
		}
	}
	return message
end

--------------------------------------------------------------------------------
--- Create a matchmaker_remove socket message
function M.create_matchmaker_remove_message(ticket)
	assert(ticket and type(ticket) == "string", "Argument 'ticket' must be of type 'string'")
	local message = {
		matchmaker_remove = {
			ticket = ticket
		}
	}
	return message
end

--------------------------------------------------------------------------------
--- Create a match_data_send socket message
function M.create_match_data_message(match_id, op_code, data)
	assert(match_id and type(match_id) == "string", "Argument 'match_id' must be of type 'string'")
	assert(op_code and type(op_code) == "number", "Argument 'op_code' must be of type 'number'")
	assert(data and type(data) == "string", "Argument 'data' must be of type 'string'")
	local message = {
		match_data_send = {
			match_id = match_id,
			op_code = op_code,
			data = b64.encode(data),
		}
	}
	return message
end

--------------------------------------------------------------------------------
--- Create a status_follow socket message
function M.create_status_follow_message(user_id)
	assert(user_ids and type(user_ids) == "table", "Argument 'user_ids' must be of type 'table'")
	local message = {
		status_follow = {
			user_ids = user_ids
		}
	}
	return message
end

--------------------------------------------------------------------------------
--- Create a status_unfollow socket message
function M.create_status_unfollow_message(user_id)
	assert(user_ids and type(user_ids) == "table", "Argument 'user_ids' must be of type 'table'")
	local message = {
		status_unfollow = {
			user_ids = user_ids
		}
	}
	return message
end

--------------------------------------------------------------------------------
--- Create a status_update socket message
function M.create_status_update_message(status)
	assert(status and type(status) == "string", "Argument 'status' must be of type 'string'")
	local message = {
		status_update = {
			status = status
		}
	}
	return message
end

--------------------------------------------------------------------------------
--- create_group_user_list_group_user
-- A single user-role pair.
function M.create_group_user_list_group_user(
	state_int -- 'number' () Their relationship to the group.
	,user_api_user -- 'table' (api_user) User.
	)
	assert(not state_int or type(state_int) == "number", "Argument 'state_int' must be 'nil' or of type 'number'")
	assert(not user_api_user or type(user_api_user) == "table", "Argument 'user_api_user' must be 'nil' or of type 'table'")
	return {
		state = state_int,
		user = user_api_user,
	}
end

--------------------------------------------------------------------------------
--- create_user_group_list_user_group
-- A single group-role pair.
function M.create_user_group_list_user_group(
	group_api_group -- 'table' (api_group) Group.
	,state_int -- 'number' () The user's relationship to the group.
	)
	assert(not group_api_group or type(group_api_group) == "table", "Argument 'group_api_group' must be 'nil' or of type 'table'")
	assert(not state_int or type(state_int) == "number", "Argument 'state_int' must be 'nil' or of type 'number'")
	return {
		group = group_api_group,
		state = state_int,
	}
end

--------------------------------------------------------------------------------
--- validated_purchase_environment
-- - UNKNOWN: Unknown environment.
-- - SANDBOX: Sandbox/test environment.
-- - PRODUCTION: Production environment.
M.VALIDATEDPURCHASEENVIRONMENT_UNKNOWN = "UNKNOWN"
M.VALIDATEDPURCHASEENVIRONMENT_SANDBOX = "SANDBOX"
M.VALIDATEDPURCHASEENVIRONMENT_PRODUCTION = "PRODUCTION"

--------------------------------------------------------------------------------
--- validated_purchase_store
-- - APPLE_APP_STORE: Apple App Store
-- - GOOGLE_PLAY_STORE: Google Play Store
-- - HUAWEI_APP_GALLERY: Huawei App Gallery
M.VALIDATEDPURCHASESTORE_APPLE_APP_STORE = "APPLE_APP_STORE"
M.VALIDATEDPURCHASESTORE_GOOGLE_PLAY_STORE = "GOOGLE_PLAY_STORE"
M.VALIDATEDPURCHASESTORE_HUAWEI_APP_GALLERY = "HUAWEI_APP_GALLERY"

--------------------------------------------------------------------------------
--- create_write_leaderboard_record_request_leaderboard_record_write
-- Record values to write.
function M.create_write_leaderboard_record_request_leaderboard_record_write(
	metadata_str -- 'string' () Optional record metadata.
	,operator_api_override_operator -- 'string' (api_override_operator) Operator override.
	,score_str -- 'string' () The score value to submit.
	,subscore_str -- 'string' () An optional secondary value.
	)
	assert(not metadata_str or type(metadata_str) == "string", "Argument 'metadata_str' must be 'nil' or of type 'string'")
	assert(not operator_api_override_operator or type(operator_api_override_operator) == "string", "Argument 'operator_api_override_operator' must be 'nil' or of type 'string'")
	assert(not score_str or type(score_str) == "string", "Argument 'score_str' must be 'nil' or of type 'string'")
	assert(not subscore_str or type(subscore_str) == "string", "Argument 'subscore_str' must be 'nil' or of type 'string'")
	return {
		metadata = metadata_str,
		operator = operator_api_override_operator,
		score = score_str,
		subscore = subscore_str,
	}
end

--------------------------------------------------------------------------------
--- create_write_tournament_record_request_tournament_record_write
-- Record values to write.
function M.create_write_tournament_record_request_tournament_record_write(
	metadata_str -- 'string' () A JSON object of additional properties (optional).
	,operator_api_override_operator -- 'string' (api_override_operator) Operator override.
	,score_str -- 'string' () The score value to submit.
	,subscore_str -- 'string' () An optional secondary value.
	)
	assert(not metadata_str or type(metadata_str) == "string", "Argument 'metadata_str' must be 'nil' or of type 'string'")
	assert(not operator_api_override_operator or type(operator_api_override_operator) == "string", "Argument 'operator_api_override_operator' must be 'nil' or of type 'string'")
	assert(not score_str or type(score_str) == "string", "Argument 'score_str' must be 'nil' or of type 'string'")
	assert(not subscore_str or type(subscore_str) == "string", "Argument 'subscore_str' must be 'nil' or of type 'string'")
	return {
		metadata = metadata_str,
		operator = operator_api_override_operator,
		score = score_str,
		subscore = subscore_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_account
-- A user with additional account details. Always the current user.
function M.create_api_account(
	custom_id_str -- 'string' () The custom id in the user's account.
	,devices_arr -- 'table' () The devices which belong to the user's account.
	,disable_time_str -- 'string' () The UNIX time when the user's account was disabled/banned.
	,email_str -- 'string' () The email address of the user.
	,user_api_user -- 'table' (api_user) The user object.
	,verify_time_str -- 'string' () The UNIX time when the user's email was verified.
	,wallet_str -- 'string' () The user's wallet data.
	)
	assert(not custom_id_str or type(custom_id_str) == "string", "Argument 'custom_id_str' must be 'nil' or of type 'string'")
	assert(not devices_arr or type(devices_arr) == "table", "Argument 'devices_arr' must be 'nil' or of type 'table'")
	assert(not disable_time_str or type(disable_time_str) == "string", "Argument 'disable_time_str' must be 'nil' or of type 'string'")
	assert(not email_str or type(email_str) == "string", "Argument 'email_str' must be 'nil' or of type 'string'")
	assert(not user_api_user or type(user_api_user) == "table", "Argument 'user_api_user' must be 'nil' or of type 'table'")
	assert(not verify_time_str or type(verify_time_str) == "string", "Argument 'verify_time_str' must be 'nil' or of type 'string'")
	assert(not wallet_str or type(wallet_str) == "string", "Argument 'wallet_str' must be 'nil' or of type 'string'")
	return {
		customId = custom_id_str,
		devices = devices_arr,
		disableTime = disable_time_str,
		email = email_str,
		user = user_api_user,
		verifyTime = verify_time_str,
		wallet = wallet_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_account_apple
-- Send a Apple Sign In token to the server. Used with authenticate/link/unlink.
function M.create_api_account_apple(
	token_str -- 'string' () The ID token received from Apple to validate.
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not token_str or type(token_str) == "string", "Argument 'token_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		token = token_str,
		vars = vars_obj,
	}
end

--------------------------------------------------------------------------------
--- create_api_account_custom
-- Send a custom ID to the server. Used with authenticate/link/unlink.
function M.create_api_account_custom(
	id_str -- 'string' () A custom identifier.
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		id = id_str,
		vars = vars_obj,
	}
end

--------------------------------------------------------------------------------
--- create_api_account_device
-- Send a device to the server. Used with authenticate/link/unlink and user.
function M.create_api_account_device(
	id_str -- 'string' () A device identifier. Should be obtained by a platform-specific device API.
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		id = id_str,
		vars = vars_obj,
	}
end

--------------------------------------------------------------------------------
--- create_api_account_email
-- Send an email with password to the server. Used with authenticate/link/unlink.
function M.create_api_account_email(
	email_str -- 'string' () A valid RFC-5322 email address.
	,password_str -- 'string' () A password for the user account.
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not email_str or type(email_str) == "string", "Argument 'email_str' must be 'nil' or of type 'string'")
	assert(not password_str or type(password_str) == "string", "Argument 'password_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		email = email_str,
		password = password_str,
		vars = vars_obj,
	}
end

--------------------------------------------------------------------------------
--- create_api_account_facebook
-- Send a Facebook token to the server. Used with authenticate/link/unlink.
function M.create_api_account_facebook(
	token_str -- 'string' () The OAuth token received from Facebook to access their profile API.
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not token_str or type(token_str) == "string", "Argument 'token_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		token = token_str,
		vars = vars_obj,
	}
end

--------------------------------------------------------------------------------
--- create_api_account_facebook_instant_game
-- Send a Facebook Instant Game token to the server. Used with authenticate/link/unlink.
function M.create_api_account_facebook_instant_game(
	signed_player_info_str -- 'string' () 
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not signed_player_info_str or type(signed_player_info_str) == "string", "Argument 'signed_player_info_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		signedPlayerInfo = signed_player_info_str,
		vars = vars_obj,
	}
end

--------------------------------------------------------------------------------
--- create_api_account_game_center
-- Send Apple's Game Center account credentials to the server. Used with authenticate/link/unlink.
function M.create_api_account_game_center(
	bundle_id_str -- 'string' () Bundle ID (generated by GameCenter).
	,player_id_str -- 'string' () Player ID (generated by GameCenter).
	,public_key_url_str -- 'string' () The URL for the public encryption key.
	,salt_str -- 'string' () A random "NSString" used to compute the hash and keep it randomized.
	,signature_str -- 'string' () The verification signature data generated.
	,timestamp_seconds_str -- 'string' () Time since UNIX epoch when the signature was created.
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not bundle_id_str or type(bundle_id_str) == "string", "Argument 'bundle_id_str' must be 'nil' or of type 'string'")
	assert(not player_id_str or type(player_id_str) == "string", "Argument 'player_id_str' must be 'nil' or of type 'string'")
	assert(not public_key_url_str or type(public_key_url_str) == "string", "Argument 'public_key_url_str' must be 'nil' or of type 'string'")
	assert(not salt_str or type(salt_str) == "string", "Argument 'salt_str' must be 'nil' or of type 'string'")
	assert(not signature_str or type(signature_str) == "string", "Argument 'signature_str' must be 'nil' or of type 'string'")
	assert(not timestamp_seconds_str or type(timestamp_seconds_str) == "string", "Argument 'timestamp_seconds_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		bundleId = bundle_id_str,
		playerId = player_id_str,
		publicKeyUrl = public_key_url_str,
		salt = salt_str,
		signature = signature_str,
		timestampSeconds = timestamp_seconds_str,
		vars = vars_obj,
	}
end

--------------------------------------------------------------------------------
--- create_api_account_google
-- Send a Google token to the server. Used with authenticate/link/unlink.
function M.create_api_account_google(
	token_str -- 'string' () The OAuth token received from Google to access their profile API.
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not token_str or type(token_str) == "string", "Argument 'token_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		token = token_str,
		vars = vars_obj,
	}
end

--------------------------------------------------------------------------------
--- create_api_account_steam
-- Send a Steam token to the server. Used with authenticate/link/unlink.
function M.create_api_account_steam(
	token_str -- 'string' () The account token received from Steam to access their profile API.
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not token_str or type(token_str) == "string", "Argument 'token_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		token = token_str,
		vars = vars_obj,
	}
end

--------------------------------------------------------------------------------
--- create_api_channel_message
-- A message sent on a channel.
function M.create_api_channel_message(
	channel_id_str -- 'string' () The channel this message belongs to.
	,code_int -- 'number' () The code representing a message type or category.
	,content_str -- 'string' () The content payload.
	,create_time_str -- 'string' () The UNIX time when the message was created.
	,group_id_str -- 'string' () The ID of the group, or an empty string if this message was not sent through a group channel.
	,message_id_str -- 'string' () The unique ID of this message.
	,persistent_bool -- 'boolean' () True if the message was persisted to the channel's history, false otherwise.
	,room_name_str -- 'string' () The name of the chat room, or an empty string if this message was not sent through a chat room.
	,sender_id_str -- 'string' () Message sender, usually a user ID.
	,update_time_str -- 'string' () The UNIX time when the message was last updated.
	,user_id_one_str -- 'string' () The ID of the first DM user, or an empty string if this message was not sent through a DM chat.
	,user_id_two_str -- 'string' () The ID of the second DM user, or an empty string if this message was not sent through a DM chat.
	,username_str -- 'string' () The username of the message sender, if any.
	)
	assert(not channel_id_str or type(channel_id_str) == "string", "Argument 'channel_id_str' must be 'nil' or of type 'string'")
	assert(not code_int or type(code_int) == "number", "Argument 'code_int' must be 'nil' or of type 'number'")
	assert(not content_str or type(content_str) == "string", "Argument 'content_str' must be 'nil' or of type 'string'")
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not group_id_str or type(group_id_str) == "string", "Argument 'group_id_str' must be 'nil' or of type 'string'")
	assert(not message_id_str or type(message_id_str) == "string", "Argument 'message_id_str' must be 'nil' or of type 'string'")
	assert(not persistent_bool or type(persistent_bool) == "boolean", "Argument 'persistent_bool' must be 'nil' or of type 'boolean'")
	assert(not room_name_str or type(room_name_str) == "string", "Argument 'room_name_str' must be 'nil' or of type 'string'")
	assert(not sender_id_str or type(sender_id_str) == "string", "Argument 'sender_id_str' must be 'nil' or of type 'string'")
	assert(not update_time_str or type(update_time_str) == "string", "Argument 'update_time_str' must be 'nil' or of type 'string'")
	assert(not user_id_one_str or type(user_id_one_str) == "string", "Argument 'user_id_one_str' must be 'nil' or of type 'string'")
	assert(not user_id_two_str or type(user_id_two_str) == "string", "Argument 'user_id_two_str' must be 'nil' or of type 'string'")
	assert(not username_str or type(username_str) == "string", "Argument 'username_str' must be 'nil' or of type 'string'")
	return {
		channelId = channel_id_str,
		code = code_int,
		content = content_str,
		createTime = create_time_str,
		groupId = group_id_str,
		messageId = message_id_str,
		persistent = persistent_bool,
		roomName = room_name_str,
		senderId = sender_id_str,
		updateTime = update_time_str,
		userIdOne = user_id_one_str,
		userIdTwo = user_id_two_str,
		username = username_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_channel_message_list
-- A list of channel messages, usually a result of a list operation.
function M.create_api_channel_message_list(
	cacheable_cursor_str -- 'string' () Cacheable cursor to list newer messages. Durable and designed to be stored, unlike next/prev cursors.
	,messages_arr -- 'table' () A list of messages.
	,next_cursor_str -- 'string' () The cursor to send when retrieving the next page, if any.
	,prev_cursor_str -- 'string' () The cursor to send when retrieving the previous page, if any.
	)
	assert(not cacheable_cursor_str or type(cacheable_cursor_str) == "string", "Argument 'cacheable_cursor_str' must be 'nil' or of type 'string'")
	assert(not messages_arr or type(messages_arr) == "table", "Argument 'messages_arr' must be 'nil' or of type 'table'")
	assert(not next_cursor_str or type(next_cursor_str) == "string", "Argument 'next_cursor_str' must be 'nil' or of type 'string'")
	assert(not prev_cursor_str or type(prev_cursor_str) == "string", "Argument 'prev_cursor_str' must be 'nil' or of type 'string'")
	return {
		cacheableCursor = cacheable_cursor_str,
		messages = messages_arr,
		nextCursor = next_cursor_str,
		prevCursor = prev_cursor_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_create_group_request
-- Create a group with the current user as owner.
function M.create_api_create_group_request(
	avatar_url_str -- 'string' () A URL for an avatar image.
	,description_str -- 'string' () A description for the group.
	,lang_tag_str -- 'string' () The language expected to be a tag which follows the BCP-47 spec.
	,max_count_int -- 'number' () Maximum number of group members.
	,name_str -- 'string' () A unique name for the group.
	,open_bool -- 'boolean' () Mark a group as open or not where only admins can accept members.
	)
	assert(not avatar_url_str or type(avatar_url_str) == "string", "Argument 'avatar_url_str' must be 'nil' or of type 'string'")
	assert(not description_str or type(description_str) == "string", "Argument 'description_str' must be 'nil' or of type 'string'")
	assert(not lang_tag_str or type(lang_tag_str) == "string", "Argument 'lang_tag_str' must be 'nil' or of type 'string'")
	assert(not max_count_int or type(max_count_int) == "number", "Argument 'max_count_int' must be 'nil' or of type 'number'")
	assert(not name_str or type(name_str) == "string", "Argument 'name_str' must be 'nil' or of type 'string'")
	assert(not open_bool or type(open_bool) == "boolean", "Argument 'open_bool' must be 'nil' or of type 'boolean'")
	return {
		avatarUrl = avatar_url_str,
		description = description_str,
		langTag = lang_tag_str,
		maxCount = max_count_int,
		name = name_str,
		open = open_bool,
	}
end

--------------------------------------------------------------------------------
--- create_api_delete_storage_object_id
-- Storage objects to delete.
function M.create_api_delete_storage_object_id(
	collection_str -- 'string' () The collection which stores the object.
	,key_str -- 'string' () The key of the object within the collection.
	,version_str -- 'string' () The version hash of the object.
	)
	assert(not collection_str or type(collection_str) == "string", "Argument 'collection_str' must be 'nil' or of type 'string'")
	assert(not key_str or type(key_str) == "string", "Argument 'key_str' must be 'nil' or of type 'string'")
	assert(not version_str or type(version_str) == "string", "Argument 'version_str' must be 'nil' or of type 'string'")
	return {
		collection = collection_str,
		key = key_str,
		version = version_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_delete_storage_objects_request
-- Batch delete storage objects.
function M.create_api_delete_storage_objects_request(
	object_ids_arr -- 'table' () Batch of storage objects.
	)
	assert(not object_ids_arr or type(object_ids_arr) == "table", "Argument 'object_ids_arr' must be 'nil' or of type 'table'")
	return {
		objectIds = object_ids_arr,
	}
end

--------------------------------------------------------------------------------
--- create_api_event
-- Represents an event to be passed through the server to registered event handlers.
function M.create_api_event(
	external_bool -- 'boolean' () True if the event came directly from a client call, false otherwise.
	,name_str -- 'string' () An event name, type, category, or identifier.
	,properties_obj -- 'table' () Arbitrary event property values.
	,timestamp_str -- 'string' () The time when the event was triggered.
	)
	assert(not external_bool or type(external_bool) == "boolean", "Argument 'external_bool' must be 'nil' or of type 'boolean'")
	assert(not name_str or type(name_str) == "string", "Argument 'name_str' must be 'nil' or of type 'string'")
	assert(not properties_obj or type(properties_obj) == "table", "Argument 'properties_obj' must be 'nil' or of type 'table'")
	assert(not timestamp_str or type(timestamp_str) == "string", "Argument 'timestamp_str' must be 'nil' or of type 'string'")
	return {
		external = external_bool,
		name = name_str,
		properties = properties_obj,
		timestamp = timestamp_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_friend
-- A friend of a user.
function M.create_api_friend(
	state_int -- 'number' () The friend status.
	,update_time_str -- 'string' () Time of the latest relationship update.
	,user_api_user -- 'table' (api_user) The user object.
	)
	assert(not state_int or type(state_int) == "number", "Argument 'state_int' must be 'nil' or of type 'number'")
	assert(not update_time_str or type(update_time_str) == "string", "Argument 'update_time_str' must be 'nil' or of type 'string'")
	assert(not user_api_user or type(user_api_user) == "table", "Argument 'user_api_user' must be 'nil' or of type 'table'")
	return {
		state = state_int,
		updateTime = update_time_str,
		user = user_api_user,
	}
end

--------------------------------------------------------------------------------
--- create_api_friend_list
-- A collection of zero or more friends of the user.
function M.create_api_friend_list(
	cursor_str -- 'string' () Cursor for the next page of results, if any.
	,friends_arr -- 'table' () The Friend objects.
	)
	assert(not cursor_str or type(cursor_str) == "string", "Argument 'cursor_str' must be 'nil' or of type 'string'")
	assert(not friends_arr or type(friends_arr) == "table", "Argument 'friends_arr' must be 'nil' or of type 'table'")
	return {
		cursor = cursor_str,
		friends = friends_arr,
	}
end

--------------------------------------------------------------------------------
--- create_api_group
-- A group in the server.
function M.create_api_group(
	avatar_url_str -- 'string' () A URL for an avatar image.
	,create_time_str -- 'string' () The UNIX time when the group was created.
	,creator_id_str -- 'string' () The id of the user who created the group.
	,description_str -- 'string' () A description for the group.
	,edge_count_int -- 'number' () The current count of all members in the group.
	,id_str -- 'string' () The id of a group.
	,lang_tag_str -- 'string' () The language expected to be a tag which follows the BCP-47 spec.
	,max_count_int -- 'number' () The maximum number of members allowed.
	,metadata_str -- 'string' () Additional information stored as a JSON object.
	,name_str -- 'string' () The unique name of the group.
	,open_bool -- 'boolean' () Anyone can join open groups, otherwise only admins can accept members.
	,update_time_str -- 'string' () The UNIX time when the group was last updated.
	)
	assert(not avatar_url_str or type(avatar_url_str) == "string", "Argument 'avatar_url_str' must be 'nil' or of type 'string'")
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not creator_id_str or type(creator_id_str) == "string", "Argument 'creator_id_str' must be 'nil' or of type 'string'")
	assert(not description_str or type(description_str) == "string", "Argument 'description_str' must be 'nil' or of type 'string'")
	assert(not edge_count_int or type(edge_count_int) == "number", "Argument 'edge_count_int' must be 'nil' or of type 'number'")
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not lang_tag_str or type(lang_tag_str) == "string", "Argument 'lang_tag_str' must be 'nil' or of type 'string'")
	assert(not max_count_int or type(max_count_int) == "number", "Argument 'max_count_int' must be 'nil' or of type 'number'")
	assert(not metadata_str or type(metadata_str) == "string", "Argument 'metadata_str' must be 'nil' or of type 'string'")
	assert(not name_str or type(name_str) == "string", "Argument 'name_str' must be 'nil' or of type 'string'")
	assert(not open_bool or type(open_bool) == "boolean", "Argument 'open_bool' must be 'nil' or of type 'boolean'")
	assert(not update_time_str or type(update_time_str) == "string", "Argument 'update_time_str' must be 'nil' or of type 'string'")
	return {
		avatarUrl = avatar_url_str,
		createTime = create_time_str,
		creatorId = creator_id_str,
		description = description_str,
		edgeCount = edge_count_int,
		id = id_str,
		langTag = lang_tag_str,
		maxCount = max_count_int,
		metadata = metadata_str,
		name = name_str,
		open = open_bool,
		updateTime = update_time_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_group_list
-- One or more groups returned from a listing operation.
function M.create_api_group_list(
	cursor_str -- 'string' () A cursor used to get the next page.
	,groups_arr -- 'table' () One or more groups.
	)
	assert(not cursor_str or type(cursor_str) == "string", "Argument 'cursor_str' must be 'nil' or of type 'string'")
	assert(not groups_arr or type(groups_arr) == "table", "Argument 'groups_arr' must be 'nil' or of type 'table'")
	return {
		cursor = cursor_str,
		groups = groups_arr,
	}
end

--------------------------------------------------------------------------------
--- create_api_group_user_list
-- A list of users belonging to a group, along with their role.
function M.create_api_group_user_list(
	cursor_str -- 'string' () Cursor for the next page of results, if any.
	,group_users_arr -- 'table' () User-role pairs for a group.
	)
	assert(not cursor_str or type(cursor_str) == "string", "Argument 'cursor_str' must be 'nil' or of type 'string'")
	assert(not group_users_arr or type(group_users_arr) == "table", "Argument 'group_users_arr' must be 'nil' or of type 'table'")
	return {
		cursor = cursor_str,
		groupUsers = group_users_arr,
	}
end

--------------------------------------------------------------------------------
--- create_api_leaderboard_record
-- Represents a complete leaderboard record with all scores and associated metadata.
function M.create_api_leaderboard_record(
	create_time_str -- 'string' () The UNIX time when the leaderboard record was created.
	,expiry_time_str -- 'string' () The UNIX time when the leaderboard record expires.
	,leaderboard_id_str -- 'string' () The ID of the leaderboard this score belongs to.
	,max_num_score_int -- 'number' () The maximum number of score updates allowed by the owner.
	,metadata_str -- 'string' () Metadata.
	,num_score_int -- 'number' () The number of submissions to this score record.
	,owner_id_str -- 'string' () The ID of the score owner, usually a user or group.
	,rank_str -- 'string' () The rank of this record.
	,score_str -- 'string' () The score value.
	,subscore_str -- 'string' () An optional subscore value.
	,update_time_str -- 'string' () The UNIX time when the leaderboard record was updated.
	,username_str -- 'string' () The username of the score owner, if the owner is a user.
	)
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not expiry_time_str or type(expiry_time_str) == "string", "Argument 'expiry_time_str' must be 'nil' or of type 'string'")
	assert(not leaderboard_id_str or type(leaderboard_id_str) == "string", "Argument 'leaderboard_id_str' must be 'nil' or of type 'string'")
	assert(not max_num_score_int or type(max_num_score_int) == "number", "Argument 'max_num_score_int' must be 'nil' or of type 'number'")
	assert(not metadata_str or type(metadata_str) == "string", "Argument 'metadata_str' must be 'nil' or of type 'string'")
	assert(not num_score_int or type(num_score_int) == "number", "Argument 'num_score_int' must be 'nil' or of type 'number'")
	assert(not owner_id_str or type(owner_id_str) == "string", "Argument 'owner_id_str' must be 'nil' or of type 'string'")
	assert(not rank_str or type(rank_str) == "string", "Argument 'rank_str' must be 'nil' or of type 'string'")
	assert(not score_str or type(score_str) == "string", "Argument 'score_str' must be 'nil' or of type 'string'")
	assert(not subscore_str or type(subscore_str) == "string", "Argument 'subscore_str' must be 'nil' or of type 'string'")
	assert(not update_time_str or type(update_time_str) == "string", "Argument 'update_time_str' must be 'nil' or of type 'string'")
	assert(not username_str or type(username_str) == "string", "Argument 'username_str' must be 'nil' or of type 'string'")
	return {
		createTime = create_time_str,
		expiryTime = expiry_time_str,
		leaderboardId = leaderboard_id_str,
		maxNumScore = max_num_score_int,
		metadata = metadata_str,
		numScore = num_score_int,
		ownerId = owner_id_str,
		rank = rank_str,
		score = score_str,
		subscore = subscore_str,
		updateTime = update_time_str,
		username = username_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_leaderboard_record_list
-- A set of leaderboard records, may be part of a leaderboard records page or a batch of individual records.
function M.create_api_leaderboard_record_list(
	next_cursor_str -- 'string' () The cursor to send when retrieving the next page, if any.
	,owner_records_arr -- 'table' () A batched set of leaderboard records belonging to specified owners.
	,prev_cursor_str -- 'string' () The cursor to send when retrieving the previous page, if any.
	,records_arr -- 'table' () A list of leaderboard records.
	)
	assert(not next_cursor_str or type(next_cursor_str) == "string", "Argument 'next_cursor_str' must be 'nil' or of type 'string'")
	assert(not owner_records_arr or type(owner_records_arr) == "table", "Argument 'owner_records_arr' must be 'nil' or of type 'table'")
	assert(not prev_cursor_str or type(prev_cursor_str) == "string", "Argument 'prev_cursor_str' must be 'nil' or of type 'string'")
	assert(not records_arr or type(records_arr) == "table", "Argument 'records_arr' must be 'nil' or of type 'table'")
	return {
		nextCursor = next_cursor_str,
		ownerRecords = owner_records_arr,
		prevCursor = prev_cursor_str,
		records = records_arr,
	}
end

--------------------------------------------------------------------------------
--- create_api_link_steam_request
-- Link Steam to the current user's account.
function M.create_api_link_steam_request(
	account_api_account_steam -- 'table' (api_account_steam) The Facebook account details.
	,sync_bool -- 'boolean' () Import Steam friends for the user.
	)
	assert(not account_api_account_steam or type(account_api_account_steam) == "table", "Argument 'account_api_account_steam' must be 'nil' or of type 'table'")
	assert(not sync_bool or type(sync_bool) == "boolean", "Argument 'sync_bool' must be 'nil' or of type 'boolean'")
	return {
		account = account_api_account_steam,
		sync = sync_bool,
	}
end

--------------------------------------------------------------------------------
--- create_api_match
-- Represents a realtime match.
function M.create_api_match(
	authoritative_bool -- 'boolean' () True if it's an server-managed authoritative match, false otherwise.
	,handler_name_str -- 'string' () 
	,label_str -- 'string' () Match label, if any.
	,match_id_str -- 'string' () The ID of the match, can be used to join.
	,size_int -- 'number' () Current number of users in the match.
	,tick_rate_int -- 'number' () 
	)
	assert(not authoritative_bool or type(authoritative_bool) == "boolean", "Argument 'authoritative_bool' must be 'nil' or of type 'boolean'")
	assert(not handler_name_str or type(handler_name_str) == "string", "Argument 'handler_name_str' must be 'nil' or of type 'string'")
	assert(not label_str or type(label_str) == "string", "Argument 'label_str' must be 'nil' or of type 'string'")
	assert(not match_id_str or type(match_id_str) == "string", "Argument 'match_id_str' must be 'nil' or of type 'string'")
	assert(not size_int or type(size_int) == "number", "Argument 'size_int' must be 'nil' or of type 'number'")
	assert(not tick_rate_int or type(tick_rate_int) == "number", "Argument 'tick_rate_int' must be 'nil' or of type 'number'")
	return {
		authoritative = authoritative_bool,
		handlerName = handler_name_str,
		label = label_str,
		matchId = match_id_str,
		size = size_int,
		tickRate = tick_rate_int,
	}
end

--------------------------------------------------------------------------------
--- create_api_match_list
-- A list of realtime matches.
function M.create_api_match_list(
	matches_arr -- 'table' () A number of matches corresponding to a list operation.
	)
	assert(not matches_arr or type(matches_arr) == "table", "Argument 'matches_arr' must be 'nil' or of type 'table'")
	return {
		matches = matches_arr,
	}
end

--------------------------------------------------------------------------------
--- create_api_notification
-- A notification in the server.
function M.create_api_notification(
	code_int -- 'number' () Category code for this notification.
	,content_str -- 'string' () Content of the notification in JSON.
	,create_time_str -- 'string' () The UNIX time when the notification was created.
	,id_str -- 'string' () ID of the Notification.
	,persistent_bool -- 'boolean' () True if this notification was persisted to the database.
	,sender_id_str -- 'string' () ID of the sender, if a user. Otherwise 'null'.
	,subject_str -- 'string' () Subject of the notification.
	)
	assert(not code_int or type(code_int) == "number", "Argument 'code_int' must be 'nil' or of type 'number'")
	assert(not content_str or type(content_str) == "string", "Argument 'content_str' must be 'nil' or of type 'string'")
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not persistent_bool or type(persistent_bool) == "boolean", "Argument 'persistent_bool' must be 'nil' or of type 'boolean'")
	assert(not sender_id_str or type(sender_id_str) == "string", "Argument 'sender_id_str' must be 'nil' or of type 'string'")
	assert(not subject_str or type(subject_str) == "string", "Argument 'subject_str' must be 'nil' or of type 'string'")
	return {
		code = code_int,
		content = content_str,
		createTime = create_time_str,
		id = id_str,
		persistent = persistent_bool,
		senderId = sender_id_str,
		subject = subject_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_notification_list
-- A collection of zero or more notifications.
function M.create_api_notification_list(
	cacheable_cursor_str -- 'string' () Use this cursor to paginate notifications. Cache this to catch up to new notifications.
	,notifications_arr -- 'table' () Collection of notifications.
	)
	assert(not cacheable_cursor_str or type(cacheable_cursor_str) == "string", "Argument 'cacheable_cursor_str' must be 'nil' or of type 'string'")
	assert(not notifications_arr or type(notifications_arr) == "table", "Argument 'notifications_arr' must be 'nil' or of type 'table'")
	return {
		cacheableCursor = cacheable_cursor_str,
		notifications = notifications_arr,
	}
end

--------------------------------------------------------------------------------
--- api_override_operator
-- Operator that can be used to override the one set in the leaderboard.
--
-- - NO_OVERRIDE: Do not override the leaderboard operator.
-- - BEST: Override the leaderboard operator with BEST.
-- - SET: Override the leaderboard operator with SET.
-- - INCREMENT: Override the leaderboard operator with INCREMENT.
-- - DECREMENT: Override the leaderboard operator with DECREMENT.
M.APIOVERRIDEOPERATOR_NO_OVERRIDE = "NO_OVERRIDE"
M.APIOVERRIDEOPERATOR_BEST = "BEST"
M.APIOVERRIDEOPERATOR_SET = "SET"
M.APIOVERRIDEOPERATOR_INCREMENT = "INCREMENT"
M.APIOVERRIDEOPERATOR_DECREMENT = "DECREMENT"

--------------------------------------------------------------------------------
--- create_api_read_storage_object_id
-- Storage objects to get.
function M.create_api_read_storage_object_id(
	collection_str -- 'string' () The collection which stores the object.
	,key_str -- 'string' () The key of the object within the collection.
	,user_id_str -- 'string' () The user owner of the object.
	)
	assert(not collection_str or type(collection_str) == "string", "Argument 'collection_str' must be 'nil' or of type 'string'")
	assert(not key_str or type(key_str) == "string", "Argument 'key_str' must be 'nil' or of type 'string'")
	assert(not user_id_str or type(user_id_str) == "string", "Argument 'user_id_str' must be 'nil' or of type 'string'")
	return {
		collection = collection_str,
		key = key_str,
		userId = user_id_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_read_storage_objects_request
-- Batch get storage objects.
function M.create_api_read_storage_objects_request(
	object_ids_arr -- 'table' () Batch of storage objects.
	)
	assert(not object_ids_arr or type(object_ids_arr) == "table", "Argument 'object_ids_arr' must be 'nil' or of type 'table'")
	return {
		objectIds = object_ids_arr,
	}
end

--------------------------------------------------------------------------------
--- create_api_rpc
-- Execute an Lua function on the server.
function M.create_api_rpc(
	http_key_str -- 'string' () The authentication key used when executed as a non-client HTTP request.
	,id_str -- 'string' () The identifier of the function.
	,payload_str -- 'string' () The payload of the function which must be a JSON object.
	)
	assert(not http_key_str or type(http_key_str) == "string", "Argument 'http_key_str' must be 'nil' or of type 'string'")
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not payload_str or type(payload_str) == "string", "Argument 'payload_str' must be 'nil' or of type 'string'")
	return {
		httpKey = http_key_str,
		id = id_str,
		payload = payload_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_session
-- A user's session used to authenticate messages.
function M.create_api_session(
	created_bool -- 'boolean' () True if the corresponding account was just created, false otherwise.
	,refresh_token_str -- 'string' () Refresh token that can be used for session token renewal.
	,token_str -- 'string' () Authentication credentials.
	)
	assert(not created_bool or type(created_bool) == "boolean", "Argument 'created_bool' must be 'nil' or of type 'boolean'")
	assert(not refresh_token_str or type(refresh_token_str) == "string", "Argument 'refresh_token_str' must be 'nil' or of type 'string'")
	assert(not token_str or type(token_str) == "string", "Argument 'token_str' must be 'nil' or of type 'string'")
	return {
		created = created_bool,
		refreshToken = refresh_token_str,
		token = token_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_session_logout_request
-- Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user.
function M.create_api_session_logout_request(
	refresh_token_str -- 'string' () Refresh token to invalidate.
	,token_str -- 'string' () Session token to log out.
	)
	assert(not refresh_token_str or type(refresh_token_str) == "string", "Argument 'refresh_token_str' must be 'nil' or of type 'string'")
	assert(not token_str or type(token_str) == "string", "Argument 'token_str' must be 'nil' or of type 'string'")
	return {
		refreshToken = refresh_token_str,
		token = token_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_session_refresh_request
-- Authenticate against the server with a refresh token.
function M.create_api_session_refresh_request(
	token_str -- 'string' () Refresh token.
	,vars_obj -- 'table' () Extra information that will be bundled in the session token.
	)
	assert(not token_str or type(token_str) == "string", "Argument 'token_str' must be 'nil' or of type 'string'")
	assert(not vars_obj or type(vars_obj) == "table", "Argument 'vars_obj' must be 'nil' or of type 'table'")
	return {
		token = token_str,
		vars = vars_obj,
	}
end

--------------------------------------------------------------------------------
--- create_api_storage_object
-- An object within the storage engine.
function M.create_api_storage_object(
	collection_str -- 'string' () The collection which stores the object.
	,create_time_str -- 'string' () The UNIX time when the object was created.
	,key_str -- 'string' () The key of the object within the collection.
	,permission_read_int -- 'number' () The read access permissions for the object.
	,permission_write_int -- 'number' () The write access permissions for the object.
	,update_time_str -- 'string' () The UNIX time when the object was last updated.
	,user_id_str -- 'string' () The user owner of the object.
	,value_str -- 'string' () The value of the object.
	,version_str -- 'string' () The version hash of the object.
	)
	assert(not collection_str or type(collection_str) == "string", "Argument 'collection_str' must be 'nil' or of type 'string'")
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not key_str or type(key_str) == "string", "Argument 'key_str' must be 'nil' or of type 'string'")
	assert(not permission_read_int or type(permission_read_int) == "number", "Argument 'permission_read_int' must be 'nil' or of type 'number'")
	assert(not permission_write_int or type(permission_write_int) == "number", "Argument 'permission_write_int' must be 'nil' or of type 'number'")
	assert(not update_time_str or type(update_time_str) == "string", "Argument 'update_time_str' must be 'nil' or of type 'string'")
	assert(not user_id_str or type(user_id_str) == "string", "Argument 'user_id_str' must be 'nil' or of type 'string'")
	assert(not value_str or type(value_str) == "string", "Argument 'value_str' must be 'nil' or of type 'string'")
	assert(not version_str or type(version_str) == "string", "Argument 'version_str' must be 'nil' or of type 'string'")
	return {
		collection = collection_str,
		createTime = create_time_str,
		key = key_str,
		permissionRead = permission_read_int,
		permissionWrite = permission_write_int,
		updateTime = update_time_str,
		userId = user_id_str,
		value = value_str,
		version = version_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_storage_object_ack
-- A storage acknowledgement.
function M.create_api_storage_object_ack(
	collection_str -- 'string' () The collection which stores the object.
	,key_str -- 'string' () The key of the object within the collection.
	,user_id_str -- 'string' () The owner of the object.
	,version_str -- 'string' () The version hash of the object.
	)
	assert(not collection_str or type(collection_str) == "string", "Argument 'collection_str' must be 'nil' or of type 'string'")
	assert(not key_str or type(key_str) == "string", "Argument 'key_str' must be 'nil' or of type 'string'")
	assert(not user_id_str or type(user_id_str) == "string", "Argument 'user_id_str' must be 'nil' or of type 'string'")
	assert(not version_str or type(version_str) == "string", "Argument 'version_str' must be 'nil' or of type 'string'")
	return {
		collection = collection_str,
		key = key_str,
		userId = user_id_str,
		version = version_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_storage_object_acks
-- Batch of acknowledgements for the storage object write.
function M.create_api_storage_object_acks(
	acks_arr -- 'table' () Batch of storage write acknowledgements.
	)
	assert(not acks_arr or type(acks_arr) == "table", "Argument 'acks_arr' must be 'nil' or of type 'table'")
	return {
		acks = acks_arr,
	}
end

--------------------------------------------------------------------------------
--- create_api_storage_object_list
-- List of storage objects.
function M.create_api_storage_object_list(
	cursor_str -- 'string' () The cursor for the next page of results, if any.
	,objects_arr -- 'table' () The list of storage objects.
	)
	assert(not cursor_str or type(cursor_str) == "string", "Argument 'cursor_str' must be 'nil' or of type 'string'")
	assert(not objects_arr or type(objects_arr) == "table", "Argument 'objects_arr' must be 'nil' or of type 'table'")
	return {
		cursor = cursor_str,
		objects = objects_arr,
	}
end

--------------------------------------------------------------------------------
--- create_api_storage_objects
-- Batch of storage objects.
function M.create_api_storage_objects(
	objects_arr -- 'table' () The batch of storage objects.
	)
	assert(not objects_arr or type(objects_arr) == "table", "Argument 'objects_arr' must be 'nil' or of type 'table'")
	return {
		objects = objects_arr,
	}
end

--------------------------------------------------------------------------------
--- create_api_tournament
-- A tournament on the server.
function M.create_api_tournament(
	can_enter_bool -- 'boolean' () True if the tournament is active and can enter. A computed value.
	,category_int -- 'number' () The category of the tournament. e.g. "vip" could be category 1.
	,create_time_str -- 'string' () The UNIX time when the tournament was created.
	,description_str -- 'string' () The description of the tournament. May be blank.
	,duration_int -- 'number' () Duration of the tournament in seconds.
	,end_active_int -- 'number' () The UNIX time when the tournament stops being active until next reset. A computed value.
	,end_time_str -- 'string' () The UNIX time when the tournament will be stopped.
	,id_str -- 'string' () The ID of the tournament.
	,max_num_score_int -- 'number' () The maximum score updates allowed per player for the current tournament.
	,max_size_int -- 'number' () The maximum number of players for the tournament.
	,metadata_str -- 'string' () Additional information stored as a JSON object.
	,next_reset_int -- 'number' () The UNIX time when the tournament is next playable. A computed value.
	,size_int -- 'number' () The current number of players in the tournament.
	,sort_order_int -- 'number' () ASC or DESC sort mode of scores in the tournament.
	,start_active_int -- 'number' () The UNIX time when the tournament start being active. A computed value.
	,start_time_str -- 'string' () The UNIX time when the tournament will start.
	,title_str -- 'string' () The title for the tournament.
	)
	assert(not can_enter_bool or type(can_enter_bool) == "boolean", "Argument 'can_enter_bool' must be 'nil' or of type 'boolean'")
	assert(not category_int or type(category_int) == "number", "Argument 'category_int' must be 'nil' or of type 'number'")
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not description_str or type(description_str) == "string", "Argument 'description_str' must be 'nil' or of type 'string'")
	assert(not duration_int or type(duration_int) == "number", "Argument 'duration_int' must be 'nil' or of type 'number'")
	assert(not end_active_int or type(end_active_int) == "number", "Argument 'end_active_int' must be 'nil' or of type 'number'")
	assert(not end_time_str or type(end_time_str) == "string", "Argument 'end_time_str' must be 'nil' or of type 'string'")
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not max_num_score_int or type(max_num_score_int) == "number", "Argument 'max_num_score_int' must be 'nil' or of type 'number'")
	assert(not max_size_int or type(max_size_int) == "number", "Argument 'max_size_int' must be 'nil' or of type 'number'")
	assert(not metadata_str or type(metadata_str) == "string", "Argument 'metadata_str' must be 'nil' or of type 'string'")
	assert(not next_reset_int or type(next_reset_int) == "number", "Argument 'next_reset_int' must be 'nil' or of type 'number'")
	assert(not size_int or type(size_int) == "number", "Argument 'size_int' must be 'nil' or of type 'number'")
	assert(not sort_order_int or type(sort_order_int) == "number", "Argument 'sort_order_int' must be 'nil' or of type 'number'")
	assert(not start_active_int or type(start_active_int) == "number", "Argument 'start_active_int' must be 'nil' or of type 'number'")
	assert(not start_time_str or type(start_time_str) == "string", "Argument 'start_time_str' must be 'nil' or of type 'string'")
	assert(not title_str or type(title_str) == "string", "Argument 'title_str' must be 'nil' or of type 'string'")
	return {
		canEnter = can_enter_bool,
		category = category_int,
		createTime = create_time_str,
		description = description_str,
		duration = duration_int,
		endActive = end_active_int,
		endTime = end_time_str,
		id = id_str,
		maxNumScore = max_num_score_int,
		maxSize = max_size_int,
		metadata = metadata_str,
		nextReset = next_reset_int,
		size = size_int,
		sortOrder = sort_order_int,
		startActive = start_active_int,
		startTime = start_time_str,
		title = title_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_tournament_list
-- A list of tournaments.
function M.create_api_tournament_list(
	cursor_str -- 'string' () A pagination cursor (optional).
	,tournaments_arr -- 'table' () The list of tournaments returned.
	)
	assert(not cursor_str or type(cursor_str) == "string", "Argument 'cursor_str' must be 'nil' or of type 'string'")
	assert(not tournaments_arr or type(tournaments_arr) == "table", "Argument 'tournaments_arr' must be 'nil' or of type 'table'")
	return {
		cursor = cursor_str,
		tournaments = tournaments_arr,
	}
end

--------------------------------------------------------------------------------
--- create_api_tournament_record_list
-- A set of tournament records which may be part of a tournament records page or a batch of individual records.
function M.create_api_tournament_record_list(
	next_cursor_str -- 'string' () The cursor to send when retireving the next page (optional).
	,owner_records_arr -- 'table' () A batched set of tournament records belonging to specified owners.
	,prev_cursor_str -- 'string' () The cursor to send when retrieving the previous page (optional).
	,records_arr -- 'table' () A list of tournament records.
	)
	assert(not next_cursor_str or type(next_cursor_str) == "string", "Argument 'next_cursor_str' must be 'nil' or of type 'string'")
	assert(not owner_records_arr or type(owner_records_arr) == "table", "Argument 'owner_records_arr' must be 'nil' or of type 'table'")
	assert(not prev_cursor_str or type(prev_cursor_str) == "string", "Argument 'prev_cursor_str' must be 'nil' or of type 'string'")
	assert(not records_arr or type(records_arr) == "table", "Argument 'records_arr' must be 'nil' or of type 'table'")
	return {
		nextCursor = next_cursor_str,
		ownerRecords = owner_records_arr,
		prevCursor = prev_cursor_str,
		records = records_arr,
	}
end

--------------------------------------------------------------------------------
--- create_api_update_account_request
-- Update a user's account details.
function M.create_api_update_account_request(
	avatar_url_str -- 'string' () A URL for an avatar image.
	,display_name_str -- 'string' () The display name of the user.
	,lang_tag_str -- 'string' () The language expected to be a tag which follows the BCP-47 spec.
	,location_str -- 'string' () The location set by the user.
	,timezone_str -- 'string' () The timezone set by the user.
	,username_str -- 'string' () The username of the user's account.
	)
	assert(not avatar_url_str or type(avatar_url_str) == "string", "Argument 'avatar_url_str' must be 'nil' or of type 'string'")
	assert(not display_name_str or type(display_name_str) == "string", "Argument 'display_name_str' must be 'nil' or of type 'string'")
	assert(not lang_tag_str or type(lang_tag_str) == "string", "Argument 'lang_tag_str' must be 'nil' or of type 'string'")
	assert(not location_str or type(location_str) == "string", "Argument 'location_str' must be 'nil' or of type 'string'")
	assert(not timezone_str or type(timezone_str) == "string", "Argument 'timezone_str' must be 'nil' or of type 'string'")
	assert(not username_str or type(username_str) == "string", "Argument 'username_str' must be 'nil' or of type 'string'")
	return {
		avatarUrl = avatar_url_str,
		displayName = display_name_str,
		langTag = lang_tag_str,
		location = location_str,
		timezone = timezone_str,
		username = username_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_update_group_request
-- Update fields in a given group.
function M.create_api_update_group_request(
	avatar_url_str -- 'string' () Avatar URL.
	,description_str -- 'string' () Description string.
	,group_id_str -- 'string' () The ID of the group to update.
	,lang_tag_str -- 'string' () Lang tag.
	,name_str -- 'string' () Name.
	,open_bool -- 'boolean' () Open is true if anyone should be allowed to join, or false if joins must be approved by a group admin.
	)
	assert(not avatar_url_str or type(avatar_url_str) == "string", "Argument 'avatar_url_str' must be 'nil' or of type 'string'")
	assert(not description_str or type(description_str) == "string", "Argument 'description_str' must be 'nil' or of type 'string'")
	assert(not group_id_str or type(group_id_str) == "string", "Argument 'group_id_str' must be 'nil' or of type 'string'")
	assert(not lang_tag_str or type(lang_tag_str) == "string", "Argument 'lang_tag_str' must be 'nil' or of type 'string'")
	assert(not name_str or type(name_str) == "string", "Argument 'name_str' must be 'nil' or of type 'string'")
	assert(not open_bool or type(open_bool) == "boolean", "Argument 'open_bool' must be 'nil' or of type 'boolean'")
	return {
		avatarUrl = avatar_url_str,
		description = description_str,
		groupId = group_id_str,
		langTag = lang_tag_str,
		name = name_str,
		open = open_bool,
	}
end

--------------------------------------------------------------------------------
--- create_api_user
-- A user in the server.
function M.create_api_user(
	apple_id_str -- 'string' () The Apple Sign In ID in the user's account.
	,avatar_url_str -- 'string' () A URL for an avatar image.
	,create_time_str -- 'string' () The UNIX time when the user was created.
	,display_name_str -- 'string' () The display name of the user.
	,edge_count_int -- 'number' () Number of related edges to this user.
	,facebook_id_str -- 'string' () The Facebook id in the user's account.
	,facebook_instant_game_id_str -- 'string' () The Facebook Instant Game ID in the user's account.
	,gamecenter_id_str -- 'string' () The Apple Game Center in of the user's account.
	,google_id_str -- 'string' () The Google id in the user's account.
	,id_str -- 'string' () The id of the user's account.
	,lang_tag_str -- 'string' () The language expected to be a tag which follows the BCP-47 spec.
	,location_str -- 'string' () The location set by the user.
	,metadata_str -- 'string' () Additional information stored as a JSON object.
	,online_bool -- 'boolean' () Indicates whether the user is currently online.
	,steam_id_str -- 'string' () The Steam id in the user's account.
	,timezone_str -- 'string' () The timezone set by the user.
	,update_time_str -- 'string' () The UNIX time when the user was last updated.
	,username_str -- 'string' () The username of the user's account.
	)
	assert(not apple_id_str or type(apple_id_str) == "string", "Argument 'apple_id_str' must be 'nil' or of type 'string'")
	assert(not avatar_url_str or type(avatar_url_str) == "string", "Argument 'avatar_url_str' must be 'nil' or of type 'string'")
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not display_name_str or type(display_name_str) == "string", "Argument 'display_name_str' must be 'nil' or of type 'string'")
	assert(not edge_count_int or type(edge_count_int) == "number", "Argument 'edge_count_int' must be 'nil' or of type 'number'")
	assert(not facebook_id_str or type(facebook_id_str) == "string", "Argument 'facebook_id_str' must be 'nil' or of type 'string'")
	assert(not facebook_instant_game_id_str or type(facebook_instant_game_id_str) == "string", "Argument 'facebook_instant_game_id_str' must be 'nil' or of type 'string'")
	assert(not gamecenter_id_str or type(gamecenter_id_str) == "string", "Argument 'gamecenter_id_str' must be 'nil' or of type 'string'")
	assert(not google_id_str or type(google_id_str) == "string", "Argument 'google_id_str' must be 'nil' or of type 'string'")
	assert(not id_str or type(id_str) == "string", "Argument 'id_str' must be 'nil' or of type 'string'")
	assert(not lang_tag_str or type(lang_tag_str) == "string", "Argument 'lang_tag_str' must be 'nil' or of type 'string'")
	assert(not location_str or type(location_str) == "string", "Argument 'location_str' must be 'nil' or of type 'string'")
	assert(not metadata_str or type(metadata_str) == "string", "Argument 'metadata_str' must be 'nil' or of type 'string'")
	assert(not online_bool or type(online_bool) == "boolean", "Argument 'online_bool' must be 'nil' or of type 'boolean'")
	assert(not steam_id_str or type(steam_id_str) == "string", "Argument 'steam_id_str' must be 'nil' or of type 'string'")
	assert(not timezone_str or type(timezone_str) == "string", "Argument 'timezone_str' must be 'nil' or of type 'string'")
	assert(not update_time_str or type(update_time_str) == "string", "Argument 'update_time_str' must be 'nil' or of type 'string'")
	assert(not username_str or type(username_str) == "string", "Argument 'username_str' must be 'nil' or of type 'string'")
	return {
		appleId = apple_id_str,
		avatarUrl = avatar_url_str,
		createTime = create_time_str,
		displayName = display_name_str,
		edgeCount = edge_count_int,
		facebookId = facebook_id_str,
		facebookInstantGameId = facebook_instant_game_id_str,
		gamecenterId = gamecenter_id_str,
		googleId = google_id_str,
		id = id_str,
		langTag = lang_tag_str,
		location = location_str,
		metadata = metadata_str,
		online = online_bool,
		steamId = steam_id_str,
		timezone = timezone_str,
		updateTime = update_time_str,
		username = username_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_user_group_list
-- A list of groups belonging to a user, along with the user's role in each group.
function M.create_api_user_group_list(
	cursor_str -- 'string' () Cursor for the next page of results, if any.
	,user_groups_arr -- 'table' () Group-role pairs for a user.
	)
	assert(not cursor_str or type(cursor_str) == "string", "Argument 'cursor_str' must be 'nil' or of type 'string'")
	assert(not user_groups_arr or type(user_groups_arr) == "table", "Argument 'user_groups_arr' must be 'nil' or of type 'table'")
	return {
		cursor = cursor_str,
		userGroups = user_groups_arr,
	}
end

--------------------------------------------------------------------------------
--- create_api_users
-- A collection of zero or more users.
function M.create_api_users(
	users_arr -- 'table' () The User objects.
	)
	assert(not users_arr or type(users_arr) == "table", "Argument 'users_arr' must be 'nil' or of type 'table'")
	return {
		users = users_arr,
	}
end

--------------------------------------------------------------------------------
--- create_api_validate_purchase_apple_request
-- 
function M.create_api_validate_purchase_apple_request(
	receipt_str -- 'string' () Base64 encoded Apple receipt data payload.
	)
	assert(not receipt_str or type(receipt_str) == "string", "Argument 'receipt_str' must be 'nil' or of type 'string'")
	return {
		receipt = receipt_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_validate_purchase_google_request
-- 
function M.create_api_validate_purchase_google_request(
	purchase_str -- 'string' () JSON encoded Google purchase payload.
	)
	assert(not purchase_str or type(purchase_str) == "string", "Argument 'purchase_str' must be 'nil' or of type 'string'")
	return {
		purchase = purchase_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_validate_purchase_huawei_request
-- 
function M.create_api_validate_purchase_huawei_request(
	purchase_str -- 'string' () JSON encoded Huawei InAppPurchaseData.
	,signature_str -- 'string' () InAppPurchaseData signature.
	)
	assert(not purchase_str or type(purchase_str) == "string", "Argument 'purchase_str' must be 'nil' or of type 'string'")
	assert(not signature_str or type(signature_str) == "string", "Argument 'signature_str' must be 'nil' or of type 'string'")
	return {
		purchase = purchase_str,
		signature = signature_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_validate_purchase_response
-- 
function M.create_api_validate_purchase_response(
	validated_purchases_arr -- 'table' () Newly seen validated purchases.
	)
	assert(not validated_purchases_arr or type(validated_purchases_arr) == "table", "Argument 'validated_purchases_arr' must be 'nil' or of type 'table'")
	return {
		validatedPurchases = validated_purchases_arr,
	}
end

--------------------------------------------------------------------------------
--- create_api_validated_purchase
-- Validated Purchase stored by Nakama.
function M.create_api_validated_purchase(
	create_time_str -- 'string' () UNIX Timestamp when the receipt validation was stored in DB.
	,environment_validated_purchase_environment -- 'string' (validated_purchase_environment) Whether the purchase was done in production or sandbox environment.
	,product_id_str -- 'string' () Purchase Product ID.
	,provider_response_str -- 'string' () Raw provider validation response.
	,purchase_time_str -- 'string' () UNIX Timestamp when the purchase was done.
	,store_validated_purchase_store -- 'string' (validated_purchase_store) 
	,transaction_id_str -- 'string' () Purchase Transaction ID.
	,update_time_str -- 'string' () UNIX Timestamp when the receipt validation was updated in DB.
	)
	assert(not create_time_str or type(create_time_str) == "string", "Argument 'create_time_str' must be 'nil' or of type 'string'")
	assert(not environment_validated_purchase_environment or type(environment_validated_purchase_environment) == "string", "Argument 'environment_validated_purchase_environment' must be 'nil' or of type 'string'")
	assert(not product_id_str or type(product_id_str) == "string", "Argument 'product_id_str' must be 'nil' or of type 'string'")
	assert(not provider_response_str or type(provider_response_str) == "string", "Argument 'provider_response_str' must be 'nil' or of type 'string'")
	assert(not purchase_time_str or type(purchase_time_str) == "string", "Argument 'purchase_time_str' must be 'nil' or of type 'string'")
	assert(not store_validated_purchase_store or type(store_validated_purchase_store) == "string", "Argument 'store_validated_purchase_store' must be 'nil' or of type 'string'")
	assert(not transaction_id_str or type(transaction_id_str) == "string", "Argument 'transaction_id_str' must be 'nil' or of type 'string'")
	assert(not update_time_str or type(update_time_str) == "string", "Argument 'update_time_str' must be 'nil' or of type 'string'")
	return {
		createTime = create_time_str,
		environment = environment_validated_purchase_environment,
		productId = product_id_str,
		providerResponse = provider_response_str,
		purchaseTime = purchase_time_str,
		store = store_validated_purchase_store,
		transactionId = transaction_id_str,
		updateTime = update_time_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_write_storage_object
-- The object to store.
function M.create_api_write_storage_object(
	collection_str -- 'string' () The collection to store the object.
	,key_str -- 'string' () The key for the object within the collection.
	,permission_read_int -- 'number' () The read access permissions for the object.
	,permission_write_int -- 'number' () The write access permissions for the object.
	,value_str -- 'string' () The value of the object.
	,version_str -- 'string' () The version hash of the object to check. Possible values are: ["", "*", "#hash#"].
	)
	assert(not collection_str or type(collection_str) == "string", "Argument 'collection_str' must be 'nil' or of type 'string'")
	assert(not key_str or type(key_str) == "string", "Argument 'key_str' must be 'nil' or of type 'string'")
	assert(not permission_read_int or type(permission_read_int) == "number", "Argument 'permission_read_int' must be 'nil' or of type 'number'")
	assert(not permission_write_int or type(permission_write_int) == "number", "Argument 'permission_write_int' must be 'nil' or of type 'number'")
	assert(not value_str or type(value_str) == "string", "Argument 'value_str' must be 'nil' or of type 'string'")
	assert(not version_str or type(version_str) == "string", "Argument 'version_str' must be 'nil' or of type 'string'")
	return {
		collection = collection_str,
		key = key_str,
		permissionRead = permission_read_int,
		permissionWrite = permission_write_int,
		value = value_str,
		version = version_str,
	}
end

--------------------------------------------------------------------------------
--- create_api_write_storage_objects_request
-- Write objects to the storage engine.
function M.create_api_write_storage_objects_request(
	objects_arr -- 'table' () The objects to store on the server.
	)
	assert(not objects_arr or type(objects_arr) == "table", "Argument 'objects_arr' must be 'nil' or of type 'table'")
	return {
		objects = objects_arr,
	}
end

--------------------------------------------------------------------------------
--- create_protobuf_any
-- 
function M.create_protobuf_any(
	type_url_str -- 'string' () 
	,value_str -- 'string' () 
	)
	assert(not type_url_str or type(type_url_str) == "string", "Argument 'type_url_str' must be 'nil' or of type 'string'")
	assert(not value_str or type(value_str) == "string", "Argument 'value_str' must be 'nil' or of type 'string'")
	return {
		typeUrl = type_url_str,
		value = value_str,
	}
end

--------------------------------------------------------------------------------
--- create_rpc_status
-- 
function M.create_rpc_status(
	code_int -- 'number' () 
	,details_arr -- 'table' () 
	,message_str -- 'string' () 
	)
	assert(not code_int or type(code_int) == "number", "Argument 'code_int' must be 'nil' or of type 'number'")
	assert(not details_arr or type(details_arr) == "table", "Argument 'details_arr' must be 'nil' or of type 'table'")
	assert(not message_str or type(message_str) == "string", "Argument 'message_str' must be 'nil' or of type 'string'")
	return {
		code = code_int,
		details = details_arr,
		message = message_str,
	}
end

--------------------------------------------------------------------------------
-- The low level client for the Nakama API.

local _config = {}

--- Create a Nakama client instance
-- @param config
-- config.engine - Engine specific implementations
-- config.host
-- config.port
-- config.timeout
-- config.use_ssl - Use secure or non-secure sockets
-- config.bearer_token
-- config.username
-- config.password
-- @return Client instance
function M.create_client(config)
	assert(config, "You must provide a configuration")
	assert(config.host, "You must provide a host")
	assert(config.port, "You must provide a port")
	assert(config.engine, "You must provide an engine")
	assert(type(config.engine.http) == "function", "The engine must provide the 'http' function")
	assert(type(config.engine.socket_create) == "function", "The engine must provide the 'socket_create' function")
	assert(type(config.engine.socket_connect) == "function", "The engine must provide the 'socket_connect' function")
	assert(type(config.engine.socket_send) == "function", "The engine must provide the 'socket_send' function")
	log("init()")

	local client = {}
	local scheme = config.use_ssl and "https" or "http"
	client.engine = config.engine
	client.config = {}
	client.config.host = config.host
	client.config.port = config.port
	client.config.http_uri = ("%s://%s:%d"):format(scheme, config.host, config.port)
	client.config.bearer_token = config.bearer_token
	client.config.username = config.username
	client.config.password = config.password
	client.config.timeout = config.timeout or 10
	client.config.use_ssl = config.use_ssl

	return client
end

function M.on_notification(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_notification = fn
end
function M.on_matchdata(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_matchdata = fn
end
function M.on_matchpresence(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_matchpresence = fn
end
function M.on_matchmakermatched(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_matchmakermatched = fn
end
function M.on_statuspresence(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_statuspresence = fn
end
function M.on_streampresence(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_streampresence = fn
end
function M.on_streamdata(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_streamdata = fn
end
function M.on_channelmessage(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_channelmessage = fn
end
function M.on_channelpresence(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_channelpresence = fn
end
function M.on_disconnect(socket, fn)
	assert(socket, "You must provide a socket")
	socket.on_disconnect = fn
end

local function on_socket_message(socket, message)
	if message.notifications then
		if socket.on_notification then
			for n in ipairs(message.notifications.notifications) do
				socket.on_notification(message)
			end
		end
	elseif message.match_data then
		if socket.on_matchdata then
			message.match_data.data = b64.decode(message.match_data.data)
			socket.on_matchdata(message)
		end
	elseif message.match_presence_event then
		if socket.on_matchpresence then socket.on_matchpresence(message) end
	elseif message.matchmaker_matched then
		if socket.on_matchmakermatched then socket.on_matchmakermatched(message) end
	elseif message.status_presence_event then
		if socket.on_statuspresence then socket.on_statuspresence(message) end
	elseif message.stream_presence_event then
		if socket.on_streampresence then socket.on_streampresence(message) end
	elseif message.stream_data then
		if socket.on_streamdata then socket.on_streamdata(message) end
	elseif message.channel_message then
		if socket.on_channelmessage then socket.on_channelmessage(message) end
	elseif message.channel_presence_event then
		if socket.on_channelpresence then socket.on_channelpresence(message) end
	else
		log("Unhandled message")
	end
end

--- Create a Nakama socket
-- @param client The client to create the socket for
-- @return Socket instance
function M.create_socket(client)
	assert(client, "You must provide a client")
	local socket = client.engine.socket_create(client.config, on_socket_message)
	assert(socket, "No socket created")
	assert(type(socket) == "table", "The created instance must be a table")
	socket.client = client
	socket.engine = client.engine
	return socket
end

--- Attempt to connect a Nakama socket to the server
-- @param socket The client socket to connect (from call to create_socket)
-- @param callback Optional callback to invoke with the result
-- @return If no callback is provided the function returns the result
function M.socket_connect(socket, callback)
	assert(socket, "You must provide a socket")
	if callback then
		socket.engine.socket_connect(socket, callback)
	else
		return async(function(done)
			socket.engine.socket_connect(socket, done)
		end)
	end
end

--- Send message on Nakama socket
-- @param socket The client socket to use when sending the message
-- @param callback Optional callback to invoke with the result
-- @return If not callback is provided the function returns the result
function M.socket_send(socket, message, callback)
	assert(socket, "You must provide a socket")
	assert(message, "You must provide a message")
	if callback then
		socket.engine.socket_send(socket, message, callback)
	else
		return async(function(done)
			socket.engine.socket_send(socket, message, done)
		end)
	end
end

function M.sync(fn)
	local co = coroutine.create(fn)
	local ok, err = coroutine.resume(co)
	if not ok then
		log(err)
	end
end

function M.set_bearer_token(client, bearer_token)
	assert(client, "You must provide a client")
	client.config.bearer_token = bearer_token
end

--- healthcheck
-- A healthcheck which load balancers can use to check the service.
-- @param client Nakama client
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.healthcheck(
	client
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/healthcheck"

	local query_params = {}

	if callback then
		log("healthcheck() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			callback(result)
		end)
	else
		log("healthcheck() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- get_account
-- Fetch the current user's account.
-- @param client Nakama client
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.get_account(
	client
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account"

	local query_params = {}

	if callback then
		log("get_account() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_account then
				result = api_account.create(result)
			end
			callback(result)
		end)
	else
		log("get_account() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_account then
					result = api_account.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- update_account
-- Update fields in the current user's account.
-- @param client Nakama client
-- @param body_api_update_account_request (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.update_account(
	client
	,body_api_update_account_request
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account"

	local query_params = {}
	local post_data = json.encode(body_api_update_account_request)

	if callback then
		log("update_account() with callback")
		client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
			callback(result)
		end)
	else
		log("update_account() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- authenticate_apple
-- Authenticate a user with an Apple ID against the server.
-- @param client Nakama client
-- @param body_api_account_apple (table) The Apple account details.
-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.authenticate_apple(
	client
	,body_api_account_apple
	,create_bool
	,username_str
	,callback)
	assert(client, "You must provide a client")
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/apple"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_apple)

	if callback then
		log("authenticate_apple() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_apple() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_custom
-- Authenticate a user with a custom id against the server.
-- @param client Nakama client
-- @param body_api_account_custom (table) The custom account details.
-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.authenticate_custom(
	client
	,body_api_account_custom
	,create_bool
	,username_str
	,callback)
	assert(client, "You must provide a client")
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/custom"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_custom)

	if callback then
		log("authenticate_custom() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_custom() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_device
-- Authenticate a user with a device id against the server.
-- @param client Nakama client
-- @param body_api_account_device (table) The device account details.
-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.authenticate_device(
	client
	,body_api_account_device
	,create_bool
	,username_str
	,callback)
	assert(client, "You must provide a client")
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/device"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_device)

	if callback then
		log("authenticate_device() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_device() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_email
-- Authenticate a user with an email+password against the server.
-- @param client Nakama client
-- @param body_api_account_email (table) The email account details.
-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.authenticate_email(
	client
	,body_api_account_email
	,create_bool
	,username_str
	,callback)
	assert(client, "You must provide a client")
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/email"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_email)

	if callback then
		log("authenticate_email() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_email() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_facebook
-- Authenticate a user with a Facebook OAuth token against the server.
-- @param client Nakama client
-- @param body_api_account_facebook (table) The Facebook account details.
-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param sync_bool (boolean) Import Facebook friends for the user.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.authenticate_facebook(
	client
	,body_api_account_facebook
	,create_bool
	,username_str
	,sync_bool
	,callback)
	assert(client, "You must provide a client")
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/facebook"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	query_params["sync"] = sync_bool
	local post_data = json.encode(body_api_account_facebook)

	if callback then
		log("authenticate_facebook() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_facebook() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_facebook_instant_game
-- Authenticate a user with a Facebook Instant Game token against the server.
-- @param client Nakama client
-- @param body_api_account_facebook_instant_game (table) The Facebook Instant Game account details.
-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.authenticate_facebook_instant_game(
	client
	,body_api_account_facebook_instant_game
	,create_bool
	,username_str
	,callback)
	assert(client, "You must provide a client")
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/facebookinstantgame"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_facebook_instant_game)

	if callback then
		log("authenticate_facebook_instant_game() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_facebook_instant_game() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_game_center
-- Authenticate a user with Apple's GameCenter against the server.
-- @param client Nakama client
-- @param body_api_account_game_center (table) The Game Center account details.
-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.authenticate_game_center(
	client
	,body_api_account_game_center
	,create_bool
	,username_str
	,callback)
	assert(client, "You must provide a client")
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/gamecenter"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_game_center)

	if callback then
		log("authenticate_game_center() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_game_center() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_google
-- Authenticate a user with Google against the server.
-- @param client Nakama client
-- @param body_api_account_google (table) The Google account details.
-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.authenticate_google(
	client
	,body_api_account_google
	,create_bool
	,username_str
	,callback)
	assert(client, "You must provide a client")
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/google"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	local post_data = json.encode(body_api_account_google)

	if callback then
		log("authenticate_google() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_google() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- authenticate_steam
-- Authenticate a user with Steam against the server.
-- @param client Nakama client
-- @param body_api_account_steam (table) The Steam account details.
-- @param create_bool (boolean) Register the account if the user does not already exist.
-- @param username_str (string) Set the username on the account at register. Must be unique.
-- @param sync_bool (boolean) Import Steam friends for the user.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.authenticate_steam(
	client
	,body_api_account_steam
	,create_bool
	,username_str
	,sync_bool
	,callback)
	assert(client, "You must provide a client")
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	local url_path = "/v2/account/authenticate/steam"

	local query_params = {}
	query_params["create"] = create_bool
	query_params["username"] = username_str
	query_params["sync"] = sync_bool
	local post_data = json.encode(body_api_account_steam)

	if callback then
		log("authenticate_steam() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("authenticate_steam() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- link_apple
-- Add an Apple ID to the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_apple (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.link_apple(
	client
	,body_api_account_apple
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/link/apple"

	local query_params = {}
	local post_data = json.encode(body_api_account_apple)

	if callback then
		log("link_apple() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_apple() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_custom
-- Add a custom ID to the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_custom (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.link_custom(
	client
	,body_api_account_custom
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/link/custom"

	local query_params = {}
	local post_data = json.encode(body_api_account_custom)

	if callback then
		log("link_custom() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_custom() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_device
-- Add a device ID to the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_device (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.link_device(
	client
	,body_api_account_device
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/link/device"

	local query_params = {}
	local post_data = json.encode(body_api_account_device)

	if callback then
		log("link_device() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_device() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_email
-- Add an email+password to the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_email (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.link_email(
	client
	,body_api_account_email
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/link/email"

	local query_params = {}
	local post_data = json.encode(body_api_account_email)

	if callback then
		log("link_email() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_email() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_facebook
-- Add Facebook to the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_facebook (table) The Facebook account details.
-- @param sync_bool (boolean) Import Facebook friends for the user.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.link_facebook(
	client
	,body_api_account_facebook
	,sync_bool
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/link/facebook"

	local query_params = {}
	query_params["sync"] = sync_bool
	local post_data = json.encode(body_api_account_facebook)

	if callback then
		log("link_facebook() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_facebook() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_facebook_instant_game
-- Add Facebook Instant Game to the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_facebook_instant_game (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.link_facebook_instant_game(
	client
	,body_api_account_facebook_instant_game
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/link/facebookinstantgame"

	local query_params = {}
	local post_data = json.encode(body_api_account_facebook_instant_game)

	if callback then
		log("link_facebook_instant_game() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_facebook_instant_game() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_game_center
-- Add Apple's GameCenter to the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_game_center (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.link_game_center(
	client
	,body_api_account_game_center
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/link/gamecenter"

	local query_params = {}
	local post_data = json.encode(body_api_account_game_center)

	if callback then
		log("link_game_center() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_game_center() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_google
-- Add Google to the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_google (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.link_google(
	client
	,body_api_account_google
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/link/google"

	local query_params = {}
	local post_data = json.encode(body_api_account_google)

	if callback then
		log("link_google() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_google() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- link_steam
-- Add Steam to the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_link_steam_request (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.link_steam(
	client
	,body_api_link_steam_request
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/link/steam"

	local query_params = {}
	local post_data = json.encode(body_api_link_steam_request)

	if callback then
		log("link_steam() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("link_steam() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- session_refresh
-- Refresh a user's session using a refresh token retrieved from a previous authentication request.
-- @param client Nakama client
-- @param body_api_session_refresh_request (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.session_refresh(
	client
	,body_api_session_refresh_request
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/session/refresh"

	local query_params = {}
	local post_data = json.encode(body_api_session_refresh_request)

	if callback then
		log("session_refresh() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_session then
				result = api_session.create(result)
			end
			callback(result)
		end)
	else
		log("session_refresh() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_session then
					result = api_session.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- unlink_apple
-- Remove the Apple ID from the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_apple (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.unlink_apple(
	client
	,body_api_account_apple
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/unlink/apple"

	local query_params = {}
	local post_data = json.encode(body_api_account_apple)

	if callback then
		log("unlink_apple() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_apple() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_custom
-- Remove the custom ID from the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_custom (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.unlink_custom(
	client
	,body_api_account_custom
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/unlink/custom"

	local query_params = {}
	local post_data = json.encode(body_api_account_custom)

	if callback then
		log("unlink_custom() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_custom() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_device
-- Remove the device ID from the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_device (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.unlink_device(
	client
	,body_api_account_device
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/unlink/device"

	local query_params = {}
	local post_data = json.encode(body_api_account_device)

	if callback then
		log("unlink_device() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_device() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_email
-- Remove the email+password from the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_email (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.unlink_email(
	client
	,body_api_account_email
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/unlink/email"

	local query_params = {}
	local post_data = json.encode(body_api_account_email)

	if callback then
		log("unlink_email() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_email() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_facebook
-- Remove Facebook from the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_facebook (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.unlink_facebook(
	client
	,body_api_account_facebook
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/unlink/facebook"

	local query_params = {}
	local post_data = json.encode(body_api_account_facebook)

	if callback then
		log("unlink_facebook() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_facebook() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_facebook_instant_game
-- Remove Facebook Instant Game profile from the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_facebook_instant_game (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.unlink_facebook_instant_game(
	client
	,body_api_account_facebook_instant_game
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/unlink/facebookinstantgame"

	local query_params = {}
	local post_data = json.encode(body_api_account_facebook_instant_game)

	if callback then
		log("unlink_facebook_instant_game() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_facebook_instant_game() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_game_center
-- Remove Apple's GameCenter from the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_game_center (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.unlink_game_center(
	client
	,body_api_account_game_center
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/unlink/gamecenter"

	local query_params = {}
	local post_data = json.encode(body_api_account_game_center)

	if callback then
		log("unlink_game_center() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_game_center() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_google
-- Remove Google from the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_google (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.unlink_google(
	client
	,body_api_account_google
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/unlink/google"

	local query_params = {}
	local post_data = json.encode(body_api_account_google)

	if callback then
		log("unlink_google() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_google() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- unlink_steam
-- Remove Steam from the social profiles on the current user's account.
-- @param client Nakama client
-- @param body_api_account_steam (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.unlink_steam(
	client
	,body_api_account_steam
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/account/unlink/steam"

	local query_params = {}
	local post_data = json.encode(body_api_account_steam)

	if callback then
		log("unlink_steam() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("unlink_steam() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_channel_messages
-- List a channel's message history.
-- @param client Nakama client
-- @param channel_id_str (string) The channel ID to list from.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param forward_bool (boolean) True if listing should be older messages to newer, false if reverse.
-- @param cursor_str (string) A pagination cursor, if any.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_channel_messages(
	client
	,channel_id_str
	,limit_int
	,forward_bool
	,cursor_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/channel/{channelId}"
	url_path = url_path:gsub("{channelId}", uri_encode(channel_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["forward"] = forward_bool
	query_params["cursor"] = cursor_str

	if callback then
		log("list_channel_messages() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_channel_message_list then
				result = api_channel_message_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_channel_messages() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_channel_message_list then
					result = api_channel_message_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- event
-- Submit an event for processing in the server's registered runtime custom events handler.
-- @param client Nakama client
-- @param body_api_event (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.event(
	client
	,body_api_event
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/event"

	local query_params = {}
	local post_data = json.encode(body_api_event)

	if callback then
		log("event() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("event() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- delete_friends
-- Delete one or more users by ID or username.
-- @param client Nakama client
-- @param ids_arr (table) The account id of a user.
-- @param usernames_arr (table) The account username of a user.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.delete_friends(
	client
	,ids_arr
	,usernames_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/friend"

	local query_params = {}
	query_params["ids"] = ids_arr
	query_params["usernames"] = usernames_arr

	if callback then
		log("delete_friends() with callback")
		client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
			callback(result)
		end)
	else
		log("delete_friends() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_friends
-- List all friends for the current user.
-- @param client Nakama client
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param state_int (number) The friend state to list.
-- @param cursor_str (string) An optional next page cursor.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_friends(
	client
	,limit_int
	,state_int
	,cursor_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/friend"

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["state"] = state_int
	query_params["cursor"] = cursor_str

	if callback then
		log("list_friends() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_friend_list then
				result = api_friend_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_friends() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_friend_list then
					result = api_friend_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- add_friends
-- Add friends by ID or username to a user's account.
-- @param client Nakama client
-- @param ids_arr (table) The account id of a user.
-- @param usernames_arr (table) The account username of a user.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.add_friends(
	client
	,ids_arr
	,usernames_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/friend"

	local query_params = {}
	query_params["ids"] = ids_arr
	query_params["usernames"] = usernames_arr

	if callback then
		log("add_friends() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("add_friends() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- block_friends
-- Block one or more users by ID or username.
-- @param client Nakama client
-- @param ids_arr (table) The account id of a user.
-- @param usernames_arr (table) The account username of a user.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.block_friends(
	client
	,ids_arr
	,usernames_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/friend/block"

	local query_params = {}
	query_params["ids"] = ids_arr
	query_params["usernames"] = usernames_arr

	if callback then
		log("block_friends() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("block_friends() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- import_facebook_friends
-- Import Facebook friends and add them to a user's account.
-- @param client Nakama client
-- @param body_api_account_facebook (table) The Facebook account details.
-- @param reset_bool (boolean) Reset the current user's friends list.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.import_facebook_friends(
	client
	,body_api_account_facebook
	,reset_bool
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/friend/facebook"

	local query_params = {}
	query_params["reset"] = reset_bool
	local post_data = json.encode(body_api_account_facebook)

	if callback then
		log("import_facebook_friends() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("import_facebook_friends() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- import_steam_friends
-- Import Steam friends and add them to a user's account.
-- @param client Nakama client
-- @param body_api_account_steam (table) The Facebook account details.
-- @param reset_bool (boolean) Reset the current user's friends list.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.import_steam_friends(
	client
	,body_api_account_steam
	,reset_bool
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/friend/steam"

	local query_params = {}
	query_params["reset"] = reset_bool
	local post_data = json.encode(body_api_account_steam)

	if callback then
		log("import_steam_friends() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("import_steam_friends() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_groups
-- List groups based on given filters.
-- @param client Nakama client
-- @param name_str (string) List groups that contain this value in their names.
-- @param cursor_str (string) Optional pagination cursor.
-- @param limit_int (number) Max number of groups to return. Between 1 and 100.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_groups(
	client
	,name_str
	,cursor_str
	,limit_int
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group"

	local query_params = {}
	query_params["name"] = name_str
	query_params["cursor"] = cursor_str
	query_params["limit"] = limit_int

	if callback then
		log("list_groups() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_group_list then
				result = api_group_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_groups() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_group_list then
					result = api_group_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- create_group
-- Create a new group with the current user as the owner.
-- @param client Nakama client
-- @param body_api_create_group_request (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.create_group(
	client
	,body_api_create_group_request
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group"

	local query_params = {}
	local post_data = json.encode(body_api_create_group_request)

	if callback then
		log("create_group() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_group then
				result = api_group.create(result)
			end
			callback(result)
		end)
	else
		log("create_group() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_group then
					result = api_group.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- delete_group
-- Delete a group by ID.
-- @param client Nakama client
-- @param group_id_str (string) The id of a group.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.delete_group(
	client
	,group_id_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}

	if callback then
		log("delete_group() with callback")
		client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
			callback(result)
		end)
	else
		log("delete_group() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- update_group
-- Update fields in a given group.
-- @param client Nakama client
-- @param group_id_str (string) The ID of the group to update.
-- @param body_api_update_group_request (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.update_group(
	client
	,group_id_str
	,body_api_update_group_request
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	local post_data = json.encode(body_api_update_group_request)

	if callback then
		log("update_group() with callback")
		client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
			callback(result)
		end)
	else
		log("update_group() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- add_group_users
-- Add users to a group.
-- @param client Nakama client
-- @param group_id_str (string) The group to add users to.
-- @param user_ids_arr (table) The users to add.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.add_group_users(
	client
	,group_id_str
	,user_ids_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/add"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	if callback then
		log("add_group_users() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("add_group_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- ban_group_users
-- Ban a set of users from a group.
-- @param client Nakama client
-- @param group_id_str (string) The group to ban users from.
-- @param user_ids_arr (table) The users to ban.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.ban_group_users(
	client
	,group_id_str
	,user_ids_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/ban"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	if callback then
		log("ban_group_users() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("ban_group_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- demote_group_users
-- Demote a set of users in a group to the next role down.
-- @param client Nakama client
-- @param group_id_str (string) The group ID to demote in.
-- @param user_ids_arr (table) The users to demote.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.demote_group_users(
	client
	,group_id_str
	,user_ids_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/demote"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	if callback then
		log("demote_group_users() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("demote_group_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- join_group
-- Immediately join an open group, or request to join a closed one.
-- @param client Nakama client
-- @param group_id_str (string) The group ID to join. The group must already exist.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.join_group(
	client
	,group_id_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/join"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}

	if callback then
		log("join_group() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("join_group() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- kick_group_users
-- Kick a set of users from a group.
-- @param client Nakama client
-- @param group_id_str (string) The group ID to kick from.
-- @param user_ids_arr (table) The users to kick.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.kick_group_users(
	client
	,group_id_str
	,user_ids_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/kick"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	if callback then
		log("kick_group_users() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("kick_group_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- leave_group
-- Leave a group the user is a member of.
-- @param client Nakama client
-- @param group_id_str (string) The group ID to leave.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.leave_group(
	client
	,group_id_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/leave"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}

	if callback then
		log("leave_group() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("leave_group() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- promote_group_users
-- Promote a set of users in a group to the next role up.
-- @param client Nakama client
-- @param group_id_str (string) The group ID to promote in.
-- @param user_ids_arr (table) The users to promote.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.promote_group_users(
	client
	,group_id_str
	,user_ids_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/promote"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	query_params["user_ids"] = user_ids_arr

	if callback then
		log("promote_group_users() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("promote_group_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_group_users
-- List all users that are part of a group.
-- @param client Nakama client
-- @param group_id_str (string) The group ID to list from.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param state_int (number) The group user state to list.
-- @param cursor_str (string) An optional next page cursor.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_group_users(
	client
	,group_id_str
	,limit_int
	,state_int
	,cursor_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/group/{groupId}/user"
	url_path = url_path:gsub("{groupId}", uri_encode(group_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["state"] = state_int
	query_params["cursor"] = cursor_str

	if callback then
		log("list_group_users() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_group_user_list then
				result = api_group_user_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_group_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_group_user_list then
					result = api_group_user_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- validate_purchase_apple
-- Validate Apple IAP Receipt
-- @param client Nakama client
-- @param body_api_validate_purchase_apple_request (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.validate_purchase_apple(
	client
	,body_api_validate_purchase_apple_request
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/iap/purchase/apple"

	local query_params = {}
	local post_data = json.encode(body_api_validate_purchase_apple_request)

	if callback then
		log("validate_purchase_apple() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_validate_purchase_response then
				result = api_validate_purchase_response.create(result)
			end
			callback(result)
		end)
	else
		log("validate_purchase_apple() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_validate_purchase_response then
					result = api_validate_purchase_response.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- validate_purchase_google
-- Validate Google IAP Receipt
-- @param client Nakama client
-- @param body_api_validate_purchase_google_request (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.validate_purchase_google(
	client
	,body_api_validate_purchase_google_request
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/iap/purchase/google"

	local query_params = {}
	local post_data = json.encode(body_api_validate_purchase_google_request)

	if callback then
		log("validate_purchase_google() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_validate_purchase_response then
				result = api_validate_purchase_response.create(result)
			end
			callback(result)
		end)
	else
		log("validate_purchase_google() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_validate_purchase_response then
					result = api_validate_purchase_response.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- validate_purchase_huawei
-- Validate Huawei IAP Receipt
-- @param client Nakama client
-- @param body_api_validate_purchase_huawei_request (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.validate_purchase_huawei(
	client
	,body_api_validate_purchase_huawei_request
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/iap/purchase/huawei"

	local query_params = {}
	local post_data = json.encode(body_api_validate_purchase_huawei_request)

	if callback then
		log("validate_purchase_huawei() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_validate_purchase_response then
				result = api_validate_purchase_response.create(result)
			end
			callback(result)
		end)
	else
		log("validate_purchase_huawei() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_validate_purchase_response then
					result = api_validate_purchase_response.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- delete_leaderboard_record
-- Delete a leaderboard record.
-- @param client Nakama client
-- @param leaderboard_id_str (string) The leaderboard ID to delete from.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.delete_leaderboard_record(
	client
	,leaderboard_id_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/leaderboard/{leaderboardId}"
	url_path = url_path:gsub("{leaderboardId}", uri_encode(leaderboard_id_str))

	local query_params = {}

	if callback then
		log("delete_leaderboard_record() with callback")
		client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
			callback(result)
		end)
	else
		log("delete_leaderboard_record() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_leaderboard_records
-- List leaderboard records.
-- @param client Nakama client
-- @param leaderboard_id_str (string) The ID of the leaderboard to list for.
-- @param owner_ids_arr (table) One or more owners to retrieve records for.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param cursor_str (string) A next or previous page cursor.
-- @param expiry_str (string) Expiry in seconds (since epoch) to begin fetching records from. Optional. 0 means from current time.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_leaderboard_records(
	client
	,leaderboard_id_str
	,owner_ids_arr
	,limit_int
	,cursor_str
	,expiry_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/leaderboard/{leaderboardId}"
	url_path = url_path:gsub("{leaderboardId}", uri_encode(leaderboard_id_str))

	local query_params = {}
	query_params["ownerIds"] = owner_ids_arr
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str
	query_params["expiry"] = expiry_str

	if callback then
		log("list_leaderboard_records() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_leaderboard_record_list then
				result = api_leaderboard_record_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_leaderboard_records() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_leaderboard_record_list then
					result = api_leaderboard_record_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- write_leaderboard_record
-- Write a record to a leaderboard.
-- @param client Nakama client
-- @param leaderboard_id_str (string) The ID of the leaderboard to write to.
-- @param body_write_leaderboard_record_request_leaderboard_record_write (table) Record input.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.write_leaderboard_record(
	client
	,leaderboard_id_str
	,body_write_leaderboard_record_request_leaderboard_record_write
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/leaderboard/{leaderboardId}"
	url_path = url_path:gsub("{leaderboardId}", uri_encode(leaderboard_id_str))

	local query_params = {}
	local post_data = json.encode(body_write_leaderboard_record_request_leaderboard_record_write)

	if callback then
		log("write_leaderboard_record() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_leaderboard_record then
				result = api_leaderboard_record.create(result)
			end
			callback(result)
		end)
	else
		log("write_leaderboard_record() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_leaderboard_record then
					result = api_leaderboard_record.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- list_leaderboard_records_around_owner
-- List leaderboard records that belong to a user.
-- @param client Nakama client
-- @param leaderboard_id_str (string) The ID of the tournament to list for.
-- @param owner_id_str (string) The owner to retrieve records around.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param expiry_str (string) Expiry in seconds (since epoch) to begin fetching records from.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_leaderboard_records_around_owner(
	client
	,leaderboard_id_str
	,owner_id_str
	,limit_int
	,expiry_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/leaderboard/{leaderboardId}/owner/{ownerId}"
	url_path = url_path:gsub("{leaderboardId}", uri_encode(leaderboard_id_str))
	url_path = url_path:gsub("{ownerId}", uri_encode(owner_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["expiry"] = expiry_str

	if callback then
		log("list_leaderboard_records_around_owner() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_leaderboard_record_list then
				result = api_leaderboard_record_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_leaderboard_records_around_owner() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_leaderboard_record_list then
					result = api_leaderboard_record_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- list_matches
-- Fetch list of running matches.
-- @param client Nakama client
-- @param limit_int (number) Limit the number of returned matches.
-- @param authoritative_bool (boolean) Authoritative or relayed matches.
-- @param label_str (string) Label filter.
-- @param min_size_int (number) Minimum user count.
-- @param max_size_int (number) Maximum user count.
-- @param query_str (string) Arbitrary label query.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_matches(
	client
	,limit_int
	,authoritative_bool
	,label_str
	,min_size_int
	,max_size_int
	,query_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/match"

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["authoritative"] = authoritative_bool
	query_params["label"] = label_str
	query_params["minSize"] = min_size_int
	query_params["maxSize"] = max_size_int
	query_params["query"] = query_str

	if callback then
		log("list_matches() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_match_list then
				result = api_match_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_matches() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_match_list then
					result = api_match_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- delete_notifications
-- Delete one or more notifications for the current user.
-- @param client Nakama client
-- @param ids_arr (table) The id of notifications.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.delete_notifications(
	client
	,ids_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/notification"

	local query_params = {}
	query_params["ids"] = ids_arr

	if callback then
		log("delete_notifications() with callback")
		client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
			callback(result)
		end)
	else
		log("delete_notifications() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "DELETE", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_notifications
-- Fetch list of notifications.
-- @param client Nakama client
-- @param limit_int (number) The number of notifications to get. Between 1 and 100.
-- @param cacheable_cursor_str (string) A cursor to page through notifications. May be cached by clients to get from point in time forwards.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_notifications(
	client
	,limit_int
	,cacheable_cursor_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/notification"

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["cacheableCursor"] = cacheable_cursor_str

	if callback then
		log("list_notifications() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_notification_list then
				result = api_notification_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_notifications() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_notification_list then
					result = api_notification_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- rpc_func2
-- Execute a Lua function on the server.
-- @param client Nakama client
-- @param id_str (string) The identifier of the function.
-- @param payload_str (string) The payload of the function which must be a JSON object.
-- @param http_key_str (string) The authentication key used when executed as a non-client HTTP request.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.rpc_func2(
	client
	,id_str
	,payload_str
	,http_key_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/rpc/{id}"
	url_path = url_path:gsub("{id}", uri_encode(id_str))

	local query_params = {}
	query_params["payload"] = payload_str
	query_params["httpKey"] = http_key_str

	if callback then
		log("rpc_func2() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_rpc then
				result = api_rpc.create(result)
			end
			callback(result)
		end)
	else
		log("rpc_func2() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_rpc then
					result = api_rpc.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- rpc_func
-- Execute a Lua function on the server.
-- @param client Nakama client
-- @param id_str (string) The identifier of the function.
-- @param body_ (table) The payload of the function which must be a JSON object.
-- @param http_key_str (string) The authentication key used when executed as a non-client HTTP request.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.rpc_func(
	client
	,id_str
	,body_
	,http_key_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/rpc/{id}"
	url_path = url_path:gsub("{id}", uri_encode(id_str))

	local query_params = {}
	query_params["httpKey"] = http_key_str
	local post_data = json.encode(body_)

	if callback then
		log("rpc_func() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_rpc then
				result = api_rpc.create(result)
			end
			callback(result)
		end)
	else
		log("rpc_func() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_rpc then
					result = api_rpc.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- session_logout
-- Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user.
-- @param client Nakama client
-- @param body_api_session_logout_request (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.session_logout(
	client
	,body_api_session_logout_request
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/session/logout"

	local query_params = {}
	local post_data = json.encode(body_api_session_logout_request)

	if callback then
		log("session_logout() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("session_logout() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- read_storage_objects
-- Get storage objects.
-- @param client Nakama client
-- @param body_api_read_storage_objects_request (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.read_storage_objects(
	client
	,body_api_read_storage_objects_request
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/storage"

	local query_params = {}
	local post_data = json.encode(body_api_read_storage_objects_request)

	if callback then
		log("read_storage_objects() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_storage_objects then
				result = api_storage_objects.create(result)
			end
			callback(result)
		end)
	else
		log("read_storage_objects() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_storage_objects then
					result = api_storage_objects.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- write_storage_objects
-- Write objects into the storage engine.
-- @param client Nakama client
-- @param body_api_write_storage_objects_request (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.write_storage_objects(
	client
	,body_api_write_storage_objects_request
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/storage"

	local query_params = {}
	local post_data = json.encode(body_api_write_storage_objects_request)

	if callback then
		log("write_storage_objects() with callback")
		client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
			if not result.error and api_storage_object_acks then
				result = api_storage_object_acks.create(result)
			end
			callback(result)
		end)
	else
		log("write_storage_objects() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
				if not result.error and api_storage_object_acks then
					result = api_storage_object_acks.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- delete_storage_objects
-- Delete one or more objects by ID or username.
-- @param client Nakama client
-- @param body_api_delete_storage_objects_request (table) 
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.delete_storage_objects(
	client
	,body_api_delete_storage_objects_request
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/storage/delete"

	local query_params = {}
	local post_data = json.encode(body_api_delete_storage_objects_request)

	if callback then
		log("delete_storage_objects() with callback")
		client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
			callback(result)
		end)
	else
		log("delete_storage_objects() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_storage_objects
-- List publicly readable storage objects in a given collection.
-- @param client Nakama client
-- @param collection_str (string) The collection which stores the object.
-- @param user_id_str (string) ID of the user.
-- @param limit_int (number) The number of storage objects to list. Between 1 and 100.
-- @param cursor_str (string) The cursor to page through results from.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_storage_objects(
	client
	,collection_str
	,user_id_str
	,limit_int
	,cursor_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/storage/{collection}"
	url_path = url_path:gsub("{collection}", uri_encode(collection_str))

	local query_params = {}
	query_params["userId"] = user_id_str
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str

	if callback then
		log("list_storage_objects() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_storage_object_list then
				result = api_storage_object_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_storage_objects() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_storage_object_list then
					result = api_storage_object_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- list_storage_objects2
-- List publicly readable storage objects in a given collection.
-- @param client Nakama client
-- @param collection_str (string) The collection which stores the object.
-- @param user_id_str (string) ID of the user.
-- @param limit_int (number) The number of storage objects to list. Between 1 and 100.
-- @param cursor_str (string) The cursor to page through results from.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_storage_objects2(
	client
	,collection_str
	,user_id_str
	,limit_int
	,cursor_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/storage/{collection}/{userId}"
	url_path = url_path:gsub("{collection}", uri_encode(collection_str))
	url_path = url_path:gsub("{userId}", uri_encode(user_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str

	if callback then
		log("list_storage_objects2() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_storage_object_list then
				result = api_storage_object_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_storage_objects2() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_storage_object_list then
					result = api_storage_object_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- list_tournaments
-- List current or upcoming tournaments.
-- @param client Nakama client
-- @param category_start_int (number) The start of the categories to include. Defaults to 0.
-- @param category_end_int (number) The end of the categories to include. Defaults to 128.
-- @param start_time_int (number) The start time for tournaments. Defaults to epoch.
-- @param end_time_int (number) The end time for tournaments. Defaults to +1 year from current Unix time.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param cursor_str (string) A next page cursor for listings (optional).
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_tournaments(
	client
	,category_start_int
	,category_end_int
	,start_time_int
	,end_time_int
	,limit_int
	,cursor_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/tournament"

	local query_params = {}
	query_params["categoryStart"] = category_start_int
	query_params["categoryEnd"] = category_end_int
	query_params["startTime"] = start_time_int
	query_params["endTime"] = end_time_int
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str

	if callback then
		log("list_tournaments() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_tournament_list then
				result = api_tournament_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_tournaments() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_tournament_list then
					result = api_tournament_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- list_tournament_records
-- List tournament records.
-- @param client Nakama client
-- @param tournament_id_str (string) The ID of the tournament to list for.
-- @param owner_ids_arr (table) One or more owners to retrieve records for.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param cursor_str (string) A next or previous page cursor.
-- @param expiry_str (string) Expiry in seconds (since epoch) to begin fetching records from.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_tournament_records(
	client
	,tournament_id_str
	,owner_ids_arr
	,limit_int
	,cursor_str
	,expiry_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/tournament/{tournamentId}"
	url_path = url_path:gsub("{tournamentId}", uri_encode(tournament_id_str))

	local query_params = {}
	query_params["ownerIds"] = owner_ids_arr
	query_params["limit"] = limit_int
	query_params["cursor"] = cursor_str
	query_params["expiry"] = expiry_str

	if callback then
		log("list_tournament_records() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_tournament_record_list then
				result = api_tournament_record_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_tournament_records() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_tournament_record_list then
					result = api_tournament_record_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- write_tournament_record2
-- Write a record to a tournament.
-- @param client Nakama client
-- @param tournament_id_str (string) The tournament ID to write the record for.
-- @param body_write_tournament_record_request_tournament_record_write (table) Record input.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.write_tournament_record2(
	client
	,tournament_id_str
	,body_write_tournament_record_request_tournament_record_write
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/tournament/{tournamentId}"
	url_path = url_path:gsub("{tournamentId}", uri_encode(tournament_id_str))

	local query_params = {}
	local post_data = json.encode(body_write_tournament_record_request_tournament_record_write)

	if callback then
		log("write_tournament_record2() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			if not result.error and api_leaderboard_record then
				result = api_leaderboard_record.create(result)
			end
			callback(result)
		end)
	else
		log("write_tournament_record2() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				if not result.error and api_leaderboard_record then
					result = api_leaderboard_record.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- write_tournament_record
-- Write a record to a tournament.
-- @param client Nakama client
-- @param tournament_id_str (string) The tournament ID to write the record for.
-- @param body_write_tournament_record_request_tournament_record_write (table) Record input.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.write_tournament_record(
	client
	,tournament_id_str
	,body_write_tournament_record_request_tournament_record_write
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/tournament/{tournamentId}"
	url_path = url_path:gsub("{tournamentId}", uri_encode(tournament_id_str))

	local query_params = {}
	local post_data = json.encode(body_write_tournament_record_request_tournament_record_write)

	if callback then
		log("write_tournament_record() with callback")
		client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
			if not result.error and api_leaderboard_record then
				result = api_leaderboard_record.create(result)
			end
			callback(result)
		end)
	else
		log("write_tournament_record() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "PUT", post_data, function(result)
				if not result.error and api_leaderboard_record then
					result = api_leaderboard_record.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- join_tournament
-- Attempt to join an open and running tournament.
-- @param client Nakama client
-- @param tournament_id_str (string) The ID of the tournament to join. The tournament must already exist.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.join_tournament(
	client
	,tournament_id_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/tournament/{tournamentId}/join"
	url_path = url_path:gsub("{tournamentId}", uri_encode(tournament_id_str))

	local query_params = {}

	if callback then
		log("join_tournament() with callback")
		client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
			callback(result)
		end)
	else
		log("join_tournament() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "POST", post_data, function(result)
				done(result)
			end)
		end)
	end
end

--- list_tournament_records_around_owner
-- List tournament records for a given owner.
-- @param client Nakama client
-- @param tournament_id_str (string) The ID of the tournament to list for.
-- @param owner_id_str (string) The owner to retrieve records around.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param expiry_str (string) Expiry in seconds (since epoch) to begin fetching records from.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_tournament_records_around_owner(
	client
	,tournament_id_str
	,owner_id_str
	,limit_int
	,expiry_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/tournament/{tournamentId}/owner/{ownerId}"
	url_path = url_path:gsub("{tournamentId}", uri_encode(tournament_id_str))
	url_path = url_path:gsub("{ownerId}", uri_encode(owner_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["expiry"] = expiry_str

	if callback then
		log("list_tournament_records_around_owner() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_tournament_record_list then
				result = api_tournament_record_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_tournament_records_around_owner() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_tournament_record_list then
					result = api_tournament_record_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- get_users
-- Fetch zero or more users by ID and/or username.
-- @param client Nakama client
-- @param ids_arr (table) The account id of a user.
-- @param usernames_arr (table) The account username of a user.
-- @param facebook_ids_arr (table) The Facebook ID of a user.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.get_users(
	client
	,ids_arr
	,usernames_arr
	,facebook_ids_arr
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/user"

	local query_params = {}
	query_params["ids"] = ids_arr
	query_params["usernames"] = usernames_arr
	query_params["facebookIds"] = facebook_ids_arr

	if callback then
		log("get_users() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_users then
				result = api_users.create(result)
			end
			callback(result)
		end)
	else
		log("get_users() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_users then
					result = api_users.create(result)
				end
				done(result)
			end)
		end)
	end
end

--- list_user_groups
-- List groups the current user belongs to.
-- @param client Nakama client
-- @param user_id_str (string) ID of the user.
-- @param limit_int (number) Max number of records to return. Between 1 and 100.
-- @param state_int (number) The user group state to list.
-- @param cursor_str (string) An optional next page cursor.
-- @param callback Optional callback function. If none is provided the function
-- is run from within a coroutine and will wait until the call completes and
-- return the result
function M.list_user_groups(
	client
	,user_id_str
	,limit_int
	,state_int
	,cursor_str
	,callback)
	assert(client, "You must provide a client")

	local url_path = "/v2/user/{userId}/group"
	url_path = url_path:gsub("{userId}", uri_encode(user_id_str))

	local query_params = {}
	query_params["limit"] = limit_int
	query_params["state"] = state_int
	query_params["cursor"] = cursor_str

	if callback then
		log("list_user_groups() with callback")
		client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
			if not result.error and api_user_group_list then
				result = api_user_group_list.create(result)
			end
			callback(result)
		end)
	else
		log("list_user_groups() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "GET", post_data, function(result)
				if not result.error and api_user_group_list then
					result = api_user_group_list.create(result)
				end
				done(result)
			end)
		end)
	end
end

return M
