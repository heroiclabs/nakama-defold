// Copyright 2018 The Nakama Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"text/template"
)

const codeTemplate string = `-- Code generated by codegen/main.go. DO NOT EDIT.

--[[--
The Nakama client SDK for Defold.

@module nakama
]]

local json = require "nakama.util.json"
local b64 = require "nakama.util.b64"
local log = require "nakama.util.log"
local async = require "nakama.util.async"
local api_session = require "nakama.session"
local socket = require "nakama.socket"

local uri = require "nakama.util.uri"
local uri_encode = uri.encode

local M = {}

--
-- Nakama RealTime API (using client socket)
--

--- Create a match.
-- @param socket The client socket to use when sending the message.
-- @param callback Optional callback to invoke with the result.
-- @return If no callback is provided the function returns the result.
function M.send_match_create(socket, callback)
	local message = {
		match_create = {}
	}
	return M.socket_send(socket, message, callback)
end

--- Add a current user to a match.
-- @param socket The client socket to use when sending the message.
-- @param match_id The match id string.
-- @param token The authorization token.
-- @param metadata A table of metadata.
-- @param callback Optional callback to invoke with the result.
-- @return If no callback is provided the function returns the result.
function M.send_match_join(socket, match_id, token, metadata, callback)
	assert(not match_id or (match_id and type(match_id) == "string"), "Argument 'match_id' must be 'nil' or of type 'string'")
	assert(not token or (token and type(token) == "string"), "Argument 'token' must be 'nil' or of type 'string'")
	local message = {
		match_join = {
			match_id = match_id,
			token = token,
			metadata = metadata,
		}
	}
	return M.socket_send(socket, message, callback)
end


--- Remove the current user from a match.
-- @param socket The client socket to use when sending the message.
-- @param match_id The match id string.
-- @param callback Optional callback to invoke with the result.
-- @return If no callback is provided the function returns the result.
function M.send_match_leave(socket, match_id, callback)
	assert(match_id and type(match_id) == "string", "Argument 'match_id' must be of type 'string'")
	local message = {
		match_leave = {
			match_id = match_id,
		}
	}
	return M.socket_send(socket, message, callback)
end


--- Send a channel chat message if the current user has permission.
-- @param socket The client socket to use when sending the message.
-- @param channel_id The channel id string.
-- @param content The message content string.
-- @param callback Optional callback to invoke with the result.
-- @return If no callback is provided the function returns the result.
function M.send_channel_message_send(socket, channel_id, content, callback)
	assert(channel_id and type(channel_id) == "string", "Argument 'channel_id' must be of type 'string'")
	assert(content and type(content) == "string", "Argument 'content' must be of type 'string'")
	local message = {
		channel_message_send = {
			channel_id = channel_id,
			content = content,
		}
	}
	return M.socket_send(socket, message, callback)
end


--- Update a channel chat message if the current user has permission.
-- @param socket The client socket to use when sending the message.
-- @param channel_id The channel id string.
-- @param message_id The message id string.
-- @param content The message content string.
-- @param callback Optional callback to invoke with the result.
-- @return If no callback is provided the function returns the result.
function M.send_channel_message_update(socket, channel_id, message_id, content, callback)
	assert(channel_id and type(channel_id) == "string", "Argument 'channel_id' must be of type 'string'")
	assert(message_id and type(message_id) == "string", "Argument 'message_id' must be of type 'string'")
	assert(content and type(content) == "string", "Argument 'content' must be of type 'string'")
	local message = {
		channel_message_update = {
			channel_id = channel_id,
			message_id = message_id,
			content = content,
		}
	}
	return M.socket_send(socket, message, callback)
end


--- Remove a channel chat message if the current user has permission.
-- @param socket The client socket to use when sending the message.
-- @param channel_id The channel id string.
-- @param message_id The message id string.
-- @param callback Optional callback to invoke with the result.
-- @return If no callback is provided the function returns the result.
function M.send_channel_message_remove(socket, channel_id, message_id, callback)
	assert(channel_id and type(channel_id) == "string", "Argument 'channel_id' must be of type 'string'")
	assert(message_id and type(message_id) == "string", "Argument 'message_id' must be of type 'string'")
	local message = {
		channel_message_remove = {
			channel_id = channel_id,
			message_id = message_id,
		}
	}
	return M.socket_send(socket, message, callback)
end


--- Add the current user to a chat channel.
-- @param socket The client socket to use when sending the message.
-- @param target The target channel id.
-- @param type The message type {"string","number"}.
-- @param persistence Is the message persistant boolean.
-- @param hidden Is the message hidden boolean.
-- @param callback Optional callback to invoke with the result.
-- @return If no callback is provided the function returns the result.
function M.send_channel_join(socket, target, type, persistence, hidden, callback)
	assert(target and type(target) == "string", "Argument 'target' must be of type 'string'")
	assert(type and type(type) == "number", "Argument 'type' must be of type 'number'")
	assert(persistence and type(persistence) == "boolean", "Argument 'persistence' must be of type 'boolean'")
	assert(hidden and type(hidden) == "boolean", "Argument 'hidden' must be of type 'boolean'")
	local message = {
		channel_join = {
			target = target,
			type = type,
			persistence = persistence,
			hidden = hidden,
		}
	}
	return M.socket_send(socket, message, callback)
end


--- Remove the current user from a chat channel.
-- @param socket The client socket to use when sending the message.
-- @param channel_id The channel id string.
-- @param callback Optional callback to invoke with the result.
-- @return If no callback is provided the function returns the result.
function M.send_channel_leave(socket, channel_id, callback)
	assert(channel_id and type(channel_id) == "string", "Argument 'channel_id' must be of type 'string'")
	local message = {
		channel_leave = {
			channel_id = channel_id,
		}
	}
	return M.socket_send(socket, message, callback)
end


--- Add the current user to a matchmaker.
-- @param socket The client socket to use when sending the message.
-- @param query The matchmaker query string.
-- @param min_count The minimum user count.
-- @param max_count The maximum user count.
-- @param string_properties A table of user string properties.
-- @param numeric_properties A table of user numeric properties.
-- @param callback Optional callback to invoke with the result.
-- @return If no callback is provided the function returns the result.
function M.send_matchmaker_add(socket, query, min_count, max_count, string_properties, numeric_properties, callback)
	assert(query and type(query) == "string", "Argument 'query' must be of type 'string'")
	assert(min_count and type(min_count) == "number", "Argument 'min_count' must be of type 'number'")
	assert(max_count and type(max_count) == "number", "Argument 'max_count' must be of type 'number'")
	local message = {
		matchmaker_add = {
			query = query,
			min_count = tostring(min_count),
			max_count = tostring(max_count),
			string_properties = string_properties,
			numeric_properties = numeric_properties,
		}
	}
	return M.socket_send(socket, message, callback)
end


--- Remove the current user from a matchmaker.
-- @param socket The client socket to use when sending the message.
-- @param ticket The matchmaker ticket.
-- @param callback Optional callback to invoke with the result.
-- @return If no callback is provided the function returns the result.
function M.send_matchmaker_remove(socket, ticket, callback)
	assert(ticket and type(ticket) == "string", "Argument 'ticket' must be of type 'string'")
	local message = {
		matchmaker_remove = {
			ticket = ticket
		}
	}
	return M.socket_send(socket, message, callback)
end


--- Send match data for the current user.
-- @param socket The client socket to use when sending the message.
-- @param match_id The match id string.
-- @param op_code The op_code number.
-- @param data The data string.
-- @param callback Optional callback to invoke with the result.
-- @return If no callback is provided the function returns the result.
function M.send_match_data(socket, match_id, op_code, data, callback)
	assert(match_id and type(match_id) == "string", "Argument 'match_id' must be of type 'string'")
	assert(op_code and type(op_code) == "number", "Argument 'op_code' must be of type 'number'")
	assert(data and type(data) == "string", "Argument 'data' must be of type 'string'")
	local message = {
		match_data_send = {
			match_id = match_id,
			op_code = op_code,
			data = b64.encode(data),
		}
	}
	return M.socket_send(socket, message, callback)
end


--- Subscribe the current user to follow another user's status updates.
-- @param socket The client socket to use when sending the message.
-- @param user_ids The user id string to follow.
-- @param callback Optional callback to invoke with the result.
-- @return If no callback is provided the function returns the result.
function M.send_status_follow(socket, user_ids, callback)
	assert(user_ids and type(user_ids) == "table", "Argument 'user_ids' must be of type 'table'")
	local message = {
		status_follow = {
			user_ids = user_ids
		}
	}
	return M.socket_send(socket, message, callback)
end


--- Unsubscribe the current user from following another user's status updates.
-- @param socket The client socket to use when sending the message.
-- @param user_ids The user id string to unfollow.
-- @param callback Optional callback to invoke with the result.
-- @return If no callback is provided the function returns the result.
function M.send_status_unfollow(socket, user_ids, callback)
	assert(user_ids and type(user_ids) == "table", "Argument 'user_ids' must be of type 'table'")
	local message = {
		status_unfollow = {
			user_ids = user_ids
		}
	}
	return M.socket_send(socket, message, callback)
end


--- Update the current user's status.
-- @param socket The client socket to use when sending the message.
-- @param status The status update string.
-- @param callback Optional callback to invoke with the result.
-- @return If no callback is provided the function returns the result.
function M.send_status_update(socket, status, callback)
	assert(status and type(status) == "string", "Argument 'status' must be of type 'string'")
	local message = {
		status_update = {
			status = status
		}
	}
	return M.socket_send(socket, message, callback)
end


--- Create party.
-- @param socket The client socket to use when sending the message.
-- @param status The status update string.
-- @param callback Optional callback to invoke with the result.
-- @return If no callback is provided the function returns the result.
function M.send_party_create(socket, status, callback)
	assert(status and type(status) == "string", "Argument 'status' must be of type 'string'")
	local message = {
		status_update = {
			status = status
		}
	}
	return M.socket_send(socket, message, callback)
end



--
-- Defines
--

{{- range $defname, $definition := .Definitions }}
{{- $classname := $defname | title }}
{{- if $definition.Enum }}

--- {{ $classname | pascalToSnake }}
-- {{ $definition.Description | stripNewlines }}
{{- range $i, $enum := $definition.Enum }}
M.{{ $classname | uppercase }}_{{ $enum }} = "{{ $enum }}"
{{- end }}
{{- end }}
{{- end }}

--
-- The low level client for the Nakama API.
--

local _config = {}

--- Create a Nakama client instance.
-- @param config A table of configuration options.
-- config.engine - Engine specific implementations.
-- config.host
-- config.port
-- config.timeout
-- config.use_ssl - Use secure or non-secure sockets.
-- config.bearer_token
-- config.username
-- config.password
-- @return Nakama Client instance.
function M.create_client(config)
	assert(config, "You must provide a configuration")
	assert(config.host, "You must provide a host")
	assert(config.port, "You must provide a port")
	assert(config.engine, "You must provide an engine")
	assert(type(config.engine.http) == "function", "The engine must provide the 'http' function")
	assert(type(config.engine.socket_create) == "function", "The engine must provide the 'socket_create' function")
	assert(type(config.engine.socket_connect) == "function", "The engine must provide the 'socket_connect' function")
	assert(type(config.engine.socket_send) == "function", "The engine must provide the 'socket_send' function")
	log("init()")

	local client = {}
	local scheme = config.use_ssl and "https" or "http"
	client.engine = config.engine
	client.config = {}
	client.config.host = config.host
	client.config.port = config.port
	client.config.http_uri = ("%s://%s:%d"):format(scheme, config.host, config.port)
	client.config.bearer_token = config.bearer_token
	client.config.username = config.username
	client.config.password = config.password
	client.config.timeout = config.timeout or 10
	client.config.use_ssl = config.use_ssl

	return client
end


--- Create a Nakama socket.
-- @param client The client to create the socket for.
-- @return Socket instance.
function M.create_socket(client)
	assert(client, "You must provide a client")
	return socket.create(client)
end

-- Private
function M.sync(fn)
	local co = coroutine.create(fn)
	local ok, err = coroutine.resume(co)
	if not ok then
		log(err)
	end
end

--- Set Nakama client bearer token.
-- @param client Nakama client.
-- @param bearer_token Authorization bearer token.
function M.set_bearer_token(client, bearer_token)
	assert(client, "You must provide a client")
	client.config.bearer_token = bearer_token
end


--
-- Nakama REST API
--

{{- range $url, $path := .Paths }}
	{{- range $method, $operation := $path}}

--- {{ $operation.OperationId | pascalToSnake | removePrefix }}
-- {{ $operation.Summary | stripNewlines }}
-- @param client Nakama client.
{{- range $i, $parameter := $operation.Parameters }}
{{- $luaType := luaType $parameter.Type $parameter.Schema.Ref }}
{{- $varName := varName $parameter.Name $parameter.Type $parameter.Schema.Ref }}
{{- $varName := $varName | pascalToSnake }}
{{- $varComment := varComment $parameter.Name $parameter.Type $parameter.Schema.Ref $parameter.Items.Type }}
{{- if eq $parameter.Name "body" }}
{{- bodyFunctionArgsDocs $parameter.Schema.Ref}}
{{- end }}
{{- if ne $parameter.Name "body" }}
-- @param {{ $varName }} ({{ $luaType}}) {{ $parameter.Description }}
{{- end }}

{{- end }}
-- @param callback Optional callback function.
-- A coroutine is used and the result returned if no function is provided.
-- @return The result.
function M.{{ $operation.OperationId | pascalToSnake | removePrefix }}(client
	{{- range $i, $parameter := $operation.Parameters }}
	{{- $luaType := luaType $parameter.Type $parameter.Schema.Ref }}
	{{- $varName := varName $parameter.Name $parameter.Type $parameter.Schema.Ref }}
	{{- $varName := $varName | pascalToSnake }}
	{{- $varComment := varComment $parameter.Name $parameter.Type $parameter.Schema.Ref $parameter.Items.Type }}
	{{- if eq $parameter.Name "body" }}
	{{- bodyFunctionArgs $parameter.Schema.Ref}}
	{{- end }}
	{{- if ne $parameter.Name "body" }}, {{ $varName }} {{- end }}
	{{- end }},callback)
	assert(client, "You must provide a client")
	{{- range $parameter := $operation.Parameters }}
	{{- $varName := varName $parameter.Name $parameter.Type $parameter.Schema.Ref }}
	{{- if eq $parameter.In "body" }}
	{{- bodyFunctionArgsAssert $parameter.Schema.Ref}}
	{{- end }}
	{{- end }}

	{{- if $operation.OperationId | isAuthenticateMethod }}
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil

	{{- end}}

	local url_path = "{{- $url }}"
	{{- range $parameter := $operation.Parameters }}
	{{- $varName := varName $parameter.Name $parameter.Type $parameter.Schema.Ref }}
	{{- if eq $parameter.In "path" }}
	url_path = url_path:gsub("{{- print "{" $parameter.Name "}"}}", uri_encode({{ $varName | pascalToSnake }}))
	{{- end }}
	{{- end }}

	local query_params = {}
	{{- range $parameter := $operation.Parameters}}
	{{- $varName := varName $parameter.Name $parameter.Type $parameter.Schema.Ref }}
	{{- if eq $parameter.In "query"}}
	query_params["{{- $parameter.Name }}"] = {{ $varName | pascalToSnake }}
	{{- end}}
	{{- end}}

	{{- range $parameter := $operation.Parameters }}
	{{- $varName := varName $parameter.Name $parameter.Type $parameter.Schema.Ref }}
	{{- if eq $parameter.In "body" }}
	
	local post_data = json.encode({
		{{- bodyFunctionArgsTable $parameter.Schema.Ref}}	})
	{{- end }}
	{{- end }}

	if callback then
		log("{{ $operation.OperationId | pascalToSnake | removePrefix }}() with callback")
		client.engine.http(client.config, url_path, query_params, "{{- $method | uppercase }}", post_data, function(result)
			{{- if $operation.Responses.Ok.Schema.Ref }}
			if not result.error and {{ $operation.Responses.Ok.Schema.Ref | cleanRef | pascalToSnake }} then
				result = {{ $operation.Responses.Ok.Schema.Ref | cleanRef | pascalToSnake }}.create(result)
			end
			{{- end }}
			callback(result)
		end)
	else
		log("{{ $operation.OperationId | pascalToSnake | removePrefix }}() with coroutine")
		return async(function(done)
			client.engine.http(client.config, url_path, query_params, "{{- $method | uppercase }}", post_data, function(result)
				{{- if $operation.Responses.Ok.Schema.Ref }}
				if not result.error and {{ $operation.Responses.Ok.Schema.Ref | cleanRef | pascalToSnake }} then
					result = {{ $operation.Responses.Ok.Schema.Ref | cleanRef | pascalToSnake }}.create(result)
				end
				{{- end }}
				done(result)
			end)
		end)
	end
end
	{{- end }}
{{- end }}

return M
`

var schema struct {
	Paths map[string]map[string]struct {
		Summary     string
		OperationId string
		Responses   struct {
			Ok struct {
				Schema struct {
					Ref string `json:"$ref"`
				}
			} `json:"200"`
		}
		Parameters []struct {
			Name     	string
			Description	string
			In       	string
			Required 	bool
			Type     	string   // used with primitives
			Items    	struct { // used with type "array"
				Type string
			}
			Schema struct { // used with http body
				Type string
				Ref  string `json:"$ref"`
			}
			Format   string // used with type "boolean"
		}
		Security []map[string][]struct {
		}
	}
	Definitions map[string]struct {
		Properties map[string]struct {
			Type  string
			Ref   string   `json:"$ref"` // used with object
			Items struct { // used with type "array"
				Type string
				Ref  string `json:"$ref"`
			}
			AdditionalProperties struct {
				Type string // used with type "map"
			}
			Format      string // used with type "boolean"
			Description string
		}
		Enum        []string
		Description string
		// used only by enums
		Title string
	}
}

func convertRefToClassName(input string) (className string) {
	cleanRef := strings.TrimPrefix(input, "#/definitions/")
	className = strings.Title(cleanRef)
	return
}

func stripNewlines(input string) (output string) {
	output = strings.Replace(input, "\n", "\n--", -1)
	return
}

func pascalToSnake(input string) (output string) {
	output = ""
	prev_low := false
	for _, v := range input {
		is_cap := v >= 'A' && v <= 'Z'
		is_low := v >= 'a' && v <= 'z'
		if is_cap && prev_low {
			output = output + "_"
		}
		output += strings.ToLower(string(v))
		prev_low = is_low
	}
	return
}

// camelToPascal converts a string from camel case to Pascal case.
func camelToPascal(camelCase string) (pascalCase string) {
	if len(camelCase) <= 0 {
		return ""
	}
	pascalCase = strings.ToUpper(string(camelCase[0])) + camelCase[1:]
	return
}
// pascalToCamel converts a Pascal case string to a camel case string.
func pascalToCamel(input string) (camelCase string) {
	if input == "" {
		return ""
	}
	camelCase = strings.ToLower(string(input[0]))
	camelCase += string(input[1:])
	return camelCase
}

func removePrefix(input string) (output string) {
	output = strings.Replace(input, "nakama_", "", -1)
	return
}

func isEnum(ref string) bool {
	// swagger schema definition keys have inconsistent casing
	var camelOk bool
	var pascalOk bool
	var enums []string

	cleanedRef := convertRefToClassName(ref)
	asCamel := pascalToCamel(cleanedRef)
	if _, camelOk = schema.Definitions[asCamel]; camelOk {
		enums = schema.Definitions[asCamel].Enum
	}

	asPascal := camelToPascal(cleanedRef)
	if _, pascalOk = schema.Definitions[asPascal]; pascalOk {
		enums = schema.Definitions[asPascal].Enum
	}

	if !pascalOk && !camelOk {
		return false
	}

	return len(enums) > 0
}

// Parameter type to Lua type
func luaType(p_type string, p_ref string) (out string) {
	if isEnum(p_ref) {
		out = "string"
		return
	}
	switch p_type {
		case "integer": out = "number"
		case "string": out = "string"
		case "boolean": out = "boolean"
		case "array": out = "table"
		case "object": out = "table"
		default: out = "table"
	}
	return
}

// Default value for Lua types
func luaDef(p_type string, p_ref string) (out string) {
	switch(p_type) {
		case "integer": out = "0"
		case "string": out = "\"\""
		case "boolean": out = "false"
		case "array": out = "{}"
		case "object": out = "{ _ = '' }"
		default: out = "M.create_" + pascalToSnake(convertRefToClassName(p_ref)) + "()"
	}
	return
}

// Lua variable name from name, type and ref
func varName(p_name string, p_type string, p_ref string) (out string) {
	switch(p_type) {
		case "integer": out = p_name + "_int"
		case "string": out = p_name + "_str"
		case "boolean": out = p_name + "_bool"
		case "array": out = p_name + "_arr"
		case "object": out = p_name + "_obj"
		default: out = p_name + "_" + pascalToSnake(convertRefToClassName(p_ref))
	}
	return
}

func varComment(p_name string, p_type string, p_ref string, p_item_type string) (out string) {
	switch(p_type) {
		case "integer": out = "number"
		case "string": out = "string"
		case "boolean": out = "boolean"
		case "array": out = "table (" + luaType(p_item_type, p_ref) + ")"
		case "object": out = "table (object)"
		default: out = "table (" + pascalToSnake(convertRefToClassName(p_ref)) + ")"
	}
	return
}

func isAuthenticateMethod(input string) (output bool) {
	output = strings.HasPrefix(input, "Nakama_Authenticate")
	return
}

func main() {
	// Argument flags
	var output = flag.String("output", "", "The output for generated code.")
	flag.Parse()

	inputs := flag.Args()
	if len(inputs) < 1 {
		fmt.Printf("No input file found: %s\n\n", inputs)
		fmt.Println("openapi-gen [flags] inputs...")
		flag.PrintDefaults()
		return
	}

	input := inputs[0]
	content, err := ioutil.ReadFile(input)
	if err != nil {
		fmt.Printf("Unable to read file: %s\n", err)
		return
	}


	if err := json.Unmarshal(content, &schema); err != nil {
		fmt.Printf("Unable to decode input %s : %s\n", input, err)
		return
	}


	// expand the body argument to individual function arguments
	bodyFunctionArgs := func(ref string) (output string) {
		ref = strings.Replace(ref, "#/definitions/", "", -1)
		for prop := range schema.Definitions[ref].Properties {
			output = output + ", " + prop
		}
		return
	}

	// expand the body argument to individual function argument docs
	bodyFunctionArgsDocs := func(ref string) (output string) {
		ref = strings.Replace(ref, "#/definitions/", "", -1)
		output = "\n"
		for prop, info := range schema.Definitions[ref].Properties {
			output = output + "-- @param " + prop + " (" + info.Type + ") " + info.Description + "\n"
		}
		return
	}

	// expand the body argument to individual asserts for the call args
	bodyFunctionArgsAssert := func(ref string) (output string) {
		ref = strings.Replace(ref, "#/definitions/", "", -1)
		output = "\n"
		for prop, info := range schema.Definitions[ref].Properties {
			luaType := luaType(info.Type, info.Ref)
			output = output + "\tassert(not " + prop + " or type(" + prop + ") == \"" + luaType + "\", \"Argument '" + prop + "' must be 'nil' or of type '" + luaType + "'\")\n"
		}
		return
	}

	// expand the body argument to individual asserts for the message body table
	bodyFunctionArgsTable := func(ref string) (output string) {
		ref = strings.Replace(ref, "#/definitions/", "", -1)
		output = "\n"
		for prop := range schema.Definitions[ref].Properties {
			output = output + "\t" + prop + " = " + prop + ",\n"
		}
		return
	}

	fmap := template.FuncMap{
		"cleanRef": convertRefToClassName,
		"stripNewlines": stripNewlines,
		"title": strings.Title,
		"uppercase": strings.ToUpper,
		"pascalToSnake": pascalToSnake,
		"luaType": luaType,
		"luaDef": luaDef,
		"varName": varName,
		"varComment": varComment,
		"bodyFunctionArgsDocs": bodyFunctionArgsDocs,
		"bodyFunctionArgs": bodyFunctionArgs,
		"bodyFunctionArgsAssert": bodyFunctionArgsAssert,
		"bodyFunctionArgsTable": bodyFunctionArgsTable,
		"isEnum": isEnum,
		"isAuthenticateMethod": isAuthenticateMethod,
		"removePrefix": removePrefix,
	}
	tmpl, err := template.New(input).Funcs(fmap).Parse(codeTemplate)
	if err != nil {
		fmt.Printf("Template parse error: %s\n", err)
		return
	}

	if len(*output) < 1 {
		tmpl.Execute(os.Stdout, schema)
		return
	}

	f, err := os.Create(*output)
	if err != nil {
		fmt.Printf("Unable to create file: %s\n", err)
		return
	}
	defer f.Close()

	writer := bufio.NewWriter(f)
	tmpl.Execute(writer, schema)
	writer.Flush()
}
