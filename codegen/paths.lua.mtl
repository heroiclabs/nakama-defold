local api_session = require "nakama.session"
local json = require "nakama.util.json"
local async = require "nakama.util.async"
local uri = require "nakama.util.uri"
local uri_encode = uri.encode

-- cancellation tokens associated with a coroutine
local cancellation_tokens = {}

-- cancel a cancellation token
function M.cancel(token)
	assert(token)
	token.cancelled = true
end

-- create a cancellation token
-- use this to cancel an ongoing API call or a sequence of API calls
-- @return token Pass the token to a call to nakama.sync() or to any of the API calls
function M.cancellation_token()
	local token = {
		cancelled = false
	}
	function token.cancel()
		token.cancelled = true
	end
	return token
end

-- Private
-- Run code within a coroutine
-- @param fn The code to run
-- @param cancellation_token Optional cancellation token to cancel the running code
function M.sync(fn, cancellation_token)
	assert(fn)
	local co = nil
	co = coroutine.create(function()
		cancellation_tokens[co] = cancellation_token
		fn()
		cancellation_tokens[co] = nil
	end)
	local ok, err = coroutine.resume(co)
	if not ok then
		log(err)
		cancellation_tokens[co] = nil
	end
end

-- http request helper used to reduce code duplication in all API functions below
local function http(client, callback, url_path, query_params, method, post_data, retry_policy, cancellation_token, handler_fn)
	if callback then
		log(url_path, "with callback")
		client.engine.http(client.config, url_path, query_params, method, post_data, retry_policy, cancellation_token, function(result)
			if not cancellation_token or not cancellation_token.cancelled then
				callback(handler_fn(result))
			end
		end)
	else
		log(url_path, "with coroutine")
		local co = coroutine.running()
		assert(co, "You must be running this from withing a coroutine")

		-- get cancellation token associated with this coroutine
		cancellation_token = cancellation_tokens[co]
		if cancellation_token and cancellation_token.cancelled then
			cancellation_tokens[co] = nil
			return
		end

		return async(function(done)
			client.engine.http(client.config, url_path, query_params, method, post_data, retry_policy, cancellation_token, function(result)
				if cancellation_token and cancellation_token.cancelled then
					cancellation_tokens[co] = nil
					return
				end
				done(handler_fn(result))
			end)
		end)
	end
end

{{#paths}}

--- {{operationId}}
-- {{summary}}
-- @param client
{{#parameters}}
-- @param {{name_lua}} ({{type_lua}}) {{description}} {{title}}{{#required}} (REQUIRED){{/required}}
{{/parameters}}
-- @param callback (function) Optional callback function
-- A coroutine is used and the result is returned if no callback function is provided.
-- @param retry_policy (table) Optional retry policy used specifically for this call or nil
-- @param cancellation_token (table) Optional cancellation token for this call
-- @return The result.
function M.{{operationId}}(client{{#has_parameters}}, {{parameter_names}}{{/has_parameters}}, callback, retry_policy, cancellation_token)
	log("{{operationId}}()")
	assert(client, "You must provide a client")
	{{#has_parameters}}
	{{#parameters}}
	{{#required}}
	assert(check_{{type}}({{name_lua}}), "You must provide parameter '{{name}}' of type '{{type}}'")
	{{/required}}
	{{/parameters}}
	{{/has_parameters}}

	{{#is_authentication_method}}
	-- unset the token so username+password credentials will be used
	client.config.bearer_token = nil
	{{/is_authentication_method}}

	local url_path = "{{path}}"
	{{#has_path_parameters}}
	{{#parameters}}
	{{#is_path_parameter}}
	url_path = url_path:gsub("{" .. "{{name}}" .. "}", uri_encode({{name_lua}}))
	{{/is_path_parameter}}
	{{/parameters}}
	{{/has_path_parameters}}

	local query_params = {}
	{{#has_query_parameters}}
	{{#parameters}}
	{{#is_query_parameter}}
	query_params["{{name}}"] = {{name_lua}}
	{{/is_query_parameter}}
	{{/parameters}}
	{{/has_query_parameters}}

	{{#has_body_parameters}}
	local post_data = json.encode({
	{{#parameters}}
	{{#is_body_parameter}}
		["{{name}}"] = {{name_lua}},
	{{/is_body_parameter}}
	{{/parameters}}
	})
	{{/has_body_parameters}}
	{{^has_body_parameters}}
	local post_data = nil
	{{/has_body_parameters}}

	return http(client, callback, url_path, query_params, "{{method}}", post_data, retry_policy, cancellation_token, function(result)
		{{#responses}}
		{{#code}}
		-- {{description}}
		if result.code == {{code}} then
			{{#is_authentication_method}}
			if not result.error then
				result = api_session.create(result)
			end
			{{/is_authentication_method}}
			return result
		end
		{{/code}}
		{{^code}}
		-- {{description}}
		return result
		{{/code}}
		{{/responses}}
	end)
end
{{/paths}}